{
    "titleBlog": "First 250 days of software dev - Part {{order}}",
    "titleBlogIntro": "First 250 days of software dev - Intro",
    "minRead": "min read",
    "title": "{{textContent}}",
    "summaries" :{
        "1": "Day 1. I think I learned a lot today, or at least I think I studied a lot. I can briefly list the topics I studied as I remember them: I spent time on things like binary system, bits and bytes, which I had researched before but didn't go into much detail. I learned the concepts of big endian, little endian. I learned the difference between synchronous programming and asynchronous programming. Asynchronous seems to stay in my mind as \"I will call you back\". In short: when there is an operation that may take a long time in our code or there is a situation that may prevent it, doing other pending tasks and returning to the undone operation after finishing those tasks is called asynchronous programming. In other words, it doesn't do the sequence of operations in a straight line, and if an operation on that line fails, it skips it and continues on its way. Then it goes back there again. It's faster than synchronous because it doesn't get stuck in the same position. The number of threads is also important, of course, with two or three threads instead of one thread, the process can end much faster.",
        "2": "Day 11. I think today was also productive. I think the topics were reinforced a little more with many examples on objects and arrays. 11 days have passed and I have started to form my opinions on many topics. Today I found a site in the time left from the tasks: latentflip. On this site I ran some code I wrote myself and some code I found with setTimeout and other similar code structures and looked at how they work. I got a little more ideas about call stack, callback queue, and web api's and how asynchronous structure works. I especially looked at examples related to async...await and after the array-object topics, I wanted to work on them a lot, but there was not much opportunity. I'm going to work on the last assignment given today to complete it tomorrow because Saturday evening is the only space I gave myself.",
        "3": "Day 21. I really don't understand how 21 days have passed. I want to work hard, I want to learn a lot because I want to do my job very well. If 21 days have passed so fast, I think I should fit more things into each day. Life is short, even if it is relative. Yes, after this introduction, we can return to today. Although the next paragraph has nothing to do with work, I wrote it anyway, you can skip it. Today, I looked a lot about what event, event listener, etc. are, what they mean for a website and where they are used. I got lost in documents, problems and solutions. Your explanations at the end of the day were also useful.",
        "4": "Day 31. The best thing I learned today: When English resources are abundant, never look at Turkish resources first, and never look first at texts that the author has read from English resources and is likely to present from a narrow perspective. The first site and REST API and API examples that I haven't had a chance to take a good look at but will tomorrow morning (7 hours later): \"What is rest?\". The topic of the day was REST API. Initially I found a few resources but I didn't understand the raison d'être of what I was researching as I was stuck with them and they took my time explaining terms that were more technical than logical. Unfortunately I think I was able to understand it again by searching stackoverflow and accessing good resources. Lessons of the day: REST is the foundation of the web's architectural principle.",
        "5": "Day 41. Today, we examined and did the conversion of a program we worked on before and coded in Javascript into PHP. To be honest, it wasn't hard to convert it to PHP. In fact, nothing is difficult (at least from what we saw). I think it was only difficult because we were still new and we were seeing terms for the first time. The best part of today was that we contributed to something we had done before. If we were expected to build a structure from scratch, it would have been more difficult. I think it will be harder from now on, of course, because it was just like an exercise. It was like getting familiar with the terms, getting familiar with writing in PHP. Like practicing what, what does it do. After the server side (no matter how questionable the optimization is), I tried to combine it with HTML-CSS-Javascript. Before the Javascript part, I was a bit stuck on how to do the form operations. Then I solved that problem with your help. Although I don't have any problems when I work on the server side, there are some problems when processing data from the client. I put it as \"future development\" (when I say future, I wouldn't be surprised if it happens tomorrow).",
        "6": "Day 51. I don't feel like I'm struggling with CSS and HTML anymore. It takes a while to figure out what to use, how to use it and where to use it because there are so many ideas about how to design and so many possibilities of what to do. Of course it's more challenging because we only use coding where Javascript is used. I recently heard an Iranian saying something like \"a mystery is simple when its solved\". And it really was. Even though it seems easy when the solution is reached, it can be difficult beforehand. In Javascript or any other language, it requires problem solving skills to reach the desired solution, but once it is solved, it is understood that it is easy. Today HTML and CSS designs are completely finished for the given site design. I used small icon images instead of font awesome, I fixed those parts. I fixed the Product Cards a little bit and edited the effects on them. I made the sorting part and the picture part right next to the carousels.",
        "7": "Day 61. Today I read with admiration the JavaScript code you sent us to interpret. It was so well thought out that I felt like I couldn't have done it if I thought about it for 5 days. In 2 months, literacy was acquired, but I realized again today that there is a long way to become a good writer, literary writer, poet. I felt the expression \"I understand but I can't speak\" for English very well today. Yes, I know the purpose of the code, the meaning of the terms used, or I can find them immediately with a short search, but I still can't display a nimble and intelligent approach when it comes to doing the work. I hope it will improve with a little experience. I believe it will happen, because I love it so much. I think I used too many positive words like hope, faith, love. I think the reason is the Daft Punk song I listened to when I was looking at DOM and event handlers again after work. \"Work it harder, make it better Do it faster, makes us stronger More than ever, hour after hour Work is never over\"",
        "8": "...We have a sentence. Just as we make sense of it when we read it, we need to do the same for the machine. Our aim was to make the incoming data meaningful. In the last example (\"mer(h)aba\" (\"a\" asd) my \"sss\" asdasd`) how could I express that the parenthesis inside the quotation marks is part of the quotation mark and has no separate meaning? And of course the same applies to similar situations in other parts. Then the following can be done: Go through each element of the data one by one. If there is a nestedness (in the keywords used to construct the meaning), the problem is solved if I save the position (index) of the key element in the inner part somewhere and do not use it later to construct the meaningful structure. In the case of this nesting, all I need to see is not to see the inner element as the key element for that example. But if I am going to create a sub-node in a nested structure, I will of course need to take that into account as well. In short, we can produce different results depending on the problem we are facing. I think we need to make the most basic logical deductions to be able to use the language of the machine. And creating or trying to create a structure in this way pushes you into philosophy and mathematics. 4 months ago, I probably wouldn't have believed it. But I thought it was about subjects like artificial intelligence, which has \"words that seem too clever.\" However, even making a string entity meaningful is a very \"clever\" subject.",
        "9": "Day 81. For the first time, I approached a design that I think fits responsive from my point of view. When it comes to CSS, it feels a bit like magic, even though I know that it will give the desired outputs as long as the rules are followed. The topics we talked about in the meeting today made me think about some issues again and think about some problems from different angles. And I really didn't realize how time was passing and how much time had passed. Towards the end of the day, I looked at different CSS examples again. For example, I didn't know that there are online formatters that convert SCSS to CSS. Many beautiful designs on Codepen used SCSS, but I was skipping them directly, not using them and not examining them carefully. Now I've learned a shortcut for it too if it will be useful to me. Today, I spent the rest of the day trying to beautify the design in general and researching similar topics and examples.",
        "10": "...Then I looked at Actor Model and Alan Key had a Quora account and he answered a lot of questions. When I saw this, I was very impressed because he became one of the heroes of the fairy tales in my eyes. He mentioned that the Actor Model is actually not much different from OOP. In fact, since the pure object oriented logic that was first created turned a little more class oriented afterwards; he said that Actor Model is more similar to pure OOP than the OOP currently used. The reason is that it focuses on messaging as far as I understand. I understood the concurrency advantage, but since I haven't seen it in practice, I only grasped it logically. Apart from that, I guess Actor Model can also be used in PHP. So I thought why Actor Model is not used now instead of OOP. There were answers I found. But I didn't fully understand. The only point I can relate to is that there may be a similarity with why SmallTalk is not used now. Of course it is used, by the way, discrete (like microservice. I only know it as a concept. I have no idea about the details) especially for systems. But I realized that it is not very common.",
        "11": "Day 101. I wanted to illustrate the distinction between composition and dependency, so I produced one: human, mountain, Earth. The Earth contains the human and the mountain. There is a relationship of ownership and part-whole. The world is not dependent on the mountain or the human to exist. So there is no dependency here for the world. There is association in the most general sense. We can give the moon as a distinctive example for association. The Earth can use the Moon satellite to maintain the tides in the ocean object it possesses. Here the emphasis is on use rather than ownership. This is also an accosication. Man is a part of the world, but man can also exist outside the world object (he can live on different planets and satellites when appropriate conditions are met). The mountain cannot exist outside the earth. There is such a difference between Earth-human and Earth-mountain, even though the Earth has both. The Earth-human relationship is an aggregation relationship whose superset is asscociation. The Earth-mountain relation is a composition relation whose superset is association. We can grasp the concept from this narrow framework, since the example would be inefficient if we were to extend these lines of thought.",
        "12": "...The above examples are actually based entirely on the relationship between object and class in Java. Now let's look at how it is in PHP: Looking at the PHP Manual as the main source, we can see that object and class have a distinction similar to Java. But does this distinction exist in every language? This is where it gets complicated because every language has a different concept as far as I understand. I read that in Objective-C every class is an object, every class is an object. But since these classes are objects, they have to derive from a different class and this class is called metaclass. Just like an object is the expression of an ordinary instance, a metaclass is the expression of a class object (I didn't know anything about it, but since I said it with reference to those who know, I included a lot of -ish tenses).In Smalltalk, classes, numbers, strings, even the program itself are objects. I'm a bit confused, but I guess the rails will fall into place.",
        "13": "Day 121. When I looked at the calendar in the morning, I was surprised because I thought it was Wednesday. I don't know how this week went. I couldn't do what I wanted to do on time. When I looked at my code today, I felt like I was responsible for the murder of OCP (open-closed principle) in solid. Because it was both open for extension and open for modification, especially looking at the code I wrote today.  I try to realize the mistakes I've made before and then try not to make them. I refresh. Then I try again. Today I was stuck in the same places a lot, which was due to my own mistakes. I corrected the mistakes in the evening. Tomorrow I will be faster.",
        "14": "...This morning I watched what you did carefully because I acted with the motto \"let your eye be a thief, not your hand\" that my father learned from cooking and often told me. Afterwards, when I tried to do the drawer navigation, I encountered an error with a library due to a version error. When I Googled the problem, I found different solution methods. I was able to reach a solution by making changes in some codes in the files and removing the relevant library and adding a different version. Although my hand trembled at first with the thought that I would break it even more, then I reached the solution with the motto \"those who are afraid have no children\" and with caution. Then there was the problem of converting pages into file and folder structure. When I did research on this topic on the web, it was generally advised to establish a file-folder organization by classifying by feature (group by feature, or group by archetype) rather than by archetype. Although I thought of the same principle on the mobile side, since I saw the screen-component structure most frequently in the examples, it was a solution that converged to ten situations. I will continue with the last task tomorrow.",
        "15": "Day 141. First of all, I apologize if I have done anything wrong against my master today. If I seem to know too much about some things, it is my own ignorance. I realize that I know very little, it's just that sometimes I have the mistake of speaking in a certain way. Today, since there was no task at the beginning, I looked at two react-native related topics: how to check the internet connection and how to hide the keyboard when clicking on a different place. Then, when I couldn't think of anything, I read an article I saw yesterday (it was about software design and programming in general). But I didn't finish it. I hope I will summarize it here when I finish it. Then you provided the source code of the mobile application. I tried to grasp the subject you wrote about, how the application works on the backend, the connections and relationships. I think I understood something superficially. I must say that I was impressed when I saw the ternary operators and clean code.",
        "16": "Day 151. Today I experienced my greatest joy about programming within myself: I saw and you showed me that the code can be self-aware. I feel like there are so many things that can be done and learned that even thinking about it gives me a lot of pleasure. Apart from that, today I looked at the Laravel documentation in general. I saw how cross site request forguery can be blocked and its place in mvc. When I was looking at the View section and came across the Blade template engine, I remembered ofEngine and paid more attention. I could not examine it very carefully because the code related to Blade in Laravel was a bit too complicated, but I think I understand what the template engine does and how it works at the most basic level.",
        "17": "Day 161. I learned more about the steps I need to follow in single sign on. Although I haven't thought about every part in detail, I'm trying to follow and code a scheme on how a simple authorization and verification should be done. The problem I had today I couldn't solve at the end of the day. When a server sends a request to another server with the post method and wants to get the response (using axios), it can get the response without any problem when receiving normal and ordinary variables, but it cannot get the session information. However, session information can be accessed from everywhere else on that server. Even when retrieving data from that server with the get method, the session data is simply accessed. Tomorrow morning I will refocus and try to find the main source of the problem and solve it, or alternatively I will solve it with the get method. In addition, I transferred the transitions from the redirect method provided by express to a different url on the client side in the normal way. Everywhere I use it. Despite that, it continues.",
        "18": "Day 171. Today I wrote the functions I need to use most on the front end (on a simple messaging application). It's still at the most basic level, but it includes the front end part that I need for instant two-way communication using socket.io. Tomorrow and for the rest of this week I will work on the communication between server and client. My goal is to finish the websocket part on Saturday. I was planning to work this evening and complete the missing parts, but I didn't have the opportunity (as a result of time allocated for family and friends). Other than that, I think I can do the task. I will be very happy for myself if I can complete my requirements this week. Tomorrow I will directly adapt the simple chat application example in socket.io to the system I wrote and try to develop it from the very basics. I think I am progressing in a systematic way (a systematic progress in my own way, of course).  I think I will complete the basic parts and solve the problems as I encounter deficiencies.",
        "19": "Day 181. Today I finished uploading the file, transmitting the file to the user, using a data structure that I assume is appropriate in the backend, in less time than I expected. I need to enable the user to search for different users and their own past chat content, so they can add people they haven't started a chat with yet. I was going to go straight to the topic, but then I wanted to look at algorithms related to search in the book of algorithms. When I looked, I just read the different types of problems and solutions there. And of course I thought about them. For example, there was the \"Travelling salesman problem\" that I came across while looking at graph algorithms. I want to think about it on Sunday and look at its applications. As far as I understood, there was no general solution method and I was interested. Tomorrow I will continue as normal.",
        "20": "199. Day. Today I started to read the documentation provided by Google as an introduction to WebRTC. Since the document I read started directly with the coding part and the interpretation of the codes, I didn't read anything comprehensive that explains the essence of the event and the structure and logic of the technologies it uses. Afterwards, I researched the subject from Wikipedia and a few other sources. I need to get my hands dirty by getting some more ideas about the subject (by researching the subject a little more if I have the opportunity on vacation). On Thursday, I will start (try) to integrate these situations into the system. Day 200. I will make careful corrections tomorrow as some anomalies occurred while making changes in the code on the parts you showed me today. Before that, I tried to learn and implement live (stream peer-to-peer comm.) data exchange with WebRTC. First I tried to understand by copying the examples I found and reading the code, but I had some difficulties. I will return to this section after I make my application object-oriented.",
        "21": "...Today, although not the authentication part, the general chat logic has been made object-oriented. Tomorrow the goal is to make the codes related to authentication and then start and finish the folderization issue. I think a lot of corrections were made today. I think that when the authentication part is completed tomorrow, there will not be many problems on OOP. If there are problems, I think they can be fixed without difficulty. Of course, I also need to make the backend codes of the SSO server object-oriented. When all this is done, the basic features of an application that includes knowledge base and bug tracking will be extracted. In accordance with these features, a summary software requirements document can be prepared, or a template of objects with general requirements and usage scenarios suitable for these requirements can be created before implementing them into the system.  Of course, a report on these issues (bug tracking and kb) will also be written.",
        "22": "...I actually switched the application directly to electron today. Everything that used to work was still working normally. The Inter Process Communication part is as I understand it (I'm writing it again because I may look at these notes in the future): When Chrome or any browser is running, the user can open multiple tabs. As far as I understand, the most primitive browsers are thought of as a single tab. In case of multiple tabs, it was necessary to separate the javascript operations and memory operations of each tab. Because if a site explodes in one tab, all other tabs are affected and the browser crashes (I remember it hard because it was a long time ago, but yes there was such a thing). Each tab was called a separate process and all these small processes were managed by a main process. This method was later adopted by all other browsers. Electron follows the same logic here and divides it into main process and rendering process. It seemed like it could be considered as two separate contexts.",
        "23": "...I would like to make one last description so that I don't get carried away. A framework is like a faith/culture. Developers who use the same framework find a common ground, get along with each other and live in tolerance and live happily by continuing the same belief and culture in future generations. The language of this belief/culture is the spoken language of the developers. Some developers can be nationalistic in their faith/language. Some are multicultural by saying \"make peace don't war\", taking pollen from every language and belief and making honey. Laravel is like Judaism. It is an ancient faith and it derived from other faiths. And it opened the door to other beliefs. It has such a strong structure that it and the beliefs from which it derives have a very strong following. The language it uses is not very common anymore. And other languages are very popular. This does not cause the death of the language, but it reduces its popularity and reduces its community.",
        "24": "...Today's most beautiful non-technical post: On living (Nazım Hikmet): ...I mean, you will take life so seriously that even at seventy, for example, you will plant olives, not because you want to pass them on to your children or anything like that, but because you don't believe in death even though you are afraid of dying, because the living part of you predominates...",
        "25": "...\"Today I realize once again that my professors actually helped me find the best answer to the questions \"who is an engineer and what does he/she do\". The engineer solves problems. The problem-solving engineer is the synthesis of the eastern and western perspectives, writes, gives and reads reports. The engineer who gives a written report is acceptable. While writing a report, he/she defines problems, finds creative solutions, has the opportunity to see what he/she has not seen, has to interpret what he/she has written and draw conclusions, and the writing stays and the words fly away. The engineer who writes good reports reads good reports and questions well. The engineer who sees this fact has completed his/her individual institutionalization and is a very good managerial candidate. Senior managers who are aware of this fact know the value of the treasure in their hands. Those who cannot see it realize their material and moral losses later on.\"",
        "26": "A nice intro will be written here when inspiration strikes, or it can be written without waiting for the muse :)"

    }
}