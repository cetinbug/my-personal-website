{
    "titleBlog": "Yazılımın ilk 250 günü - Part {{order}}",
    "titleBlogIntro": "Yazılımın ilk 250 günü - Intro",
    "minRead": "dk okuma",
    "intro": {
        "1": "Buraya ilham geldiğinde güzel bir intro yazılacak ya da ilham perisi beklenmeden yazılabilir :)",
        "2": "Giriş"
    },
    "part1": {
        "1": "1. Gün",
        "2": "Bugün çok çok şey öğrendiğimi, en azından çalıştığımı düşünüyorum. Çalıştığım konuları, kısaca hafızamda kalan şekilleriyle sıralayabilirim:",
        "3": "Binary-bit-byte-shifting kavramları",
        "4": "Binary sistem, bit ve byte konuları gibi, hakkında daha önce araştırdığım fakat çok da detayına girmediğim şeylere zaman ayırdım. Big endian,little endian kavramlarını öğrendim.",
        "5": "Asenkronize programlama",
        "6": "Senkronize programlama ile farkını öğrendim. Asenkronize, “I will call you back” diye aklımda kalacak gibi görünüyor. Kısaca şu: kodlarımız içinde uzun sürebilecek bir işlem varken ya da engelleyebilecek bir durum varken, bekleyen diğer işleri yapmak ve o işleri bitirdikten sonra yapılmamış işleme geri dönmek asenkronize programlama diye geçiyor. Yani işlem sırasını düz bir çizgide yapmıyor ve o çizgi üstünde bir işlem hata verirse onu es geçip yoluna devam ediyor. Sonrasında tekrar oraya geri dönüyor. Senkronizeye göre daha hızlı çünkü olduğu konumda takılı kalmıyor. Thread sayılarının da bir önemi var tabii ki, bir thread yerine iki ya da üç thread le işlem çok daha hızlı sonlanabiliyor.",
        "7": "Javascript’te değişkenler, diziler ve object",
        "8": "Benzer örneklere bakıp, ilk kez web tarayıcıda console üstünden bir şeyler yazabildim. İlk adım olarak önemli görüyorum. Bir dizinin içeriğini oluşturmak ve object hakkında ufak örnekler yaptım ve inceledim. Değişken tiplerini öğrendim.",
        "9": "Scope hakkında",
        "10": "Var,let ve const ile değişken (ya da sabit) atamayı, bunların kullanımında scope özelliklerini öğrendim. Let ve const ile süslü parantez arasında bulunan scope (yani local scope) ta atama yapılınca global scope için bir anlam ifade etmediğini, aslında bunun da 'var' ile değişken tanımlamaya göre daha avantajlı olabileceğini öğrendim.",
        "11": "AST(Abstract Syntax Trees)",
        "12": "Kaynak kodunu bir ağaç gibi farzedersek, kökünden yaprağına kadar dallanıp budaklandırma işlemi gibi düşünülebilir.  Kodun yapsısını göstermek, derleyicinin analiz fazı ile alakalı işlemlerde, ve static kod analizinde kullanılıyor. Vikipediye göre program dönüşüm sistemlerinde de kullanılıyormuş fakat pek vakıf olamadım. Ama bir AST’nin nasıl çıkarıldığının örneklerini inceledim ve anladım.",
        "13": "Döngü kullanmadan döngünün getirilerini sağlayabilmek",
        "14": "Çok basit bir ‘do while’ döngüsünü, sadece recursive function ve if statement kullanarak PHP de oluşturdum. Açıkçası biraz google dan yardım aldım fakat mantığını anladım.",
        "15": "Son olarak SEO",
        "16": "Türk ve yabancı sitelerdeki bizim e-ticaret işimize muadil/benzer işler yapan e-ticaret sitelerini karşılaştırdım aslında. Açıkçası biraz daha araştırmak istiyorum ama yarına kaldı. SEO’ya da bir giriş yaptım diyebilirim Yarın ve sonrasında ufkumu/zu hep genişletecek bilgiler öğrenmek ve kullanmak dileğiyle.",
        "17": "2. Gün",
        "18": "Günün çoğunluğu Javascript ile temel programlama dersleri gibi geçti diyebilirim. Ama çok şey kattığını düşünüyorum. Hızlıca günün özetini yaparsam eğer:",
        "19": "Gün içinde baktığım konular: ‘Conditionals, Functions, Scope, Arrays, Loops, Iterators’ .Objects konusuna maalesef zaman yetmedi çünkü dediğim konu başlıklarında 50’den fazla örnek inceleyip hepsinin üstüne kendim tek tek benzer kodları yazdım. Zorlandığım kısımlarda çözümlere baktım fakat işin özündeki mantığı kavramak istediğim için biraz fazla zamanımı aldılar. Bugün öğrendiğim en güzel bilgiler aslında ‘Iterators’ konusundaydı. Bir fonksiyonun hem bir “data” olarak, hem de bir “parameter” olarak kullanıldığını görmek, ve bunun üstüne kodları inceleyip mantığını kavramak günün en olumlu sonucuydu benim için. Higher-order functions’larda fonksiyonu parametre gibi kabul edip işlemler yaparken, aslında callback kullanmadan da benzer işlemlerin yapıldığını, yapılabildiğini anladım. Call-back fonksiyonunun mantığını anladığımı düşünüyorum fakat işlem sırasını makine tam olarak nasıl izliyor onu çözemedim. Yarın acil bir şey olmazsa, ilk işim onu öğrenmek olacak.  Bir de event ve callback fonksiyonlarının başka bir programlama dilinde kullanıldığı bir kodu stackoverflow’ da inceledim. Kod yapısını çözümleyebilmek ve anlamak da çok sevindirdi açıkçası.",
        "20": "Diziler ve fonksiyonlar ile birçok örnek yaptım ki ve bu sırada kavramların isimlerini değil, nasıl kullanıldıklarını öğrendiğimi belirtmeliyim.",
        "21": "Değişken",
        "22": "Değişkenlerin yapısını düşününce, bir değişken, iki şeyden oluşur temelde: Tanımlama, değer atama. Bunlar ise bilgisayar belleğinin bir kısmına kaydedilerek yapılır. Burda kendi kendime şu örneği kurguladım bir an: Tanrının insanı yaratması, ve ona ilk ismin verilmesi. Ve o insanın dünyanın nerede konumlandığını Tanrı’nın belirleyebileceği veya belirtmese bile Dünya’da bir yerde doğmuş olduğunun kesin olması. Ve eğer tanrının isterse bu varlığın konumunu direkt değiştirebilmesi. Değişkenimiz insandı. Bellekte kapladığı veri Adem’di. Bellek dünyaydı. Kapladığı yer ise konumuydu. Sonra bu örneği çok genişletmek istedim fakat fırsat olmadı. Evet gereksiz bir (Stanley) Kubrickvari yaklaşım oldu fakat yazmak istedim yine de.",
        "23": "Google’ın tarayıcıda siteleri neye göre ilk sayfaya (hatta en üste) çıkardığının algoritması her sene Google tarafından güncellendiğini öğrendim. Biraz araştırma yaptıktan sonra bunun üstüne yayınlanan raporlar ve yazılar buldum. Bir tanesinde de sitenin hızının, ya da tarayıcıda gösterilme hızının öneminden bahsediyordu aslında. 0.61 saniye içinde ortalama 200-300 milyon sonuç arasından bir siteyi  ilk sayfada çıkarıyorsa, bu sayfaların da hızlı bir şekilde yüklenecek kapasitede olmaları gerektiğini düşündüm. Bu yüzden de sitenin performans analizini, yapısal analizini, sitenin yüklenme süresini (LCP,TBT,CLC gibi birçok kavram var) gözlemledim. “gtmetrix” ve “google page speed” den bu değerleri inceledim ve buna göre onların iyileştirme(optimizasyon) önerilerine baktım. Milisaniye cinsinden işlemler bile bu konularda çok önemli olduğu için aklıma bir an “block scope ta değişken tanımlamanın bellekte yer kaplamadaki geçiciliği konusundaki avantajı ve global variable olarak hep kalıp bellekte yer kaplamaması gibi konular” geldi. O kadar basit görünen ufak kodlama farklılıklarının, site içindeki resim büyüklüklerinin, CSS’i Bootstrap’le yaparken aslında fazla yüklenme sürelerine sebebiyet verdiğini öğrendim. Bunlar tabii ki SEO’daki asıl konular değil. Keywords gibi daha temel konularda var. Daha teknik konulara da geçeceğim.",
        "24": "Günün Özeti : 3’e kadar say denildiğinde “1,2,3” diye basitçe düşünüp sayan bir insanın; kendi mantığını, bir makineye anlatıp bunda da başarılı olduğunu görmekle hayretler içinde kalıyor,  öğrenmeye devam ediyorum.",
        "25": "3. Gün",
        "26": "Bugün Iterator  ve Object konusunu örnekleriyle beraber tamamladım. Dün biraz fazla çalıştığım için ve  uykusuz kaldığım için bugün biraz daha verimsiz geçtiğini hissettim. Ama iki gün içinde CodeAcademy’deki Beginner-Javascript kursunu tamamlamak da bir yandan güzel oldu. Sırada Intermediate kısmını tamamlamak var. Tabii burda biraz hızlı olmaya çalışıyorum çünkü çok fazla bilgi var ve olabildiğince şey öğrenip, nasıl kullanıldıklarıın görüp, unutsam bile karşıma bir proje çıktığında ya da bir soru geldiğinde, çözümünü yaparken ya da başka birisinin kodunu incelerken kurduğu algoritmaya, kod yapısına, kodda bulunan ifadelere ve kullanımlarını bilmek istiyorum.",
        "27": "‘Eloquent Javascript’ kitabındaki konular, projeler, örnekler ile alakalı bir Github kaynağı buldum. Javascript’in içine biraz daha girince-hatta her konu sonrası- onlara bakıp, daha da çok pekiştirmeyi düşünüyorum.",
        "28": "Bugün sizin ofisteki  toplantınızda konuştuğunuz konulardan “page speed” e dün bakmıştım ve Javascript  ile alakalı iyileştirmelerin gerektiğine kulak misafiri olunca aslında doğru bir yeri incelemişim  gibi hissettim. SEO konusuna bugün hiç bakamadım ama yarın bunu telafi etmek istiyorum.",
        "29": "Gün sonuna doğru toplantıda konuşulan konuları aslında gayet beyin jimnastiği gibi gördüm  ve çok severek dinledim. Yapay zeka, matematiğin üstüne kurulduğu temel varsayımlar gibi konuları sizden dinleyince,  “Gödel, Escher, Bach” ı okumayı daha da çok istedim fakat boş kalan vakitlerde önce MIT’deki bu kitap ile alakalı ders kayıtlarını izleyip, sonra kitabı okumayı düşünüyorum. ",
        "30": "İyi geceler, bugünkü bilgisayar/hayat/bilim/bilişim/felsefe konularındaki düşüncelerinizi de hiç zorunlu olmadığınız halde bizimle paylaştığınız  için de çok teşekkür ederim.",
        "31": "4. Gün",
        "32": "Bugünü yine çoğunlukla Javascript’e verdim. Hemen konuya girecek olursam eğer:",
        "33": "Nesne",
        "34": "Önce Object konusunda biraz daha detaylı kısımlara girdim. Factory Functions’I öğrendim mesela. Aslında biraz da Class a da benzetmedim değil fakat Class konusuna tam bakmadığım için büyük konuşmamalıyım. Ama Factory Functions’lar Object konusunda en sevdiğim yerlerden biriydi bugün için.",
        "35": "Web Compability and Transpilation",
        "36": "Object konusunu tamamen bitirdikten sonra Browser web Compatibility and Transpilation konusu vardı. Caniuse.com ve babel.io sitelerinden ES6 ve ES5 ile alakalı kodların ES6’dan ES5’e nasıl döndürüleceği ile alakalı dökümanlara baktım. 2021’ de artık ES6’dan ES5’ in formatına syntax aktarımı yoktur sanırım fakat ama birkaç sene önce web’in çoğunuluğu ES5 formatında Javascript I desteklediği için gerekli oluyormuş. Terminal’I kullanarak, Node paketleri indirip ve babel kütüphanesini indirdikten sonra bu işlem gerçekleştirliyormuş. Teminal kullanmayı biraz öğrenmek için işlemleri biraz takip ettim fakat 2021 sonrası (ki  web’in %97 (caniuse.com’a göre) sinden fazlası ES6 kullandığı için) sadece araştırmakla yetinmeyi tercih ettim bu konuyu.",
        "37": "Sınıf",
        "38": "Constructor, instance, method ve method call konularına baktım. Anladığımı düşünüyorum fakat üstünde örneklere bakmam gerekiyor tekrar. Sonrasında bugün Class konusunu tamamlamyı düşünüyordum fakat haftaya gireceğimizi öğrenince onu yarıda bıraktım ve ‘Eloquent Javascript’ isimli kitaptan şimdiye kadar öğrendiğimiz her şeyi tekrar etmek istedim örnekleriyle beraber. Bugün iki bölümünü bitirdim. Yarın da  başarabilirsem tüm örneklerine bakıp, kendim yazmaya çalışıp, yazıp, problem yaşayıp çözüme ulaşamazsam  da solution manul’ından bakarak günü tamamlamayı düşünüyorum. Kitapta her şey en öz ve anlaşılabilir haliyle anlatıldığı için ve ben de birkaç gündür kavramları okuyup, araştırıp, biraz da öğrendiğim için çok iyi bir tekrar olacağını düşünüyorum. Aynı zamanda gözden kaçan noktaları, ya da bilerek çok da bakmadığım fakat önemli olabilecek konu içeriklerini de tekrar edersem iyi olur diye düşünüyorum. ",
        "39": "İki gün önce SEO’ya baktığımda sitemizin internet hızını, ve diğer erişebildiğim paramerelerinin analizine bakmıştım. Aynı zamanda rakip firmaların (ya da benzer ürünler üstünden ticaret yapan firmaların) da aynı şekilde analizlerini yaptığımda sitemizin websitesi olarak (yazılım anlamında, mesela bağlanma hızı, sitenin yapısal analizi gibi) daha iyi olduğunu gördüm. Fakat yine SEO içinde ele alınabilecek fakat beni çok ilgilendirmediğini düşündüğüm sosyal medya, bilinirlik gibi konularda çok iyi olduğunu düşünmüyorum. Fakat site içi yorumları da koyarak güzel bir şey yapıldığını düşünüyorum müşteri ile iletişim için. Siz şeyi farkettiniz mi bilmiyorum ama (Google Analytics I kullanarak en azından marketing kısmı kesin farketmiştir bence) sitemiz ve benzer sitelerde google araması yapıldığında öneri aramalarda websitemizin güvenilirliği ile ilgili bir arama sonucu ile karşılaştım. Benzer sitelerin arama önerilerinde de aynısını çok kez gördüm. Hatta ekşisözlükte de websitemizin ve benzeri sitelerin yorumlarına da bakıldığında güvenlik konusuna değindiklerini gördüm. SEO dediğimiz şeyin bir tarafını site, diğer tarafını kullanıcı oluşturuyorsa ve ortada kalan Google ise, bizim kullanıcının istediklerini bir şekilde vermemiz gerekiyor ve güvenli-güvenilir olduğunu, bu kelimeleri ifade etmeden söylemenin bir yolunu düşündüm biraz ama cevap bulamadım. Açıkçası SEO hakkında fikirlerim oluşmaya başladı fakat tam istediğim seviyede olmadığı için sadece kendi kişisel görüşlerimi yazıyorum.",
        "40": "Günün Özeti :",
        "41": "Gerçekten severek bir şeyleri yapınca zamanın nasıl geçtiğini anlayamıyormuş insan. Bu demektir ki uzun süredir bir şeyleri severek yapmıyormuşum. Öyle düşünmüyordum ama mantığım bunu söyletti şimdi. Demek istediğim biraz alakasız olacak ama Morpheus’tan gelsin: ",
        "42": "Bu senin son şansın. Bundan sonra geri dönüş yok. Mavi hapı alırsın - hikaye biter, yatağında uyanırsın ve neye inanmak istiyorsan ona inanırsın. Kırmızı hapı alırsın - Harikalar Diyarı'nda kalırsın ve ben sana tavşan deliğinin ne kadar derine gittiğini gösteririm.",
        "43": "Wonderland’ de kalıp, tavşan deliğinin ne derinliklere gittiğini öğrenmek, “Ignorance is bliss”(aslında neden olmasın?) demeden devam edebilmek dileğiyle.",
        "44": "5. Gün",
        "45": "Bugünü kısaca anlatayım:",
        "46": "Sizin bugün yorumlamamızı istediğiniz kodu doğru yorumladığımı düşünüyorum fakat tabii ki eksik yanı fonskiyonların amacını belirtmemiş olmamdı. Aslında kodun sonucunu kağıda yazıp elle hesaplamaya çalışmıştım ve biraz zaman kaybettiğim için onunla, fonksiyonun amacını belirten yorumu yazmamıştım.",
        "47": "Günün çoğunluğu Eloquent Javasscript kitabından daha önceki konuları  tekrar yapmak, yazarın konularla alakalı ilginç düşünceleri ve üstüne çok düşündüren açıklamaları ve oradaki örnekleri yapmak/incelemekle geçti. Class konusuna dün biraz bakmıştım fakat bugün bakmadım doğruyu söylemek gerekirse. Yarın Class konusunu tamamen bitirmeyi düşünüyorum, bir beklenmedik şey olmazsa bitireceğim de. ",
        "48": "6. Gün",
        "49": "Bugün tamamen Javascript ile geçti.",
        "50": "Class konusunda ekskik kalan yerleri tamamladım. Inheritance yapısını ve static metodunu öğrendim.",
        "51": "Promise objesinin ne olduğunu ve niçin kullanıldığını, bir promise objesi oluşturmayı, catch(),promise.all(), gibi yapıların kullanımını öğrendim. Zincir halindeki birkaç tane promise yapısı oluşturan bir yapıyı inceleyip üstüne örnekler çözdüm.  Promise hakkında bugünkü çalışmalardan akılda kalanlar:",
        "52": "Asenkron programlarda kullanılırlar.",
        "53": "Üç durumda bulunurlar:”Pending, resolved, veya rejected” Bu konu hakkında bir ev temizliği örneği vardı. Diyordu ki, ev işlerini yaparken mesela sadece odaları süpürmezsin. Aynı zamanda çamaşırları da makineye atarsın, bulaşıkları da makineye atabilirsin. Süpürme işlemin bitince pencereleri temizleyebilirssin. Ama bunları tek tek yapmak yerine sen kendi işlerini hallederken bir yandan da makineler çalışabilir. İşte burda asenkron yapı ortaya çıkıyor. Javascript aslında tek thread’li, yani tek tek işi yapan bir programlama dili fakat event-loop olayı ile multi-thread gibi çalışma özelliği var. Event-loop ve call stack konusuna da bugün bolca baktım. Hangi işlemlere öncelik verildiğini, systemin nasıl çalıştığını öğrendim. Örneğe geri dönelim. Eğer çamaşır tozu makineye koyulmadıysa makine uyarı verir, bunun adı da rejected olarak geçer. Eğer makine işini tamamlarsa bu resolved anlamına gelir. Başlangıçta da adı üstünde pending durumundadır. ",
        "54": "setTimeout (Node API ile çalışır)  ile execution’ın zamanı ertelenebilir.Burda da event-loop un çalışma mantığını anlamakta fayda vardı. setTimeout’ta argument olarak bir callback function ve bir tane de delay süresi verilir.",
        "55": "Promise resolve edildiğinde, .then() kullanarak çağırabiliriz.",
        "56": ".then() : “I have a promise. When it settles, then here’s what I want to happen” diye özet geçilebilir.",
        "57": ".catch() ile de diğer handler ımız olan reject durumunda kullanırız.",
        "58": "Eşzamanlılığın avantaji ile de Promise.all() fonksiyonunu kullanabiliriz.",
        "59": "İç içe olanlar(nested) yerine zincir içindeki çoklu promise’ler daha işlevli olduğu için onları kullanmalıyız eğer kullanmamız gerekirse.",
        "60": "Bugün sizin verdiğiniz koddaki problemi anlamak da bugünün en güzel aydınlatıcı konularındna biriydi. Global değişekn kullanmanın zararlarının konu edildiği, iki kod arasındaki çok ufak bir farkla kodlarında işleyişinin farklı olduğu harika bir örnekti. Kodu okuyabildiğimi düşünüyorum, “büyük resmi” görmeye çok yaklaştığımı da hissediyorum fakat biraz daha kavramlar ve kodların arasında kayboluyorum sanırım. Öğrenme aşamasında olduğumuz için, zaten bir anda tüm kodları okuyuop anlayıp yorumlamamızı beklemekten çok, mantıklı yaklaşımlar sergileyebiliyor muyuz ya da çaba verip bir şeyleri anlayacak kadar analitik yaklaşabiliyor muyuz olaylara o önemli sanırım.",
        "61": "Async-await konusunda bugün en ilgimi çeken nokta, birkaç await yapısı kullanarak, kodun senkron bir kod gibi görünüp okunabileceğini öğrendim. ",
        "62": "Async-await yapısının kullanım amacı .then() zincirlerinden kurtulup, kısa kod yazmak değil, onun synchronous koda benzemesi ve bu sayede maintain ve debug işlemleri için yazılım geliştiriciye yardımcı olmasıdır. Ayrıca store etmesi daha kolaydır.",
        "63": "Singleton Pattern: Constructor’ı private olan bir sınıfn(class’ın) özelliklerine ulaşmak için bir getter yapısı ile kullanılabilen bir pattern’in genel adıdır. Bu işlemde sadece tek bir instance oluyor.",
        "64": "Günün Özeti : Hamdım, Pişiyorum..",
        "65": "7. Gün",
        "66": "Bugün ilk kez zorlandığımı hissettiğim gündü o yüzden birazcık stres yaptım. Çabuk bir şekilde bir kodu size göndermem gerektiğini düşünüp, çözümü direct stackoverflow da bulup copy-paste yapınca kendimi de kötü hissedip tekrar konuyu inceleyip kendim yazdım. Sonuçta amaç bir kod yazmaktan öte kendimin yazdığı, yanlışlarım da olsa bir şeyler üretmemdi. Sebebi de ilk kez karşılaştığım logic devrelerle alakalı şeyler olunca bir önyargıyla yaklaşıp çözümü aramak oldu. Ama işin içine girince yapılabildiğini anladım. Kendi yazdığım kodda ,Half Adder buldum. Full Adder’ın da yarısını bulup diğerlerini koda dökemedim ama biraz çabalasam olacaktı. Bugün şunları şunları bitirdim gibi bir cümle kullanamam zira bitirmedim. Bugün kod yazmak için bir şeyleri okumaktan çok yine Pratik yapmanın önemini kavradım. Son verdiğiniz kodu Javascript’e uygun hale getirdim ve sorunsuz bir çıktı aldım. Sonrasında da yorumlamaya ilk fonksiyondan başladım ama başlarda kaldı. Yarın devamını getirip hepsini yorumlamış hâle gelmek istiyorum. Son bir şey, siz gittikten sonra ofiste kalıp biraz daha çalıştım ama kötü bi niyetim yoktu yanlış anlamayın, ofiste çalışmak evde çalışmaya göre daha verimli oluyor diye durmuştum. Haber vermem gerekirdi bu konuda ama rahatsız etmemek istemiştim, kusura bakmayın.",
        "67": "8. Gün",
        "68": "Bugün öğle arasına kadar verilen php kodunun javascript’e dönüştürüldükten sonra yorumlanması ile geçti. Sonrasında design pattern nedir ve örnekleri nelerdir onlara baktım. Özellikle singleton pattern ile alakalı çok şey araştırdım. Aslında basit bir mantığı var ama anladım ki henüz konuya tam hakim değilim. Javascript’te constructor’I private yapmalıyım diye bir yargının içine girince, biraz afalladım. Ama constructor’ı private yapmadan da private gibi davranabileceği bir yapı öğrendim: Object.freeze () yapısı. Yarın güzel bir örnek üstünde çözmeyi düşünüyorum. Hatta yapabilirsem hem async yapısını, hem singleton’ı, hem module pattern ile privacy yapma konusunu, hem de factory pattern’ini bir kodda yapmaya çalışacağım. Yapamazsam eğer hepsini ayrı ayrı yazıp yorumlamayı düşünüyorum.",
        "69": "Bugün design pattern’lere bakarken öğrendim ki, aslında nesne yönelimli programlama ile gelişmişler. Sonrasında UML(Unified Modelling Language) diye bir şey buldum. UML ile soyut olarak tasarlanan nesne yönelimli modelleri görselleştirilebiliyor. Class’lar arasındaki inheritance ilşikisi gibi en basit konular dahi görselleştirilebiliyor. Yani design pattern’ler yazılım konusunda yıllardır biriken çok benzer sorunlara artık bir tepki olarak doğmuş ve bu kalıba göre bir çözüm üretin diye çıkmış gibi. Bu sayede kodun okunabilirliği, düzeltilebilirliği artıyor. Çünkü senden önce o kodu yazan kişinin tasarım kalıbınının ne olduğunu ve mantığını kavrayabiliyorsun.",
        "70": "9. Gün",
        "71": "Bugün öğle arasına kadar dün verilen görevi tamamlamaya çalıştım. Singleton ve diğer yapıları çok araştırdım ve artık anladığımı düşünüyorum. Bazı şeyleri sindire sindire öğrenmek istediğim için hıphızlı yapıp birçok şeyi kaçıracağıma, üstüne düşünerek her yapının varlığını ve kullanım sebebini anlayıp ilerlemek açıkçası hoşuma gidiyor. Bugün verdiğiniz ödevi yaparken farkettim ki, bazı şyapıları bol bol kullanmak gerekiyor ki hafızada yer etsin. Tıpkı yabancı dil öğrenmek gibi maruz kalmadan pek sonuç alınmıyor. O yüzden Singleton, Factory pattern’lerine, async...await yapısına, biraz da try catch yapısına baktım bugün. Daha önce de baktığım konulardı fakat tekrar etmek çok iyi oldu. Gün sonlarına doğru da ödevi yapmaya başladım. Onun da birçok kısmı bitti. Sadece yapmam gerekenler şunlar: Satılmamış ürünlerin bulunduğu diziden, alıcının istediği ürünü rastgele(ya da bulunduğu sıraya göre) seçmek ve sonrasındaki işlemleri yapmak. Gün sonunda o kısmın mantığını kafamda oluşturdum, yarın kaldığım yerden devam edeceğim. ",
        "72": "10. Gün",
        "73": "Bugün güzel geçti. Verilen ödevdeki bazı kısımları yaparken bazı yerleri yapamayacağımı düşündüm ama yeni bir solukla tekrar tekrar üstüne düşününce işin içinden çıkabildiğimi düşünüyorum. Çıkıtılar her ne kadar istenen formatta olmasa da, doğru şeyler çıktığı için mutluyum biraz. Özellikle kendi emeğinle bir kodu ‘okumak’, yorumlamak, istenenler doğrultusunda şekil vermek çok güzeldi. İster istemez mantığın devreye girdiği birçok yer oluyor ve bu da insane keyif veriyor çünkü zekanı kullanıp bir şeyler yaratıyorsun. Evet gelelim yazmam gereken şeylere:",
        "74": "Singleton kalıbı kullanılan bir kodun nasıl çalıştığını bugün daha iyi öğrendim. Class’lardan bir object çıkarmayı, o objeler üstünden başka işlemler yapmayı pekiştirdim. .foreach, .map, .push, if statement, for döngüsü gibi şimdiye kadar öğrendiğimiz her şeyi bu örneğin içinde bol bol kullandım. Diziye nesne eklemeyi, diziden nesne çıkarmayı (gizleme daha doğrusu, kullandığım metoddan dolayı), fonksiyon içine başka bir fonksiyonu argument olarak kullanmayı, kısaca object ve arrays konusu bugünün gündemiydi. Ve bu örneği yapmanın çok faydası olduğunu düşünüyorum. Günün çoğunluğu farklı yöntemlerle ödevin içerdiği mantığı anlamak, buna çözümler üretmekle geçti.",
        "75": "Module kavramını öğrendim bugün. Bazı kod parçalarını, aynı dosya içinde birkaç farklı dosyaya kaydedip ona göre işlemler yapmamız gerekebilir. Burada da, o dosyalar arasında köprü görevi görecek olan komutları öğrendim. ES6 ve Node Runtime environment’larında ufak farklı isimleri olsa da genel mantık aynı. Export ve import etmek için ‘module.exports’ ve ‘require()’ yapıları temel anlamda kullanılıyor Node için. Birkaç örnek inceleyip kendim de denedim.",
        "76": "Bu yaptıklarım aslında biraz ön araştırma ve önbilgi olması amacıyla yaptığım okuma gibi. HTTP Requests konusunu biraz araştırdım. Araştırırken karşıma tekrar ‘event loop,  heap, stack, event queue’,hatta ‘XML, AJAX’ gibi kavramlar çıktı. Bunlar hakkında biraz okumalar yapıp üstüne görselleştirmek için biraz video izledim. Daha detaylı şekilde:",
        "77": "Javascript’in en iyi özelliği, non-blocking özellikleri olması, ya da asenkron yapıda olması.",
        "78": "İçinde çok fotoğraf bulunan websiteleri örneğin, bu özellik sayesinde daha iyi kullanıcı deneyimine sahip olurlar. Mesela bir gazete websitesi büyük fotoğraf dosyalarına sahip olabilir. Onların yüklenmesi beklenirse kullanıcı durmak istemez ya da beklemek zorunda kalır. Ama o sırada yazıları okuması mümkündür. ",
        "79": "Asenkron foknsikyon çağrılarında event loop kullanılıyor javascript’te. Function calls’lar stack’e eklenir. Server’ın cevap vermesi için beklemesi gereken fonksiyon request’leri, mecburen sıraya girerler. Stack boşaldığı anda sıradakiler execute edilir. First in, first out kuralına göre execute sırası belirlenir.",
        "80": "Web geliştiriciler de daha iyi bir kullanıcı deneyimi için event loop’ları kullanır. ",
        "81": "Neleri öğrenmem gerektiğini öğrenmeye başladığımı düşünüyorum ama henüz en başındayım yolun. Yolun sonu güzel olacak diye umuyorum. Bugünlük bu kadardı."
    },
    "part2": {
        "1": "11. Gün",
        "2": "Bugünün de verimli geçtiğini düşünüyorum. Objeler ve diziler üstüne birçok örnek ile biraz daha pekiştiğini düşünüyorum konuların. 11 gün geçmiş ve birçok konuda fikirlerim oluşmaya başladı.",
        "3": "Bugün bir tane site buldum görevlerden arta kalan zamanda:",
        "4": "Bu sitede birkaç kendi yazdığım kodu ve bulduğum setTimeout içeren ve diğer benzeri kod yapılarını  içeren kodları, çalıştırıp çalışma şekillerine baktım. Call stack, callback queue, ve web api’ler üstüne Biraz daha fazla fikrim oluştu asenkron yapının çalışma şekli hakkında. Özellikle async…await ile alakalı örneklere baktım ve array-object konularından sonra onlar üstüne de çok çalışmak istedim fakat fırsat pek olmadı. Bugün verilen son odevi yarın tamamlamak için çalışacağım çünkü cumartesi akşamı kendime verdiğim tek boşluk. ",
        "5": "12. Gün",
        "6": "Bugün verilen görevi önce fonskiyonlar ile, sonra da class kullanarak yaptım. Static kullanımını ve constructor metodunu ayrı ayrı kullanıp, throw ile hata mesajı göndermeyi, “.find, .filter, .foreach, .map, .toString, .includes” gibi yapıları kullanıp object ve array’lerde işlemler yaptım. Daha da pekiştirdim konu üstüne bilgileri. ",
        "7": "Sonrasında Ajax, Xml , Json gibi kavramları biraz araşıtırırken Ajax ın ne olduğu üstüne gittim. Ajax ile web sayfasını yenilemeden sunucuya request gönderme işlemi yapılabiliyor. Sunucudan veri alınıp üstüne işlemler yapılabiliyor. Bu da daha ‘responsive’ ve hızlı bir kullanıcı deneyimine izin veriyor. Günümüzde genelde XML yerine JSON daha çok tercih ediliyor çünkü JSON javascript’in bir parçası durumunda ve bu da daha ‘lighter size’ sağlıyor (Bazı kelimeleri türkçe’ye çevirmek ile uğraşınca çok vakit kayboluyor  o yüzden böyle yazıyorum yoksa Tükçe’yi katletmek gibi bir amacım yok :)). Hem JSON hem de XML bilgi paketleme (packaging information) için kullanılıyor. XMLHttpRequest objesi, serverlarla iletişim için kullanılıyor.",
        "8": "HTTP request nasıl yapılır bakmadan önce HTTP  nedire bakmak gerekli gibi. Hyper text => linklenmiş kelime. HTTP web tarayıcı ve web sunucusu arasında iletişim için dizayn edilmiştir. Stateless protokoldür. Yani aynı bağlantıda(connection), server iki istek(request) arasında hiçbir bağlantı-köprü(link) tutmaz. HTTP çerezleri ile stateful oturumların kullanımına izin verilir. Client-server protokoldür. Bu şu anlama geliyor: request client tarafından başlatırılır (web browser yani). Client ve server arasındaki mesajların exchange’I sırasında proxy ler bulunur. Bunlar HTTP response’larını geçici olarak tutabilir (caches) ve sonraki HTTP request’ler için kullanılabilir. Proxy’ler birkaç şey için daha kullanılıyor ama bunu bilmem şu an için yeterli gibi görünüyor.  HTTP akış şeması şu şekilde: 1. TCP bağlantısı oluşturulur. 2.HTTP mesajı gönderilir. 3.Sunucu tarafından gönderilen response(cevap) okunur. HTTP request’I oluştumak, sunucu cevabını işlemek ile alakalı işlemler biraz fazla detaylı olduğu için atlıyorum şimdilik. İleride tekrar karşıma çıkacağını düşünüp, şimdilik bu kadar araştırma yeterli diye düşünüyorum.",
        "9": "SEO hakkında çok güzel açıklamaları ile yol haritaları çizen iki tane site buldum. İkisinin de anlattıklarını referans olarak kabul edip bu süreçte bitirmek istiyorum. Günün SEO konusu: Core Web Vitals.",
        "10": "Üç tane önemli konu var, onları da diğer konular takip ediyor: Largest contentful paint (LCP)-Loading-, First Input Delay (FID)-Interactivity-, Cumulative Layout Shift (CLS)-Visual Stability-. Mobil uyumluluk, safe browsing, HTTPs, bir de Intrusive Interstitials( beklenmedik çatlak gibi bir anlamı var Türkçe de, anlamlandırabiliyorum ama tercüme edemiyorum) gibi konular da var. Google’a göre özellikle ilk üçlü sıralamayı direct olarak etkiliyor. Ve google iyi URL’leri ödüllendirmekten daha çok cezalandırıyor kötü,bozuk(poor) URL’leri (CLS skoru düşük olan URL’ler gibi). Şöyle de bir şey var: sayfa hızı ve sıralama arasında her zaman korelasyon bulunmayabiliyor. Yani google sadece sayfa yüklenme hızına bakmıyor. Google asıl kullnıcı deneyimini ölçmeye çalışıyor (user experience). İyi bir kullanıcı deneyimi için de LCP’nin 2.5 saniye veya altında olması gerekiyor. LCP’deki element tipleri: <img>, <video> block-level elementler, arkaplandaki yüklenen resmin bulunduğu element (URL ile). Sitemizi tekrar webpage test’lerinden birine soktum ve yine verdiği optimizasyon önerilerine baktım ve canlı destek kısmı ile alakalı önerilere rastladım ama çok bir fikir yürütemedim. Başlarda olduğumu biliyorum ama gelimden yapmaya çalışıyorum diye düşünüyorum. Yine tararken site ile ilgili şeyleri, alexa kullanımı ile alakalı şeylere de rastladım ama henüz pek anlam veremedim. Daha çok çok araştırma yapmam, öğrenmem, pratik yapmam gerekiyor. Bilgiye aç olduğumu çok hissediyorum ve bu açlığın çok uzun süre devam etmesini diliyorum.",
        "11": "Bugünlük bu kadardı.",
        "12": "13. Gün",
        "13": "Bu sabah  web’in nasıl işlediğine biraz baktım. Sonrasında görev verilince ona yoğunlaştım. Soru bence çok güzeldi ve üstüne düşünülmesi gereken yerleri vardı. Ben biraz fazla düşünüp birkaç gündür kullanmadığım yapıları kullanmak istedim. Biraz deneme yanılma metodlarını da çok kullandım galiba. Mesela switch case yapısını uzun zamandır kullanmamıştım. Açıkçası zor değildi fakat algoritmasını iyi kurmak gerekiyordu. Elbette eksikleri vardı kodumun fakat genel olarak yaptığım şeyden zevk aldım evet.",
        "14": "XML, JSON konularına bakmaya başladım sonrasında. Dün zaten AJAX’I araştırırken iyice aşina olmuştum bu konulara açıkçası. Ama bugün JSON’ ın kullanım şeklini öğrendim. JSON web sunucusu ile client arasında iletişimin sağlanmasında işimize yarıyor. Ve tamamen string yapıda, yani text tabanlı bir formattır. Bugün JSON hakkında asıl öğrendiğim şey “.parse()” ve .stringtify()” metodlarıydı.  Örneğin JSON objesi, javascript’teki obşeye yapı yönünden aşırı benzemsine ragmen arada çok büyük bir fark vardır. Birisi object’tir, diğer ise sadece bir text(string)tir. Yani bir javascript objesi olarak JSON objesini görmemiz mümkün değildir.  Onu bir objeye döndürmek için “.parse()” metodu kullanılır. Tam tersinin istenmesi halinde ise, yani objeyi bir string hale getirmek istiyorsak da stringify metodu kullanılır. Peki neden JSON’a ya da XML’e ihtiyacımız vaR? Çünkü client ve web server arasındaki veri alışverişinde direct bir javascript objesi kullanılmaz; JSON, yani bir text dosyası kullanılır. Parse ve stringify metodlarının örneklerini inceleyip kendim de console’a yazdırıp arsdaki farklarını inceledim.",
        "15": "JSON’I elde etmek : Bunun için bizim bir API kullanmamız gerekiyor: “XMLHttpRequest” ya da kısa adıyla XHR. Javascript aracılığyla server’dan kaynakları almak için network request’I yapmamızı sağlayan bir Javascript objesidir. Yani bu sayede sayfayı yenilemeden sayfada güncelleme yapılabiliyor. Detaylı ve aynı zamanda basit bir kod yapısını gördüm JSON’ı elde etmek ve request response çağırmak ile alakalı. Okudum, anladığımı düşünüyorum.",
        "16": "SEO’ya da biraz baktım ama buraya ekleyecek kadar çok detaylı değil maalesef. Yarın bunu telafi etmeye çalışacağım.",
        "17": "14. Gün",
        "18": "Bugün de genel olarak JSON, XML, API, DOM kavramlarına baktım.",
        "19": "Application Programming Interface. User Interface’ten farklı olarak bir API, yazılımlar arasında etkileşime izin veren bir yazılımın içinde bulunan kurallar ve özellikler bütünür. Web geliştiricisi (ya da diğer geliştiriciler, sadece web’te kullanılan bir teknoloji değil çünkü), kullanıcının web browser ile etkileşime geçmek için kendi ugulamasında kullanabilir. Mesela getUserMedia API ile ses ve görüntü kaudı alınabiliyor. Geolocation APı ile de konum bilgisi alınabiliyor. Çoğu API sadece secure context’te (HTTPs’de) geçerlidir. Sebebi ise API’ler kullanılarak büyük saldırılara sebebiyet verilebilir. HTTPs’nin temel amacı güçlü API’lerden ulaşan MITM (man in the middle attack) saldırılarını önlemektir. Bazı API’ler güçlü olduğu için sisteme saldırı yapanlar için büyük avantaj sağlıyor. Bu saldırılar ile kullanıcı bilgisayarına düşük seviye erişim sağlayabiliyor saldırıyı gerçekleştirenler. Ya da kullanıcı verilerine erişebiliyor. Ve kullanıcı gizliliği geçersiz kalıyor. Local olmayan kaynakların secure olması için “https:// veya wss://URLs” şeklinde olması gerekiyor.",
        "20": "Document Object Model. XML ve HTML dokümanları ile etkileşime geçmek için kullanılan bir API’dir. Dom tarayıcıda yüklenen bir doküman modelidir ve dokümanı bir node ağacı olarak sunar (node tree, data structures çalışırken de görmüştüm buna benzer bir ağaç yapısını). DOM web’te en çok kullanılan API’lerden biridir. Dokümanda, kodun her node ile etkileşime girmesine ve ulaşmasına izin verir ve browser’da kodun çalışmasına izin verir. Yani DOM, dokümanın yapısını sunarak web sayfasını script’e veya programlama diline bağlar. DOM ile bi mantıksal ağaca sahibiz. Ağacın her dalı bir node ise bitiyor ve her node da bir object bulunmakta. DOM meodu bizim bu ağaca erişimimizi sağlıyor ve dokümanın yapısnı, stilini, ve içeriğini değiştirmemize izin veriyor. Özet tanım: DOM web üstündeki dokümanın içeriğini ve yapısını içeren objenin veri olarak göstermidir. Dokümanı nodes ve objects olarak gösterir ki, bu da programlama dilinin web sayfaı ile etkileşime geçmesine izin verir. DOM JS’in bir parçası değil ve website oluştumrka için kullanılan bir web API’dir. Node.js, bilgisayar üstünde çalışır ama API’leri sağlar ve DOM API Node.js’in core parçası değildir. Yani DOM hiçbir programlama diline bağlı değil ve dokümanın yapısal gösterimini tek bir API ile sağlar.",
        "21": "Asenkron ya da senkron olarak değişir.Web workers dışında senkron kullanmamız gerektiğini öğrendim fakat tam detaylı araştırmadım o kısmı. Ama öğrendiğim bir şey var: Performans için kesinlikle asenkronu seçmeliyiz. Senkron execution’I bloklayıp ‘freezing’e sebep olur. Yani unresponsive user experience demek.",
        "22": "Bugün XMLHttpRequest ile işlemler nasıl yapılıyor onları öğrenmeye çalıştım. Baktığım yerlerdi de anladığımı düşünüyorum.Bir örnekte request oluşturmak için bazı adımlar takip edip işlemi gerçekleştirmişti: API’den bilgilere URL ile ulaşılmıştı. AJAX kısmında, response tipi (JSON), event handler kısmı (mesela XHR tamam olunca, server 200 OK! Deyince ne yapılması gerektiği burada belirtildi. İki parametre kullanıp (GET, ‘destination) kullanıp request açılıp gönderildi. Örnek şuydu: Bir web sayfasında bir API vardı ve kullanıcı tarafından girilen bir kelimenin kafiyeli olduğu benzer kelimeleri sonuç kısmında yazdırıyordu. Örneğin amacı neydi? Oluşturulan sitede ne kadar çok kelime araması yapsam da, sonuçlar yazdırılırken asla sayfa yenilemesi olmadı. Yani Ajax bu işe yaradı diye düşünüyorum.",
        "23": "Gün sonuna doğru HTML,CSS konularına girdim. Açıkcası ço kdaha basit yapıları var fakat Pratik yapmadan öğrenmek biraz zaman alacak gibi. Bugün öğrendiğim en güzel şey konu hakkındaki sizin söylediğiniz bir şeydi: CSS oluşturulurken 3 şekli var. HTML içindeyse CSS dosyamız, inline ve internal olarak kullanım yerine göre değişiyor. Eğer HTML ile aynı klasörde başka bir CSS doyası oluşturuyorsak da o zaman external CSS olarak adlandırıyoruz.",
        "24": "Yarın kaldığım yerden devam edeceğim.",
        "25": "15. Gün",
        "26": "Bugün tamamen CSS ve HTML üstüne çalışmakla, pratik yapmakla, araştırmakla geçti. Javascript’ten bir anda bu konulara girince zorluk yaşadığımı söylemeliyim. HTML’e ne kadar aşina olsam da CSS’le beraber tasarım konularına girmek yabancı olduğum bir şeydi ve bu yüzden en temelinden başlayıp hızlıca birçok şeyi öğrenmek istedim. ",
        "27": "HTML ile alakalı konuların çoğunluğunu bitirdim, HTML Forms kalmıştı bir tek ama ona 1 ay önce çalıştığım için ve asıl çalışmam gereken CSS olduğu için biraz da girmedim. Diğerlerini tamamladım.",
        "28": "CSS’te en temel kavramlardan başlayıp Fletbox’a kadar gelebildim. Birçok örnek inceleyip, üstünde oynamalar yapıp birkaç site tasarımı yaptım fakat ne kadar öğrendin derseniz eğer; 3 ve 2 yi topla derseniz konu hakkında yaparım. Çünkü 3 ve 2 nin tanımını, nasıl kullanıldığını bugün öğrendim. Fakat sin3°+sin2°=? derseniz sinüs ve derecenin anlamını bilmediğim için bunların ne olduğunu araştırmam, örneklerine bakmam, onlara bakıp problem üstünde kendim çözüm üretmem gerekir. Yani yap deyince yapamayabilirim ama nasıl çözüldüğünü araştırıp öğrenip yapabilirim. Bugün kısaca bu şekildeydi.",
        "29": "Flex, inline-flex, flex-wrap, relative position, justify content, block-inline arasındaki fark, # işaretinin href içinde URL için placeholder özelliği, hover, align-items gibi çok farklı terimler gördüm. Bu terimlerle alıştırmalar yaptım. Ama tek bir görev verilip bunun üstüne aratırma yaparak tek tek kendim HTML ve CSS’I yazarsam daha akılda kalacak bunu biliyorum. O yüzden bugün biraz temel oturtmaya çalıştım yarın da daha çok pratik yapacağım, eğer bu konu üstüne çalışmaya devam edeceksek.",
        "30": "16. Gün",
        "31": "Bugün birbirinden farklı konulara baktım. CSS, HTML, XML ve DOM, ve regex.",
        "32": "CSS ve HTML de bugün tamamen websitemizin tasarımına, site içindeki kodlara baktım ve inceledim. Her kodun neden yazıldığını, her birinin ne işlevi olduğunu anlamaya çalıştım. Elbette çok karışık geldi çünkü baktığım şey  büyük bir çalışmanın sonucuydu. O yüzden adım adım her bir elementi incelemeye çalıştım. Bazı yerler başta gereksiz gibi gözükmüştü mesela navigation bar kısmındaki bir kod bir işe yaramıyor sanmıştım başta. Ama sonra tarayıcının boyutunu küçlütünce o kodun da  bir işlevi olduğunu gördüm. Responsive web tasarımının kolay olmadığını gördüm. Bazı yerlerde Bootstrap’ten izler vardı, mesela footer kısmındaki 6 tane div elementinde dikkatimi çekti. Öğlene kadar header kısmının bazı yerlerini benzeterek kendim yapmaya çalıştım. Oldu mu? Olmadı ama olacağını düşünüyorum. Çünkü çok zor değil fakat çok uğraştırıcı. Anladım ki algoritma ile alakalı konuları daha çok sevmişim.",
        "33": "XML ve DOM konusuna gelmeliyim. Başta soruyu anlamaya çalıştım. Sonra bunun için zaten DOM Parser gibi özellikler zaten var neden uğraşmalıyım diye düşündüm. Önce kolay yolu aradım. İnternette bunun için zaten bir fonksiyon olduğunu öğrendim fakat soruda benden istenilen, string bir metinden anlamlı objeler çıkarmanın lagoritması istendiği için Google’dan kopup, algoritması üstüne düşündüm. Gayet mantıklı olduğunu düşündüğüm bir algoritmayı kurmuştum ve üstüne çalışma başlamıştım. Sonra sizin yaklaşım biçimlerinizle  farklı bi çözüm yolu görünce kendiminkini bir kenara bıraktım ama yarın sizin çözümünüzü yorumlarken kendi düşündüğümü de nasıl uygulayabilirim onun üstüne çalışacağım.",
        "34": "Regex’le yapmanızı beklersem, füze atmanızı isterim dediğiniz için regex daha da ilgimi çekti ve sonrasında hep regex nedir, ne için kullanılır, ve örneklerine, kullanımlarına baktım. xmlStirng text’indeki bazı istenenleri regex’le buldum. Birkaç yer I bulamadım ama dediğiniz gibi her şeyi de regex’le bulmak gerekmiyor ya da bulunmuyor sanırım. Yine de üstüne çalışmak ve birkaç şey yazmak güzel oldu diye düşünüyorum.",
        "35": "Bugünden aktarabileceklerim bu kadardı.",
        "36": "17. Gün",
        "37": "Bugün iki şey vardı yaptığım: XML’den anlamlı bir DOM objesi çıkarmanın algoritmasını anlayıp eski işlediğimiz javascript konularını, yazdığınız kodu okurken bilgi olarak tazelemek ve CSS çalışmak. HTML kısmında hiçbir problem olduğunu sanmıyorum ama CSS te kavramları birbirine çok karıştırıyorum. O yüzden web sitesi dizaynı konusunda bugün zorlandım. Gün sonunda en azından responsive olan bir header yapabildim.  Konu çok fazla görsellikle alakalı olduğu için gün sonunda ve yarın üstüne videolar izleyip üstüne kendim bir şeyler yapmaya çalışacağım. Bugünü bu kadar özetleyebilirim. Eksik kaldığım konuları telafi etmek için elimden geleni yapacağım.",
        "38": "18. Gün",
        "39": "Bugün de CSS ve HTML ile geçti. Inspect element dedikten sonra bol bol div’lere dalsam da, azıcık da olsa Sources kısmına girip javascript kodlarına bakınca, anlamamış olsam dahi çok hoşuma gitti. Nedense o konular çok daha cezbedici görünüyor. Evet, bugüne gelelim:",
        "40": "Carousel için internette araştırma yaptım. Javascript ile çalışan bir kod buldum fakat çok karıştırmak istemedim için sadece CSS ve HTML ile yaptım o kısmı. Günün çoğunluğunda websitemizin sadece dizaynına ve nasıl bi yapı oluşturulduğuna bakıp, kendim zaman harcayıp farklı şekilde yapmak istedim. Farklı da oldu, yine benden parçalar vardı. Ama en basitinden body kısmındaki genişliğin sayfa genişliği kadar olmaması bana problem yarattı biraz. O yüzden eski haliyle çalışmaya devam ettim. Sonra doğru işler komple copy-paste e kayıyor ya da kayacak gibi geldi bana ama zaman varsa yine kendim yapmaya çalışacağım.",
        "41": "Bugün en önemli öğrenilen şey: pratik yapmak gerekiyormuş. Ve bufün çokça yaptım. İki gün önce hiç sevmediğim tasarım işleri bugün biraz yapabilince daha da hoşuma gitti ve daha çok bir şeyler yapmak istedim.",
        "42": "Çok alakasız olacak ama, internette flexbox ile ilgili ",
        "43": "çokça kişi tarafından, konuyu anlamak için. Yarın sabah erken kalkıp, onu bitimek istiyorum. Bugünde erken uyanıp biraz konu hakkında videolar izledim. Onlar da çok yardımcı oldu. ",
        "44": "Bugün aktarabileceklerim aslında bu kadar değildi. Ama yarına daha dolu şekilde yazmak istiyorum yine büyük ihtimalle CSS ile geçeceği için.",
        "45": "19. Gün",
        "46": "Bugün sitenin birçok ksımının HTML ve CSS kısmını tamamladım. Birebir aynısı olamdı. Hatta çok fazla farklılık var ama bir web sitesinin tasarımını, sitenin yapısının nasıl olduğunu özellikle websitemiz üstünden incelemek ve tekrar üretmek için bir fırsat oldu.  Bol bol flexbox örneği yaptığımı düşünüyorum. Hala daha biraz karşıtırsam da kavramların ne için kullanıldığını, ve kullanım şeklini bol pratik yaparak biraz öğrendim. Ayrıca dün linkini verdiğim siteden de alıştırmalar yaptım.",
        "47": "Otomatik olarak içindeki elemanları kayan carousel, zaman sayacı gibi kendim bir şeyler ekledim ya da farklı şeyler oluşturmaya calıştım. Örneğin pop-up olarak büyüyen chatbox’ımızın bir benzerini oluşturdum.",
        "48": "Bugünüm çok fazla pratik yapmakla geçti ve çok da iyi geldi açıkçası bunları yapmak. Amacımız site yapsını, kullanılan elemnetleri anlamak olduğu için oldukça verimliydi.",
        "49": "20. Gün",
        "50": "Bugün öncelikle belirtmeliyim ki, eğer o algoritma yapısını vermeseydiniz işler biraz daha zorlaşırdı. Aslında soruyu sordunuz ve cevabı da siz verdiniz o konuda üzüldüm. Biraz üstüne zaman harcayıp öğrenmeyi yeğlerdim. Ama bu şekilde de hızlı oldu çözüme ulaşmak o ayrı tabii ki. Öncelikle bir JSON String’imiz vardı. Bunu “parser” ile okunabilir bir objeye çevirdikten sonra onu ve yazacağımız javascript kodu ile websitesi üstünde değişiklikler yapabilirdik. Ki ödevin konusu da buydu. Yani amacımız, JSON objesindeki verileri tarayıp, websitemizdeki uygun ve eşleştirmek istediğimiz kısımlarla eşleştirip istediğimz değişiklikleri yapmaktı. Kurmamız gereken algoritma: JSON objesindeki özellikle istenilen property’yi her elementi için tara. Bunu da bir döngü oluşturarak yap. Sonra istenilen HTML dokümanındaki kısmı da döngü içine dahil edip, her element için değerleri güncelle. Burda zorlandığım kısım json objesi,obje,array, ya da html gibi bir konu değildi. Yaşadığım sorun HTML elementlerini javascript aracılığıyla bulmaktı. Bugün öğrendiğim en  büyük şey de bu oldu: HTML elementlerini; id,class,tag gibi onları tanımlayan özellikleri ile bulabilmek ve onlar üstünde güncelleme yapabilmek.",
        "51": "Günün ilk yarısında ise websitemizin benzeri oluşturmaya çalıştığım site üstünde güncellemeler yapmakla zaman geçti. Header kısmında eksik kalan yerleri tamamladım. Eksiklerimin de ne olduğunu sıralayabilirim aslında ama onları tamamlamak için çok zaman olmadı: body genişliği, karoselin sağ taradındaki elementlerin doğru ayarlanması, yine birkaç düzenleme yapmam gereken yerler(popular kategoriler kısmı gibi), hızlı arama kısmında çıkan seçenekler, sayfa aşağı kaydırılınce yukarı sabitlenen menu çubuğu, ve en önemli eksik de responsive tasarıma uygunluk. Mesela sayfa boyutu küçültülünce orjinal sayfada olan tasarım oluşmuyor. Bazı yerler oldu fakat çoğunluk biraz sorunlu. Bu kadar eksikten bahsedip iç karartmışken artılara gelelim. Sonuçta prons&cons yapmak lazım gerçekçi olmak için. Artılardan biri şuydu: sayfa yapısının nasıl olduğunu temel manada gerçekten öğrendim. HTML elementlerinin, CSS te kullanılan özelliklerden birçoğu ile karşılaşıp taker taker birçok yerde kullandım. Hala daha flexbox ile alakalı terimleri kullanırken karıştırsam da hemen çözümü bulabiliyorum. Pratikle daha da gelişir diye düşünüyorum. Canlı destek pop-up kutusuna site içinde link verip ulaşmayı sağladım bugün mesela. Evet kolay ama yapmak güzel ve basitti. Genel olarak basit şeyler bence bu konular ama zaman alıyor ve uğraştırıyor. Bu da çok normal bizim seviyemiz için diye düşünüyorum.",
        "52": "Günün sözü:",
        "53": "“ Limandaki gemiler güven içindedir; fakat gemiler limanlar için yapılmamıştır.  ”- J.A Shedd",
        "54": "çok güzel bi oyun sitesi önerilmiş"
    },
    "part3": {
        "1": "21. Gün",
        "2": "21 gün nasıl da geçmiş gerçekten anlamadım. Çok çalışmak istiyorum, çok öğrenmek istiyorum çünkü işimi çok iyi yapmak istiyorum. 21 gün bu kadar hızlı geçtiyse, her güne daha çok şey sığdırmalıyım diye düşünüyorum. Hayat kısa, göreceli de olsa. Evet bu girizgâhtan sonra bugüne dönebiliriz.",
        "3": "//Sonraki paragraf işle alakası olmamasına ragmen yine de yazdım. Direkt geçebilirsiniz.",
        "4": "/* Bugün event, event listener gibi konuların ne olduğuna, bir websitesi için ne anlam ifade ettiğine ve nerde kullanıldığına bol bol baktım. Kâh dökümanlar içinde, kâh problemler ve çözümleri içinde kayboldum. Gün sonundaki sizin anlattıklarınız da yararlı oldu. Ama bugün şunu düşündüm: Mühendis nedir? Ot’un, çiçeğin,elektriğin, binaların, köprülerin, uçağın, arabanın, işletmenin, fiziğin, matematiğin, uzayın, meteorolojinin, metalurjinin, bilgisayarın, yazılımın mühendisliği varsa eğer; bu çok büyük tabiri nasıl ifade edebilirdik. Çözüm bulma yetisiydi sanırım spesifik bir konu ile alakalı. Mühendisliğin sanata olan benzerliği ne olabilirdi peki? Yaratıcılık olabilir dedim kendime (typeof ‘da-vinci’ === ‘mühendis-sanatçı’ idi). Aradaki fark, birinde estetik ön plandayken diğerinde işe yararlılık, sağladığı kolaylık ve diğer insan faktörleri önemliydi. Bu yaptığımız işte, sanatla bağlantılı olan nokta da yaratıcılık konusu. Sanat eseri günlük hayatta bir işimize yaramayabilir, ama bizim yaptığımız şeyler bir işe yaramalı. Sanat eseri mükemmelliyet tutkusu ile yapılabilir, ama biz mükemmeli yakalamak isterken istediğimiz sonucu hiç elde edemeyebilir ve obsesif ruh haline bürünebiliriz. Dünyanın en hızlı arabasını yapmak eğer bizim mükemmel tanımımıza giriyorsa şöyle düşünebiliriz: Düyanın en hızlı arabasının fotoğrafını çekebilirsin, resmini de çizebilirsin. Hayal de edebilirsin. Ama onu yapman için çok çalışman gerekir. Ekip olarak çalışman gerekir. İnsanlarla uyumluluk gerektirir. Çok para gerekir. Zaman kısıtlaması olabilir. Kısaca mükemmele ulaşmak için çok faktör vardır ve ulaşamasak bile yolunda uygun adımlar atmak yeterlidir diye düşünüyorum. Yaratıcılık mı? Her bir probleme uygun bir algoritma geliştirip çözüme ulaşmak bu işin sanatsal kısmı diye düşünüyorum. Ve bence en çok haz veren kısmı da bu olmalı. Yani CSS’te renk değiştirmekten daha zevklidir diye tahmin ediyorum. Bu da bireylerin bakış açısına göre değişiyor tabii ki de, çoğu şeyin göreceli olması gibi. Lafı çok uzattım kusura bakmayın, sanırım asıl konuya girmeliyim. ",
        "5": "*/",
        "6": "Bugün öncelikle beni en çok etkileyen şey bir problem ve ona getirilen bir çözümdü. Basitti ama güzel bir örnekti: Problemimiz web saysası üzerinde oluşturulan 16 ayrı parçaya farklı farklı rastgele renkler verebilmenin algoritmasıydı. Çözüm olarak üretileni çok sevdim: Bir döngü açılıp, 16 kez tekrar etmesi sağlanıp, döngü içine de “.createElement” ve “.appendChild” kullanarak body’ye 16 tane ayrı div ekleniyor (body’nin child’I olarak). Sonrasında “rgb(-,-,-)” içine yazılabilecek en büyük sayı ile en küçük sayı arasında rastgele bir sayı seçen bir fonksiyon yazılıyor. Sonrasında ise birkaç farklı yapı kullanılarak bu divlerin backgroundcolor’ları her mouse’a tıklamada değiştirilebiliyor. Bu yapılar şunlardı: “.addEventListener, .eventobject, event handle property, event handle attribute”.Hepsi de aynı sonucu veren bu farklı yapılardan bugün en çok “.addEventListener”a baktım. ",
        "7": "Bu örnekten farklı olarak birkaç örneğe bakmış olsam da bir diğeri de şuydu: site içindeki bir düğmeye tıklayınca açılan bir videoydu. Butona basmadan görünmezken basınca görüntüleyip, sonra da videoya tıklayınca yok olması çok güzeldi. Bunun bir benzeri olarak bizim sitemizdeki bir fotoğrafın tıklanınca gelmesi konusu da bizim için iyi bir örnek oldu diye düşünüyorum hem javascript hem de biraz seo konusunda.",
        "8": "Kısaca nelere bugün baktığımı ve onların ne olduğunu yazmak istiyorum. Bu yazdıklarımı aslında günlük olarak bilgisayarıma kaydettiğim için, ileride tekrar bakıp feyz almak da güzel olur:",
        "9": "Scripting dili ve web sayfası yapısı arasındaki bir arayüz. Tarayıcı her web sayfası için bir DOM oluşturur. Scripting dillerinin web sayfasına ulşamasına ve değiliklik yapmasına DOM izin verir. DOM sayesinde javascript dinamik HTML sayfaları yapabilir.",
        "10": "Bir tag ile yeni bir element düğümüne referans yaratır ve return eder. DOM içine yeni bir element yaratmaz, bunu yapılabilmesi çin “.appenChild()”  gibi bir method ile kullanılması gerekir.",
        "11": "Bir elementin şimdiki içeriğinin değerine ulaşmak için ve üstünde değişiklik yapabilmek için kullanılır. Benzer şekilde “.innerText” ve başka yapılar da mevcut olup aralarında bazı farklar bulunmaktadır.",
        "12": "id attribute üne sahip bir elementi specific değeri ile döndürür. “id” eşsiz olamlı ve ve birkaç elemanda kullanılmamalıdır. Eğer kullanılırsa sadece ilk uyuşan id’li elementi alacaktır.",
        "13": "Id,class gibi attribute lerle elementleri sorgulamaktır. Uygulamasını yaptığımız için atlıyorum.",
        "14": "Bir web sayfası üstünde kuulanıcı interaction’I ya da tarayıcı manipülasyonu, client-side(browser üstünde) javascript event’inin yaratılmasına neden olur. Event’ler javascript fonksiyonu kullanarak DOM’u manipüle etmek(üstünde değişiklik yapmak gibi) için kullanılabilir. Event’ler tıklamadan mouse’u bir elemnt üstünde gezdirmye kadar her şey olabilir. Event’ler web tarayıcı üstündeki javascript API’nin bir parçası olarak tanımlanır.",
        "15": "Javascript’te bir event meydana gelince, event handler yani event listener çalışır.",
        "16": "Javascript’in amacı dinamik bir web sayfası yapmaktır, yani eventlere cevap verebilen bir yapı(butona tıklama, sayfayı kaydırma gibi). DOM elementleri eventler ile alakalı bir fonskiyona sahip olabilir. Bu fonksiyonlar event handler olarak adlandırılır ve DOM element bir event target olarak bilinir. ",
        "17": "Event handler fonksiyonunda parametre olarak geçerler. Event hakkında bilgi tutarlar. Event objeleri event target,event type, ve bağlantılı listener lar hakkında bilgi tutarlar.",
        "18": "Event handler ı event target üstündeki spesifik bir event’e eklemeyi sağlayan metoddur. Avantajı ise event target üstüne overwrite yapmadan farklı event’ler ekleyebilmektir. İçinde iki argüman bulunur: Event ismini içeren string ve event handler function. ",
        "19": "Çok daha fazla ayrıntı da var fakat uygulama ve görevlerle daha da pekişeceğini düşünürek bu kadar yeter diye düşünüyorum. Bubbling ve capturing gibi şeyler de var fakat sonra da açıklayabilirim.",
        "20": "22. Gün",
        "21": "Bugün verdiğiniz ödevi anlamak,anlamlandırmak için uğraştım. Biraz zaman alsa da üstesinden geldiğimi düşünüyorum. Başta google da “ (‘.class’) ” gibi bazı anahtar kelimeleri    aratıp konıuyu anlamak istedim çünkü verilen ödevdeki kodda “.find, .css” gibi methodlar vardı ve bunlar tanımanıyordu. Yani aslında bu kodlar başka bir yerde ya da platformda yazılmış ve burda javascript’e dönüştürülmüş olabilirdi. Ve öyle olduğunu da farkettim. jQuery ile yazılmış yapıların benzerlerinin javascript e uyarlanmış haliydi. Anlamam zaman aldı kodun işleyişinin. Şeyi farkediyorum: başta bazı şeyler göze çok zor görünüyor fakat çözünce yapıyı, aslında ne kadar basitmiş diyor insan. Evet bu kodu şimdi ben yazamayabilirim, ama algoritmasını anlamak da bence önemli ki anladığımı düşünüyorum. Gün içince yine event konusuna biraz baktım ve jQuery ile html dom elementinin manipülasyonu hakkında örneklere baktım. Ben bugünün çok verimli geçtiğini düşünüyorum. Çünkü önümüze problemler çıktıkça ve onlara çözümler üretmeye çalışırken bir şeyler öğreniyoruz gibime geliyor. Aslında object, array, döngü gibi yapıları 157.3545(küsüratlı gireyim de doğru olduğu düşünülsün prensibi) kez gördük ama yine de eksikler çıkabiliyor. Bence de bu kötü ama 22 günde de yine birçok şey yapıp, yeni şeyler öğrendiğimizi düşünüyorum. En azından kendi adıma öyle olduğunu rahatlıkla söyleyebilirim. Günün geri kalanında belki de biraz dinlenmem gerektiğini düşünüp çalışmaya ara verip bulduğum güzel yazıları okudum. Farklı konulara bakmak güzel geldi. Bugünlük bu kadar diyebilirim.",
        "22": "23. Gün",
        "23": "Bugün çok güzel geçti diye düşünüyorum. Özellikle iş sonrası yapılan etkinlik keyif vericiydi benim için. Size, patrona ve bu etkinliği ayarlayan insanlara teşekkür ederim. Evet günümüze geçebiliriz.",
        "24": "Bugün tekrar niteliğinde oldu ve biraz DOM elemetinin manipülasyonu üstüne örnekleri inceleyip kendim de bir şeyler yapmaya çalıştım. Birkaç tane kodu inceleyip, MDN ve benzeri sitelerdeki verilen yönergeleri takip ederek kendimde bir şeyler yapmaya çalıştım. Yapamadığım yerlerde çözümlerine bakıp anlamaya çalıştım. Daha önce işlediğimiz konulara da göz attım. Method, fonksiyon, class, promise gibi konulara tekrar baktım. Oturmayan yerler var mı? Bence çok az (yine de büyük konuşmamalıyım). Evet kullanım şekillerini unuttuğum yapılar var fakat biraz araştırınca hemen hatırlıyorum ve anlıyorum o yüzden çok sorun olacağını pek sanmıyorum. Tek sorunum CSS konularında çok pratik yapmayıp, biraz zorlanmak site tasarımında. Aslında bir site yapısı oluşturdum websiteize bakarak ve bence ilk çalışma için yeterli seviyedeydi ama daha da geliştirilebilir. Aklıma takılan en büyük iki şeyden biri buydu. Diğeri de async ve promise konularında örnek yapmamanın verdiği zayıflık oldu. Daha sonra yapacağız büyük ihtimalle ama söyleyebileceğim eksikliklerden biri de o.",
        "25": "Bugünlük söyleyebileceklerim bu kadardı. Yarın sizin son verdiğiniz ödevdeki metodlara, farklı metodlar ekleyip DOM manipülasyonu ile alakalı çalışmak istiyorum. Deneyeceğim. ",
        "26": "24. Gün",
        "27": "Bugün flexbox konusundaki örneklerin, çok daha fazla konuyu pekiştirip bize öğrettiğini düşünüyorum. Bir görevde flexbox yapmayıp absolute’la bir çok yeri yapınca tasarım responsive olmamıştı doğal olarak. Ama bu da bir ders oldu diye düşünüyorum ve sonrasında da flexbox kullanarak da tamamladım tasarımı (sizin de göstermenizle tabii ki).",
        "28": "Son ödevdeki açıklamamız gereken veri yapısını şöyle açıklayabilirim: “Birbirini, yan yana dizilmiş 3 ana sütun içinde tekrarlayan farklı desenlerin oluşturduğu bütün. Halıyı inceleyince her sütun, kendini tekrarlayan desen gruplarına sahip. Her grubun bitişinde, tekrar en baştan aynı grup eklenmekte. Bunu da sadece tahmin edebilirim çünkü halının kesiminden dolayı geri kalan tekrar eden yapıları göremiyoruz. Ama 3 sütunun bitişi ve başlangıcına dikkatli bakılırsa tekrar eden yapı görünmektedir. Çizim kısmını sadece flexbox kullanarak tamamladım. İskelet yapısı benzemekle beraber, veri yapısına döndürmeyi ve iki boyutlu bir diziye nasıl döndüreceğimi düşündüm ama bir sonuç henüz bulamadım. Erken uyuyup, erken uyanıp tekrar düşüneceğim. ",
        "29": "Bugün farklı olarak mesai bitiminde başka bir konuya baktım. Daha önce verdiğiniz DOM elementlerini manipüle etmeye yarayan koda bir şeyler eklemeye çalıştım. Örneğin popular kategorilerde ‘title’, ‘alt’, “img” etiketinin ‘title’ı ve “span” etiketinin içinde bulunan metin ifadesi aynıydı. Bunların hepsini (bir element ve onun child elementleri dahil) tek bir kodla güncellemek için ufak bir ekleme yaptım koda. Evet çalıştı, basitti aslında. Bir de mesela istenmeyen bir property eğer etiketlerimizde varsa hepsinde birden silmek için de ekleme daha yaptım. Aslında bu basit eklemeler dışında farklı ve çok güzel algoritmalar kullanmak istedim. Ama doğruyu söylemek gerekirse DOM’da neleri değiştirebileceğim pek aklıma gelmedi. Çünkü zaten en temel şeyler algoritmada bulunuyordu. jQuery ile neleri değiştirebileceğime biraz baktım ondan istifade edebilmek için, bundan sonra arta kalan zamanlarda daha önemli bir şey olmazsa yine bakacağım.",
        "30": "25. Gün",
        "31": "Flexbox kavramının iyice oturduğunu düşünüyorum. Bugün ve dün yapılan örneklerle beraber bence çok iyi anlaşıldı, birçok uygulama yaparak. ",
        "32": "Günün asıl önemli kısmı, flex özelliğini kullanarak HTML’I biçimlendirmekten çok, javascript ile halı desenininden yola çıkarak bir veri yapısı oluşturmaya çalışmakla, bir algoritma kurup onu kodlayacağım dil ile bir şekilde aktarmakla geçti. do…while döngüsü ve sizin dediğiniz yollarla başta denedim ama mantığnıı kafamda oturtamadım ve sonrasında biraz problem üstüne düşünüp, başka hangi çözüm yolları olabileceğini düşündüm. Aklıma en son gelen çözüm metodu ile şansımı denemek istedim. Ama bir mantık hatasından dolayı yazdığım kod doğru çıktıyı vermedi. Ben açıkçası kendi emeğimi tebrik ediyorum kendi kendime. Sonuçta denedim, ama yanlış şeyi denemişim en sonunda anladım en başta farketmem gereken şeyi. Artık daha da net anladım ki bir problem verildiğinde enine boyuna problemi iyi anlamam, sonrasında da iyi bir çözüm yolu geliştirmem gerekiyor. Aslında bunu biliyorum ama farklı algoritmalar karşıma çıktıkça onlar için geliştirilebilecek bambaşka çözüm yolları oluyor. Ve bu da gerçekten başta zorlasa da, bir şeyler yazabilince yabancı bir dilde (programlama dili) insanı çok mutlu ediyor. ",
        "33": "Diyeceklerim bu kadardı. Bugün istenen algoritmayı tüm çalışma sonucu  kuramadığımı farkettiğim an, daha önümdeki yol uzun diye düşündüm.",
        "34": "Günün klişe mottosu benim için buydu sanırım:",
        "35": "No pain, no gain.",
        "36": "26. Gün",
        "37": "Bugün zorlandım, CSS konusunda. Flexbox’ların nasıl kullanıldığını öğrendim. Ama o sitenin tasarımını yaparken bir türlü beceremedim. Sonrasında da kendime biraz zamanayırıp tekrar bakarım diye düşünüp mesai sonrasında gelip bakacaktım ama yarına bırakmaya karar verdim. Bir işi halletmeden yarım bırakmayı hiç sevmiyorum ve bu yüzden çok rahat değilim ama yapamamışsan da yapamamışımdır ve sonra derin bir nefes alıp tekrar başlamam gerekir.",
        "38": "Bugün sizin yazdığınız koda sabah baktım. Mantığını da oturtup fonskiyonları, döngüleri her elemanıyla beraber yorumladım. En önemli gördüğüm yerleri de koda yorum satırı olarak ekledim ki, bird aha baktığım da daha rahat anlayabileyim.",
        "39": "Bugün öğle vakitlerinde javascript’e bakarken şeyi farkettim: prototype ve constructor kullanımı arasındaki farkı tam anlamamışım. Konu hakkında bir şeyler araştırıp örneklere ve anlatımlara baktım ama hala anladığımı söyleyemem. O farka tekrar bakmam gerekiyor",
        "40": "Günün önemli bir aydınlanması javascript’in objelerle uğraşıyor olduğunu farketmek oldu. Fonksiyonlar, diziler aslında bir objeymiş ve null ve undefined dışındaki primitive’ler (boolean, number, bigint, string, symbol) obje değilmiş ama o şekilde davranıyorlarmış javascript için. Bu konuları daha önce işlemiştik diye hatırlıyorum ama unuttuğum için bazı kısımlarını, kendi çapımda bir aydınlama yaşadım.",
        "41": "27. Gün",
        "42": "Bugün mesainin hepsi web sitesi tasarımı ile geçti. Dün başlangıçta yapmakta biraz zorlandım çünkü copy paste yapmadan kendim en baştan yazmak istemiştim. Ama sitenin HTML/CSS elementlerine bakınca da bazı şeyleri almak istedim. Bu sefer iyice karışmıştı. Bu yüzden bugün sabah erkenden uyanıp kendim evde biraz videolarını izledim konu ile alakalı. Sonrasında mesai saatleri içinde de hallettim. Biraz yavaş ve eksikleri olsa da bence güzel bir çalışma oldu.",
        "43": "Mesai sonrasında ise Javascript,algoritma, veri yapıları üstüne biraz araştırma yaptım. ",
        "44": " örneğini inceledim. Typescript kullanıldığı için ve şu anki bilgi düzeyimin üstünde olduğu için sadece genel yapıyı ve mantığı kavramaya çalıştım öncelikle. Algoritmayı incelerken Dynamic Programming ile karşılaştım. DP ve recursive fonskiyonlar kullanılarak bir sonucu elde etmek arasındaki farkları öğrendim. En basitinden Fibonacci sayılarını recursive bir fonksiyon ile elde etmek mümkün. Fakat callstack’e o kadar çok işlem atanıyor ki, gereksiz yere sistemi yoruyor ve işlemi uzatıyor. Fibonacci sayılarından 20. terimi bulmak için 21981 kez hesaplama yapılırken, dynamic programming algoritması ile 55 kez hesaplama yapılıp işlem tamamlanabiliyor. Memoization tekniği bu anlamda çok işe yarıyor. Memoization ile, cache benzeri bir yapı kullanılıyor ve daha önce hesabı yapılanlar, bir object içinde tutuluyor. Ve ihtiyaç olduğunda direct ordan çekilebiliyor ve tekrar tekrar hesaplamaların önüne geçiliyor. ",
        "45": "Örneğe geri dönüp baktığımda ise şunu gördüm: bir fotoğrafı, anlamlı ya da içeriğin önemli olan ve yapısınının bozulmasını istemediğimiz kısımlarını aynı tutarak o fotoğrafı genişlik veya yükseklik açısından küçültmek, bizim amacımızdı. Bunun için de fotoğraf içindeki pikselleri incelemek ve ona göre işlemler yapmak gerekiyordu. Fotoğraf içindeki her bir pikseli, renk yoğunluğuna göre (pixel’s energy) tanımlayıp, bunun üstünden işlemler yapıldı. Tüm fotoğrafın piksel enerjisi için bir harita oluşturulup, o haritada bir patika elde etmekti amaç. Genişlik daraltılacaksa eğer, fotoğrafın yukarısından aşağısına kadar enerji haritası üstündeki en az enerji yoğunluğu bulunan patika seçilmeliydi. Bunun için de Dynamic Programming algoritması kullanıldı (Dynamic Programming vs Divide-and-Conquer gibi bir kıyasta varmış ama ona sonra bakacağım). ",
        "46": "Algoritma ile alakalı konuları anlamayı çok istediğim için ve bir şeyleri çözmeye çalışmak (bence) çok keyifli olduğu için bunlara baktım akşam.",
        "47": " isimli bir kaynak buldum ve boş zaman olursa buradan hem bazı konuları tekrar edip hem bilmediklerimi öğrenip hem de farklı sorunlara nasıl çözümler getirilmiş onları anlamaya çalışacağım.",
        "48": "28. Gün",
        "49": "Bugün de genel olarak CSS ile geçti. Konu hakkında çok yeni bir şey öğrenmediğim için bugün bu satırlar uzun olmayacak o yüzden. Çünkü günün çoğunuluğu öğrendiklerimi, gördüklerimi, okuduklarımı, anlattıklarınızı pratik yaparak geliştirmekle geçti genel olarak. Gün sonuna doğru bahsettiğiniz 100 cümlelik liste üstüne düşündüm. Birkaç cümle yazdım ama genel olarak yapılan işin müşteri kitlesini, isteklerini, oyun dünyasındaki alınıp satılan şeylerip ek bilmediğim için sonrasında onları biraz araştırdım. Site hakkındaki şikayetlere, bloglardaki yorumlara, diğer benzer sitelerin bot ya da canlı destek kısmındaki örnek sorulara baktım. Site içindeki agar.io benzeri oyuna girip, siteden oyuna erişen insanları gördüm biraz da merak edip işin doğrusu ağızlarını aradım site hakkında. Daha sonrasında yabancı ülkelerdeki bu işi yapan firmaların web sitelerine göz attım biraz da. Tasarımı çok iyi olan da var kötü görünen de. Site içinde birçok resim bulunup hızlı açılan da, 10 saniye boyunca yüklenmek için kendini parçalayan siteler de.",
        "50": "Bugünlük bu kadardı.",
        "51": "29. Gün",
        "52": "Bugünü öncelikle unutmayacağım. 1 ay boyunca node.js ile çalışıp, node.js mi yüklemem gerekiyor gibi saçma(sapan) bir düşünceye vararak kendimle de içten içe yeternice dalga geçtim. Ama bir sebebi vardı sormamın. Çünkü express’in nasıl kurulacağını bilmiyordum ve ilk kez gördüğüm şeyler. Acaba node.js’i kurup onunla beraber ayrı bir şekilde mi açılıyor visual studio’dan diye düşünmüştüm. Kafa karışıklığı. Olabilir diyorum ve devam ediyorum.",
        "53": "Bugün daha önce hiç duymadığım kavramlarla karşılaştım. Seri ve parallel iletişim, clock sinyali, mac ve ip adresi farkı, internet101 konuları genel olarak. Birçok bilmediğim şeyle karşılaştım, duyduklarımın aslında ne olduklarını öğrendim. TCP, UDP protokollerini, Websokcket’in ne olduğunu,cloudflare ile ddos attack’ların ve syn attack’ların engellendiğini öğrendim. Daha birçok şeyi not etmişim fakat detaylarına bakamadım express.js'i araştırırken.",
        "54": "Express kütüphanesinin (framework ve module olarak da düşünülebilir) ne olduğu üstüne öğleden sonrasında çalıştım. PHP’de http server olarak apache, nginx gibi sunucular kullanılıyor. Express.js’te ise sanal sunucu olarak kendisi var anladığım kadarıyla. Öyle büyük dosyalar ve programlar eklemek yerine bilgisayara, express.js kütüphanesinin indirilmesi yetiyor. Ne için kullanılıyor? Şimdiye kadar javascript’i client-side taraflı olarak işledik, o şekilde çalıştık. Server-side tarafına, back-end’e, yani sitenin beyin kısmına giriş yapmamıştık. Evet, Express burda devreye giriyor. Peki şöyle bir şey var: neden express’e ihtiyaç var? Mesela http modülü de var node.js’in o yetmez miydi? Yetmiyor. Evet ikisi de sunucu yaratmak için kullanılıyor fakat Express.js birçok özellik sunuyor kıyaslanamayacak kadar. Örneğin API tabanlı app tasarımında da kullanılıyor. MVC benzeri bir yapı sağlıyor. Async ve single thread çalışıyor. Çok hızlı I/O sağlıyor denilmiş fakat o kısmı anlamadım açıkçası.",
        "55": "Gelelim objelerimize: request ve response diye iki tane objemiz var en göze çarpan. Bu objeler, bir callback fonksiyonunun parametresi olarak geçiyorlar. Bu callback fonksiyonda middleware yada handler olarak geçiyor (arasındaki farka bakmadım henüz anlam ve kullanım olarak).",
        "56": "Request objesi HTTP Request’ini sunuyor ve bu objemiz “query string, body, HTTP header, parameters” gibi özelliklere(properties) sahip. Req.query, req.cookies şeklinde bu property’leri çağırabiliyoruz, normal javascript dilinde konuştuğumuz için. ",
        "57": "Response objesi, HTTP request’I geldiğinde, Express app’i tarafından gönderilen HTTP response’unu belirtir. Tarayıcıya cevap gönderir kısacası. Eğer bir kez res.send(), res.redirect(), res.render() kullanılırsa, tekrar kullanılamaz. İstenmeyen hata verir yoksa. Res.cookies, res.clearCookie, res.redirect res.send gibi method’lara sahip bir objedir. ",
        "58": "GET ve POST metodu ise REST API oluşturmak için kullanılan HTTP request’leri. (Yüzeysel olarak REST kavramını araştırdım ama sonra gireceğimizi tahmin edip, detaylaı bakmadım). Get metdou ile sadece sınırlı sayıda veri gönderilebiliyor çünkü veri header ile gönderiliyor ama POST metodu ile daha çok gönderilebiliyor çünkü veri body kısmında.  Bu nedenle GET metodu güvenli değil çünkü veri URL çubuğunda görünüyor. ",
        "59": "‘fs’ in anlamını bilmiyordum, file system module imiş. Bilgisayardaki file system ile çalışmaya izin veriyor. Dosyalar için okuma,yazma, oluşturma, güncelleme,silme, yeniden isimlendirme işlemleri yapılabiliyor.",
        "60": "App.use() ve app.get() arasındaki fark: ",
        "61": "App.get(): Specific bir route için kullanılıyor. Örneğin app.get(‘/book’) denildiyse, book dizinindeki alt dizinlere(child, node, ya da benzeri bir isim) erşiemiyor. Sadece belirtilen dizine erişim sağlıyor. Ve tabii ki sadece method get olduğu sürece erişim sağlıyor.",
        "62": "App.use(): Middleware’i uygulamaya bağlamak için kullanılıyor. Middleware function’i yüklemek için kullanılıyor diyebiliriz. Farkı ise şu: spresifik bir route için değil, o dizindeki tüm alt dallar için de geçerli bu method.  En büyük farkı aralarında bu oluşturuyor. Ve eğer get gibi kullanmak istersek use’u, regex kullanmak zorunda kalıyoruz ve işlemleri uzatıp karmaşıklaştırabiliyor. O yüzden yeri geldiğinde use, yeri geldiğinde get, yeri geldiğinde all kullanmak gerekiyor. Bu dediğim yerleri ise bir şeyler geliştirdikçe, çalıştıkça öğreneceğim.",
        "63": "30. Gün",
        "64": "Siz bizden her günü rapor olarak yazmamızı istediğiniz günden beri 30 iş günü geçmiş. 1 ayda neler oldu peki? Algoritma, veri yapıları, design pattern javascript ile programlamaya giriş, html css gibi en temel konuları işledik. Birçok şey oturdu diye düşünüyorum bu konular hakkında. Unutulan yerlerde kısa bir google araştırması ile hemen kapabiliyorum. Şimdi server-side kısmına geçtiğimiz için, tekrar konfor alanında (göreceli) çıkıldı ve iyi ki de çıkıldı. ",
        "65": "Bugün öğrenilen: client-side ve database arasında iletişimi sağlamak için, client-side ile web-server arasında iletişimi sağlamak için bizim bizim bazı işlemler yapmamız gerekiyor. ",
        "66": "Şimdi benim karşıma birisi geldi. Dedi ki ben senin sitenin, şu dizinine gitmek istiyorum. Dedim ki, tamamdır ben bi düşüneyim şimdi dönücem sana. Önce bi adama baktım. Bu adam  daha önce buraya gelmiş mi, tanıdık mı(cookies), hangi dizine girmek istiyor (get,post metodlarındaki req.url ya da ilk parametrelerimiz, eğer ben bu adamı o dizine alırsan , sonrasında ne yapmalıyım( redirect, res.send gibi) gibi birçok örneklendirilebilecek durumların sözel olarak belirtilip algoritmasının  kurulması ve  kod ile yazılması: Bizim bugün yaptıklarımız bu şekildeydi. Client ve server taraflarını birbirine bağladık. Bugünlük bu kadar. "
    },
    "part4": {
        "1": "31. Gün",
        "2": "Bugün öğrendiğim en iyi şey: İngilizce kaynaklar bolluktan geçilmezken, asla Türkçe kaynaklara bakıp, yazarın İngilizce kaynaklardan okuduğu ve dar bir pencereden sunma ihtimalinin olduğu metinlere önce bakmamak. Öncelikle iyice bakmaya fırsat bulamadığım ama yarın sabah (7saat sonra) bakacağım ilk site ve REST API ve API örnekleri olan site:",
        "3": "Günün konusu REST API idi. Başlangıçta birkaç kaynak buldum ama onlara takılı kaldığım için ve işim mantığından çok teknik tarafındaki terimleri açıklamakla zamanımı aldıkları için araştırdığım şeyin varolma sebebini anlamamıştım. Bunu maalesef yine stackoverflow’dan araştırıp güzel kaynaklara erişerek anlayabildiğimi düşünüyorum.  Günün öğrenilenleri:",
        "4": "REST, web’in mimarisel prensibinin temelidir.",
        "5": "Web’teki en garip gelebilecek ama en temel şeylerden biri: Client (browser,yani requesting machine), server( responding machine) ve onun host ettiği(sahiplik yaptığı ya da sunduğu) resource'lar hakkında önceden hiçbir şey bilmeden etkileşim kurabiliyor. Yani iki apayrı makine var. Bunlar birbirini tanımıyor. Ama birbirleriyle işlem yapabiliyorlar. Nasıl mı? Makineler isim ise, biz her ismi farklı fiiller kullanarak cümle oluşturabiliriz. Yani her makineyi bir fiil ile kullanarak onu diğer makineyle ortak anlaşabildikleri bir fiil ile etkileşime sokabiliriz. Fiilimiz ne? Fiili belirlemeden önce şu konu netleşmeli: hem server hem de client kullanılan media üstünde anlaşmalı, ve onu kullanmalıdırlar. Bu bizim başlangıç koşulumuzdur. Ki web üstünde çalıştığımız için bu durumda media’mız “HTML” olacaktır.",
        "6": "API, REST’in prensiplerini alır ve böylece REST API dediğimiz kavram oluşur. Client, API’nin yapısı hakkında bir şeye sahip değildir. Server, client’ın web service ile olan etkileşimi için gerekli olan ne bilgi(information) varsa sağlamalıdır. Mesela HTML form yapısına bakalım. Server, resource’un ve gerekli alanların yerini belirtir. Browser, bilgiyi nereye teslim edeceğini ve teslim edeceği bilgiyi önceden bilemez.Formların bilgisi server tarafından sağlanmalıdır.",
        "7": "Pratikte bu dediğimiz şeyler ve HTTP ile bağlantılı olan şey ne? HTTP resource’lar ve verb(fiil)’lerin etrafında şekillenir. GET, POST, PUT, DELETE gibi verb’ler; server’ın sağladığı talimatlara göre resource’lara uygulanır. Örneğin web service tarafından sağlanan bir user database’imiz var. Bu servis JSON’a dayalı bir hypermedia kullanır( application/json+userdb) gibi. Client ve server bu format anlamak için progrmalanmıştır. Ama ikisi de birbiri hakkında hiçbir şey bilmez. Request’I GET ile yaparak bir response u json formatında elde ederiz örnek olarak.  JSON içinde links adlı property’den resource’ları bulabiliriz. Bu da hypemedia controls olarak geçer.  Yani farklı HTTP verb’leri kullanarak resource’ları manipüle edebiliriz. Ve client tarafında bizim bildiğimiz tek şey media tanımımız.",
        "8": "GET request’I bilgi güncellemek için asla kullanılmamalı. Sepete ürün eklemeyi düşünelim.  GET etkisiz(idempotent) olmalı. Bir request’I iki kez göndermekle bir kez göndermek arasında fark olmamalı. Bu, request’i cachable yapmak anlamına geliyor. Sepete ürün eklemek ise etkisiz değil (iki kez yapınca, ürünün kopyasını iki kez ekliyor sepete). Bu yüzden bu tür işlemlerde POST request’I kullanılmalı.",
        "9": "Başka bir konu: Resource’lar URI sayesinde kimlik kazanır. Resource’ları bulmak client’a nerede olduklarını söyleyebilmek için evrensel-genel- bir yol olmalı. URI bunu sağlar. URI ve URL arasındaki fark: her URL bir URI’dir, ama her URI bir URL değildir. Neden? URI kimliğini belirtir, URL ise yerini. Yani URL de protocol de belirtilir, HTTPS gibi.",
        "10": "Asıl konuya gelelim. Bazı sebeplere ve REST’I tanımlayan şeylere:",
        "11": "Yüksek trafik hacmini destekleyecek bir mimariyi kullanmalıyız ki server’ımız farklı client’lardan gelen response’ları işlesin. Bu yüzden önceki request’lerdeki bilgileri hatırlayarak sunucumuzu yormak(ya da boğmak) istemeyiz. Bu yüzden de client-server arasındaki her request-response pair’ini birbirinden bağımsız yaparak kısıt koyarız. Yani, server yeni bir request’e cevap vermek için eski request’I hatırlamak zorunda değildir. Yani etkileşimimiz stateless olsun isteriz.",
        "12": "Sunucumuzdaki yükü daha da azaltmak için, client için daha önce yapılan hesaplamaları tekrar yapmamak için caching’ e izin verilir. Yani, client’e sağlanan ilk response’un snapshot’ı alınır. Eğer  client aynı request’i tekrar yaparsa, initial response’u yaratmak için gerekli hesaplamaları tekrar yapmak yerine snapshot’ı client’a sağlar. Ancak snapshot olduğu için bunun bir expire date’i olur, server’ın sağladığı. Eğer expire date’i geçmediyse ve response update edildiyse, catch in expire date gelmedikçe veya tekrardan sayfa render edilmedikçe client update’leri göremeyecektir.",
        "13": "Layer konusuna gelirsek eğer: Sistemimizdeki her layer, komşusu olduğu layer ile etkileşime girer.Yani client layer’ımız bizim server layer’ımız ile etkileşime girer. Ama ana server layer’ımızın bir request’i işlemesine yardım eden başka bir server layer’ımız olursa eğer, client bu layerlar ile direkt olarak iletişim kurmaz. Denildiği gibi herkes komşusu ile iletişime geçer. Sunucu requset’in gerektiği gibi iletir bu durumda da.",
        "14": "API ne idi? API emekti klişesinden uzaklaşıp hemen detaya bakalım: Bir yazılım parçasının, diğer yazılım parçası tarafından kullanılması durumu.  Amaç, app’ler arasında iletişim sağlamak. Makine ile makineyi konuşturmak. Web API mesela: ne zaman request gelirse, bir app client’e data gönderir.  API sadece web development’ta yok. File  system veya http module’ün kullanımı aslında bir API örneği. Sizin de dediğiniz gibi, işletim sistemi, windows bir program. Ve bu program bize kendi içinden bir kod parçasını (api’yi) kullanmamıza olanak sağlıyor. Ve tabii ki authorization, authentication gibi konularla bizim o kod parçasından ana programı manipüle etmemizi ve istenmeyen yerlere erişmemizi engelliyor. ",
        "15": "Bugünlük bu kadardı. Genel olarak mantığı anladığımı düşünüyorum.",
        "16": "32. Gün",
        "17": "Bugün en kısa raporumun olacağı gün olabilir. HTTP prokolü ile anlaşan ve konuşan makineler arasındaki ilişkinin bizim için en optimize ve isterlerimize uygun hâlde düşünerek bir sistem üretmeliyiz. Ya da en azından algoritmasını oluşturmalıyız şimdilik. 3 tane server olsun denildiği için ve bir tanesinde bazı bilgiler tutulduğu için onu database gibi ele almıştım. Database sunucusu tüm verilerimizin olduğu bir depo gibiydi. Bu depoya erişim sadece sunucularımız tarafından gerçekleştirilebilmeli, client ise sadece dosya ekleme ve çıkarma listeleme gibi işlemleri database sunucumuzda değil, ayrı bir sunucuda ona verilen yetkiler ile yapabilmeliydi. Bu durum için de, yani yetkilerin belirli olduğu kısıtlı bir alanda ( tıpkı web uygulamalarımızı yazarken paypal, twitch, youtube, google bize nasıl apiler sağlıyorsa ve bize verdiği kısıtlı alan içinde bir şeyler yapabiliyorsak) işlemler gerçekleşsin dedim. Mesela dosya listeleme işlemi ya da dosya ekleme/silme işlemi, yine bu alanda gerçekleşmeliydi bu mantığa göre. Database sunucusunda verilen metodları (fonskiyonları) kullanarak bunlar gerçekleştirilebilir diye düşündüm. ",
        "18": "Yarın farklı bir bakış açısıyla tekrar soruyu ele alacağım ve öncelikle dediğiniz şekilde çözümü oluşturmaya çalışacağım. Birçok kavram birikti ki aslında, birçok şey hakkında fikirsel anlamda parçacıklar oluştu fakat bütünü oluşturmakta biraz zorlanıyorum.",
        "19": "Bir de şu sitedeki",
        "20": "kavramlara (frontend, backend, ve diğer konular için ayrı ayrı ) bakıyorum. Bir şeyler öğrendiğimi, ama onlarca kez duyduğum şeyleri hala öğrenmemiş olmak ve öğrendiklerimi de daha çok pekiştirip gerçekten kendime özgü bir algoritma kurup bir şeyler ortaya çıkarmayı dört gözle bekliyorum.",
        "21": "33. Gün",
        "22": "Bugün farklı konulara biraz göz attım ama günün çoğunluğu REST API üstüneydi. Öncelikle sizin verdiğiniz görevi yaptım. Büyük ölçüde doğrudur diye düşünüyorum ama kime göre doğru neye göre doğru. Ve neye göre optimize onu bilmiyorum. O görevden sonra tamamen REST API üstüne yazılmış bir kitap okudum. Evet, konu hakkındaki bir kitabı da bitirmiş oldum. Birkaç gündür çalışırken zorlanmıştım ama kitabı okurken aslında basit şeyler olduğunu düşündüm. Ve 3 gün önce çok karmaşık gelen şeyler şimdi daha anlamlı gelmekte. Büyük ölçüde konuya vakıf olduğumu düşünüyorum artık.",
        "23": "Mesai sonrasında biraz farklı algoritmalar görerek; ufkumu, limitimi genişletmek istedim. Bir tane machine learning (neural network) yapısını en en basit şekilde kurgulayıp sadece javascript ile bir algoritma nasıl oluşturulur ve yazılır ona baktım. Adı üstünde makine öğrenmesi olduğu için, 3-4 gündür üstünde durduğumuz server-client konusunda makineler söz konusu olduğu için acaba machine learning konularını burada uygulayabilir miyiz diye düşündüm. Web app’I için chatbot, recommendation gibi konular zaten AI ya da benzeri şekillerle yapabiliyorken server’lar ve server-client arası iletişimde ne olabilir diye düşündüm. Ama henüz bir şey bulamadım. ",
        "24": "34. Gün",
        "25": "Bugün ve dün çok soft geçti diye düşünüyorum. Boş kaldığım zamanlar hep bir şeyler katmaya çalıştım yine. Bugün verdiğiniz görevlerde de genel olarak mantık yürütülerek yapılan şeylerdi ve genel mantığını kurabildiğimi düşünüyorum sizden tam bir feedback almamış olsam da sizden.",
        "26": "1 ayda olan değişikliği en basit şekilde şöyle açıklayabilirim: 1 ay önce obje nedir bilmiyordum. Design pattern nedir,neden kullanılır bilmiyordum. Javascript’I hiç bilmiyordum. CSS’I ben ne ara temel seviyede öğrendim hala anlamış değilim mesela. Şu an ise javascript ile bir şeyler yazmak ya da o dilde yazılan şeyleri okumak, yeni algoritmaları bulup öğrenmek, çözmek, bulmaca  gibi eğlenceli geliyor. Bugün demiştiniz hani, aranızda yarış var mı ya da öyle şeyler var mı diye. Evet bazen kim hızlı cevap gönderdi, kim hızlı bitirdi, kim hızlı anladı gibi şeyler dönebiliyor. Bu, şu an olan atmosferden ve şartlardan dolayı diye düşünüyorum. Ama ben kendimi soyutlamaya çalışıyorum gündelik yaşantı, diğer insanlar, başka insanların maaşları, düşünceleri, kadın-erkek ilişkileri, arkadaşlıklar ve her ne ise. Sebebi mi? Motivasyonum, yani bu işi öğrenmeyi kafama birkaç ay önce koydum ve ciddi ciddi bir tutku ya da hobiye dönüştüğünü hissediyorum. Ya da öyle bir şey yoktur ben de sallıyor olabilirim. Ama yok gerçekten çok zevk alıyorum. Ve bu güzel şeyin bozulması en son istediğim şeylerden biri. Bu yüzden kendimi insanlarla kıyaslarsam mutlu olamam, motivasyonum düşer. Stres olurum. O yüzden de insanlarla değil, yaptığım işle ilgilenmek en güzeli. Hem ekmeğimi kazanıp, hem de sevdiğim işi yapmak bence çok çok büyük bir şans. O yüzden de mutluyum ve biraz fazla belli ediyorum. Ama elimde olduğunu da düşünmüyorum.",
        "27": "Son bir şey. Gönderdiğiniz kitaptaki algoritma ile alakalı çok basit bir örnek vardı. O basit örneğe kendim de yine sadece 10 satır olan güzel bir seçenek yazdım(kitaptaki örneğe göre döngü sayısını çok daha kısa tutan). Ve o en basit şey bile çok mutlu etti. Evet gereksiz yere beyninizde bir yer kaplamış olabilir bu dediklerim.  Kusura bakmayın (:",
        "28": "Bugünlük bu kadar.",
        "29": "35. Gün",
        "30": "Bugün tamamen CSS ile geçti. Tamamen tekrar ve pratik niteliğindeydi. Yeni bir şey öğrendim mi? Kayda değer yeni bir şey öğrenmedim. Ama unuttuğum kısımları hatırladım. Mesai sonrası sadece karosel örneklerini inceledim. Evet sıralı normal bir karosel yapılabilir sadece javascript ve CSS ile fakat mouse ile sürüklenebilir bir karosel yapmak çok zormuş onu anladım. Birkaç saatimi vermeme rağmen olmadı. Örneklerine baktım internetten. SCSS, React Js, Angular Js ile çok çeşitli şekillerde yapılmış ama basit seviye CSS ve Javascript le bir yolunu bulamadım. Açıkçası  yolları ve yapılan örnekleri vardı fakat bir hayli karışıktı. Bugünlük bu kadardı.",
        "31": "36. Gün",
        "32": "Dün yaptığımız örnek bence biraz fazla problemliydi bence. Ama bir şekilde bitti tabii. Bugün verdiğiniz örnek ise flex yapısı ile çok güzel  göründü. Sayfanın yapısına responsive’lik açısından düşününce flex’lerin kullanımı çok işe yaradı. Sayfayı bitirdim fakat karoselli kısımları yapmamıştım. İlk karosel ile alakalı çok güzel bir w3school örneği buldum. Onu inceleyip benzerini bizim sayfamızda yapmaya çalışacağım yarın. Yeni bir şey öğrendim mi? Pratiklik açısından bazı şeyler öğrendim fakat yepyeni bir algoritma ya ufkumu açan bir şey bugün olmadı. Ama güzel bir gündü iş açısından. ",
        "33": "37. Gün",
        "34": "Bugün CSS ile alakalı yaptığımız site tasarımından ben tatmin oldum. Özellikle karosel biraz uğraştırdı. Basit bir copy-paste değildi. Nerede neyi, neden kullandığını anladım. Karosel kısmı da oldu. Tabii ki en optimize çözüm , responsive tasarım gibi konular söz konusu. Responsive’lik konusunda da iyiydi bence. İlk defa kendi yaptığım bir şeyi övüyorum galiba neyse burayı geçeyim.",
        "35": "PHP ve Javascript (bunu öğrenmiştik aslında ama farklarına bakarken yine araştırdım) dillerindeki değişken scope’ları hakkında araştırma yaptım. Üstüne ufak ufak örnekler yazdım ki, yazılan şeyin manası ne imiş anlaşılabilsin. Bu aslında bir ödev yapmaktan ziyade, kendime bir şeyler anlatmak ve bir depo gibi o yapılan şeyi tutmak için yapılmış bir şey.",
        "36": "Özetle günün öğrenilenleri ve yapılan pratikler: CSS(özellikle karosel çalışması, ve diğer düzenlemeler), PHP de scope konusu.",
        "37": "38. Gün",
        "38": "Bugün “w3school”daki PHP ile alakalı birçok şeyi araştırdım, öğrendim ya da öğrenmeye çalıştım. Ve bugün şükrettim. Günün en güzel şeyi de o şükretme hissiyatıydı. 1 aydan fazla zamanda Javascript ile çalışınca aslında bir şeyleri öğrendiğimi, PHP içeriğine bakarken farkettim. O kadar hızlı anlaşılıyor ki PHP’deki konular şaşırdım açıkçası. Tabii ki derin konular değil, ama genel olarak konsepti, içeriği çözmek çok daha hızlı oluyormuş. Bugün bu yüzden yapımda emeği geçen herkese bol bol teşekkür ettim kendi içimden. Sizin, karanlık ormanda meşalenin aydınlatması  sembolizmi ile anlattığınız hikaye  tabii ki doğru fakat benim meşalem hala çok çok zayıf ışık veriyor. Bu yüzden çok teşekkür ederim tekrar yolumu aydınlattığınız için büyük meşale ile. Bugün PHP çalışırken aslında Javascript çalışmışım gibi de hissettim. Çünkü temel yapılar (kodlama,programlama,scripting, adına ne denirse) açısından örtüşüyordu birçok yerde. Ama bugün özellikle şeye şaşırdım: PHP’de milyonlarca fonksiyon varmış gibi hissettim. Gerçekten her konuda yazılmış built-in bir fonksiyon mutlaka varmış gibi göründü. Ben o fonksiyonları ve işlevlerini okurken, kafamda acaba bu fonksiyonun algoritması nasıl kurulmuş ve yazılmış diye düşünceler beliriyordu. Sizin Jquery’deki DOM manipulation için yaptığınız örneği incelerken hissettiğim ile benzer bir şeydi bu. Bugün şeyi de farkettim PHP çalışırken. Biz aslında Javascript’te object-class konusunda birçok örnek yapmıştık ve ben bunların genel konseptine bir anlam verememiştim o zaman. Neden yapmıştık biraz anlasam da bunun genel isminin OOP(ya da OOP’nin yapı taşı) olduğu düşüncesi hiç gelmemişti. Bugün PHP’de OOP konusunu okurken fark ettim tabii ki. Bu kadar uzun bir paragrafın okunurluğu tabii ki de çok düşük fakat bir şey daha eklemek isterim: Bir şeyleri öğrenirken, konseptini anlamaya çalışırken, başka insanların problemlere getirdiği çözümleri ve web geliştirmedeki kavramları öğrendikçe, açlığım dinmiyor üstelik biraz dinlendikten sonra tekrar bakmak istiyorum. Bu bana çok garip geliyor. Daha önce böyle bir hissi yaşamamıştım sanki diye düşünüyorum. Evet lisede matematiği, fiziği çok severdim. Evet çok çalışırdım, ama şu an ki arzumu sadece şeyde hatırlıyorum: Trigonometrinin ne demek olduğunu öğrenirken. Yıllar sonra yine aynı çocuksu ve saf isteğin oluşmasından çok mutluyum. Enişten dileklerimle yine çok teşekkür ederim. Umarım bu emeğinizin, yatırımınızın karşılığında sizin de yüzünüzü kara çıkarmayız, biz de çok şeyler öğreniriz. Makine(bilgisayar, web sunucu, client, ne denirse) dilini “native speaker” seviyesine kadar yükseltebiliriz. Yani bu çok zor olsa da, neden olmasın değil mi?  Kısacası çok daha “işe yarar” oluruz çalıştığımız konuda, şirkette. Evet biraz fazla pozitiflik (ve belki boş laf) saçtım farkındayım ama içimdeki hisleri de yazmasam içimde kalacaktı, çok hoş olmayacaktı.",
        "39": "Günün özlü sözü Steve Jobs’tan gelsin:",
        "40": "“Stay hungry, stay foolish”. ",
        "41": "Öğrenme açlığımızın, azmimizin hep devam etmesi dileği ile.",
        "42": "39.Gün",
        "43": "Bugünkü örneğin javascript kısmını yapmasaydınız ben yine de yapabileceğimi düşünüyordum. Ama biraz fazla zaman alırdı çünkü recursive kısmını oturtamazdım. Hissettiğim eksiklik, bir programlama dilinden çok işin mantığı olduğu için mesai sonrası recursive fonskiyon örneklerini, algoritmalarını inceledim. Kolay olanlarını kendim yazmaya çalıştım. Orta zorlukta olanlarda (trade-off yaparak*hız-zaman*yapılabilirlik konularında) ise direct yazarların çözümlere bakış açılarını anlamaya çalıştım. Bir probleme verielecek farklı cevapların kurulduğu düzeni anlamaya çalıştım. ",
        "44": "Mesela “n” kadar basamağı olan merdiveni bir veya iki adım atan bir insan kaç farklı şekilde çıkabilir gibi bir soruyla karşılaştım. Temelinde çözümü “n”inci Fibonacci sayısının kaç hesaplama yaparak bulunacağı algoritması ile de benzerdi. Recursive çözümlerini (bellekte bir dizi tutup tekrar tekrar aynı hesaplamalı yapmayı engellemek ve diğeri de brute force algorithm denilen ve çalışması programı, CPU’yu yoran ve zaman alan en basit recursion metodu ileydi) anlasam da, dynamic programming yönteminde bir yeri tam anlamadım. Bir süre daha baksam anlaşılır ama günün yorgunluğu ile ona çok odaklanamadım. Örnek algoritmalara şuradan ulaştım:",
        "45": "Javascript Algorithms",
        "46": "Peki bugün ne yaptın Buğra? Mesaide ne yaptın onu anlat derseniz, öncelikle sizin verdiğiniz örneği sabah kurguladım. Ne yapmam gerektiğini belirledim. Yapmaya hazırlanırken siz Javascript’te nasıl yazıldığını gösterdiniz.  Sonrasında ben yine bir şeyler denedim ama olmadı. Açıkçası kodlarla oynamak o kadar zevkliydi ki hep başka şeyler yapıp, neyin ne işe yaradığını, ne ile neye ulaşılacağı gibi şeylerden dolayı biraz zaman kaybettim. Siz sonra tekrar Javascript kodunu yazdırınca onu PHP’ye döndürmesi çok kolaydı. Tek sorun PHP’yi çok bilmediğim için yeni kavramları tek tek araştırmam. Ama bu da normal bence. Bugün hissettiğim en güzel şey, PHP’de yazılan kod ile direct client tarafında bir çıktıya sahip olabilmemiz. Bugün hissettiğim en çirkin şey de, PHP’de biz debug’I nasıl yapıcaz sorusu. Node.js ile Javascript kodunda hata olduğunda nerde olduğunu ya da neden olduğunu görmek çok daha kolaydı. Ama burda (yeni olduğumuz için bir de) görmek kolay değil gibi geldi. ",
        "47": "Şimdiye kadar çok şey yaptık (göreceli olarak). Bunu da öğrenebileceğimize eminim.",
        "48": "1 ay önce biraz daha şu metod şu işe yararmış gibi ezber yapıyordum ama şu an ne kadar çok çalışırsam, ne kadar çok problem ve çözümü görürsem, ulaşırsam o kadar çok maruz kalacağım için daha iyi öğrenileceğini düşünüyorum. Tıpkı yabancı dil gibi. O yüzden tek amacım olabildiğince maruz kalmak bu dile, bu evrene.",
        "49": "40. Gün",
        "50": "Günün çoğunluğu PHP ile ilgili konuları araştırmakla geçti. Javascript’te öğrendiğimiz yapıların PHP’deki çalışma şekillerini öğrenmeye çalıştım. Daha çok okumakla geçtiği için pratik yaparken biraz tökezleyebilirim ama aşinalık kazandırdı. ",
        "51": "W3Schools'taki",
        "52": "PHP ile ilgili birçok konuyu okuduğumu, anlamaya çalıştığımı, gerekince kendim de yazmaya çalıştığımı söylemeliyim. Özellikle Javascript’te şimdiye dek ne ile karşılaştıysak onların PHP’deki karşılıklarına(varsa) bakarak bir çalışma yaptım diyebilirim. Aklıma çok bir soru takılmadığı için size bir şey soramadım. Takılan kısımları google’layıp bulabildim. Javascript’te çoğu şey object’ler üstüne oluşturuluyordu. PHP’de hangi veri yapısının daha baskın olduğunu anlayamadım ama fonksiyonların çokluğu beni yine çok şaşırttı (Gerçi Javascript’te gördüğümüz kadarıyla onlar da bir obje gibi düşünülüyordu, PHP’de nasıl onu tam bilmiyorum). Associative array ve class’ın bir instance’I olarak daha önce öğrendiğimiz object yapısının iki şekilde oluşturulması ilginç geldi. Sadece associative array yapılabilir miymiş diye şu an bir düşündüm. Ama yıllardır çalışan bir program için gereksiz bir şeyin yazılması söz konusu değildir diye kendi sorumu cevaplıyorum (Cevap büyük ihtimalle object-class ilişkisinin oluşturulması gerekliliği ile alakalı). Bugün mesela “__constructor(), __destructor()” gibi iki method gördüm class içinde oluşturulan. Başta getter setter mantığına çok benzetmiştim. Ama “__constructor”, Javascript’teki “constructor” ile aynı işlevi görüyormuş. Bugün beni en şaşırtan şey, Javascript’te karşılaşmadığım “public, private, protected” gibi “access modifiers” ile karşılaşmak oldu. İlk defa karşılaştığım terimler olduğu için iyi anlamaya çalıştım. Hızlı kavradığımı düşünüyorum, çünkü basitlerdi. Tıpkı Javascript’te olduğu gibi burada da static metodu bulunmaktaydı. Bir de namespace, iterables, trait, interface, abstract gibi “class ve method’”lar ile karşılaştım. Bunlar üstüne örnek çözmediğim için hafızamdan hemen silineceğini varsayıyorum. O yüzden biraz daha detaylı bakmam gerekebilir.",
        "53": "Aslında her öğrendiğim şeyi güzelce açıklayıp buraya yazmak çok istiyordum fakat bugün çok çok fazla şeye baktığım için yazmaya girişirsem sayfalar alabilirdi. Bunun yerine örneklerle karşılaşınca çözmeye çalışmak, kullanmak ve o şekilde yazmak daha mantıklı geldi."
    },
    "part5": {
        "1": "41. Gün",
        "2": "Bugün daha önce çalıştığımız ve Javascript’te kodladığımız bir programın PHP haline dönüşümünü inceledik, yaptık. Açıkçası PHP’ye dönüştürmek zor değildi. Aslında hiçbir şey zor değil(en azından gördüklerimiz kadarıyla). Sadece hâlâ yeni olduğumuz için ve ilk defa gördüğümüz terimlerden dolayı zorlandığımızı düşünüyorum. Bugünün en güzel noktası daha önce yaptığımız bir çalışmaya katkı yapmamızdı. Sil baştan bir yapı kurmamız beklenseydi daha zor olurdu evet. Bundan sonra zorlaşacağını düşünüyorum tabii ki, çünkü bu sadece alıştırma gibiydi. Terimlere, PHP’de yazmaya aşinalık olsun diye gibiydi sanki. Ne, ne işe yarıyormuş çalışması gibi. Server tarafı olduktan sonra (ne kadar optimize şaibeli olsa da), HTML-CSS-Javascript ile birleştirmeye çalıştım. Javascript kısmından önce form işlemlerinin nasıl yapıldığı konusunda biraz tıkandım. Sonrasında sizin de yardımınızla o problemi çözdüm.  Server tarafında işlem yapınca hiç bir problemle karşılaşmasam da, client’tan veri geldiğinde işlerken bazı sorunlar oluyor. Onu kendime “future development” olarak koydum (future derken, yarın olursa da şaşırmam). ",
        "3": "Bugün ne mi öğrendim?",
        "4": "PHP’deki temel fonskiyonları öğrendim. Array_search()’ü, isset()’i, array_push()’u, in_array()’i, count()’u, array_diff()’i, unset()’i, array_values()’u,array_column()’u kullandım. Biraz fazla şey yapmak istediğim için hepsini tam öğrendim mi? Biraz daha tekrar yapmam gerekiyor. Ama kullanırken her şeyin neden, nerede , ne ile, nasıl kullanılacağını anlayarak yaptım. ",
        "5": "Switch-case, if-else-else if, for, foreach yapılarının hepsini kullandım. Javascript’le tek fark foreach’te bulunuyor. Diğer yapılar tamamen aynı. PHP’de associative array, class, fonksiyonları oluşturdum. ",
        "6": "Son olarak server tarafını client ile daha şık bir şekilde bağlamak için HTML kısmını koduma ekledim.",
        "7": "Asıl düşüncelerim: Çok daha fazla çalışmam ya da tekrar yapmam gerekiyor. Javascript ile yapabileceğim şeylerin sınırını bilmesem de hala çok sınırlı ve sığ bir noktadayım. PHP’de evet bir şeyler yapmaya çalıştım ama bunların tekrarını ve sonrasındaki çalışmalarımız için de iyi bir çalışmayı kesinlikle yapmam gerekiyor. ",
        "8": "42. Gün",
        "9": "Bugün bazı şeylere çok takıldım. Kodun bir yerinde bir hata alıyordum, düzeltmeye çalışıyordum, çalıştım, ama orayı hâlâ düzeltemedim. Sanırım zinde bir kafa ile tekrar bakmam gerekecek ama onu yapmamak üzdü. Ne miydi? Kullanıcıdan verileri “POST” metodu ile aldık. Onu bir “.txt” uzantılı dosyaya yazdık. Dosyaya yazma ve dosyadan okuma işlemlerini yapabiliyorum. Dosyaya yazılan elemanların, her yeni eleman “takımı” girişinde yeni bir satıra atlaması; satırların her birinden yeni bir array olarak oluşturma(multidimensional oluyor tabii ki toplamda), ve oradan da istediğimiz kısmı array_column ve in_search ile çekilmesi kısmını tamamladım. Belki uzun bir yoldu ama oldu. Fakat işlemlerin devamında bazı mantıksal hatalar yaptım sanırım ki çalışmadı. Yarın ilk işim bunu çözmeye çalışmak olacak.",
        "10": "Bugün öğrenilenler: GET ve POST metotları ile kullanıcıdan bir verinin çekilip, onun request’ine karşılık response gönderilir bunu öğrendim diyebilirim.  HTML, CSS taraflarında pratiklerimin faydasını bugün hissettim. Çünkü en basitinden bir şeyleri hızlıca tasarlayabiliyorum (Amacımız PHP tarafı olduğu için sadece görünümde işimize yarayacak kısımları yaptım aslında). ",
        "11": "43. Gün",
        "12": "Bu yazacaklarım sizin zamanınızı gereksiz alıyor olabilir, okumazsanız ya da içinizden/dışınızdan eleştirirseniz anlarım. Biraz daha bilgi ağırlıklı şeyler yazmak istedim fakat iş esnasında bilgi ve yoruma dayalı çıktıları sağladığımı düşünerekten ve yaptığımız görevlerde kullandığımız şeyleri özetleyen ya da örnekleyen “cheatsheet”lerimi tuttuğum için bugünlük de biraz fazla yorumlu bir gün sonu raporu yazıyorum. Bir de ilk başladığımızda SEO’ya günde bir saat bakın demiştiniz fakat ona da bakmayalı uzun süre oldu, kodlamaya kafa yorduğumuz için. O da hep aklımda duruyor. ",
        "13": "Öncelikle, bugün çok verimli geçti. Dün yaşadığım problemi sabah rahat bir kafayla çok daha basitçe halledebildim. PHP kısmında yapmam gerekenleri tamamladıktan sonra, sizin de yönlendirmenizle SQL, MySQL, PHP- Veritabanı arasındaki iletişim gibi konuları araştırdım. Açıkçası direkt üstüne kendi yazdığımız kod ile birleştirmeyi deneyecektim fakat yarına bıraktım. Bugünün tek kötü yanı dün gece biraz üşütmüş olmam ve gün içinde hâlsiz hissetmemdi. Enerjimi biraz düşürdü ama yapmam gerekenleri tamamladım. Veritabanından sorgu yapmayı, PHP’den veritabanına bağlanmayı, temel olarak PHPMyAdmin’i açmayı ve biraz kurcalamayı, kendime bugün görev edindim. Cookie nasıl oluşturulur ve tutulur, kullanıcı bilgileri gelen form bilgilerinden çekildikten sonra veritabanına nasıl kaydedilir örneklerine baktım. Konsepti biraz oturtabildiğimi düşünüyorum (okuyarak ve inceleyerek bir yere kadar tabii ki, yarın iş üstünde pratik vakti olacak). Şirkete gelmeden önce de az da olsa veritabanına bağlanma gibi konulara bakmıştım, daha çok youtube’tan izleyip kendim de bir şeyler deneyerek. Elbette o da işe yarıyordur fakat dokümanlardan ve yazılı kaynaklardan okumanın ve anlamanın, üstüne uğraşmanın da epey katkısı varmış. Üniversitede kitaplar ve çıkmış sorular olsa da bazen Hintli veya Batılı hocalar ya da bilgili kişilerden dinleyip de öğrendiğim de çok oluyordu. Direkt kitabı tarayıp  istediklerimize de erişiyorduk. Bunu anlatmam gereksizdi sanki ama eklemek istedim. Şu an yaptıklarımızda bu şekilde olduğu için çok zorluk çektiğimi sanmıyorum, özellikle bu bilgi bolluğu içinde. Bazen kendimi biraz fazla kaptırıyor olabilirim ama bu da beni kamçılıyor. Açıkçası 1.5 aydır yaşadığım her şey beni kamçılıyor çalışma konusunda. Sanki kamçılanmak için yer arıyorum gibi hissediyorum. İş öncesi süreç, işteki süreç, insanlar, severek yaptığım iş(ki iş gibi de değil hobi gibi hissediyorum. Bu tabii ki sadece yazılım üstüne çalıştığımızdan değil, ortamın yani sizin de sunmuş olduklarınızla sağlanıyor), kazanılan para (aileye bağımlılığı ya da yükü bitiriyor), gelecek ve geçmiş üstüne düşünceler, çalıştığım alanda dünya çapında insanların katkıları ve onların yaptıklarını görünce gözlerimin içinin gülmesi, kendimi de geliştirip hem kendime, hem çalışıp para kazandığım ve sorumlu olduğum ve ayrıca bana yatırım yapan insanlara, hem de diğer konusunda uzmanlaşan geliştiriciler gibi bu “community”ye bir katkı sağlama ihtimalimin olması beni etkiliyor. Olumlu yönde tabii ki de. ",
        "14": "Bugün gün sonuna doğru aklımda sadece “Buğra bugün bitmeden SQL sorgusu yazmayı  kısa vadede işine yarayacak kadar öğrenmelisin ve PHP’den veritabanına bağlanıp, client’tan gelen  veriyi tutmalısın. Bunun üstüne de client’a cookies gönderip onun da id’sini ya da session bilgisini tutmalısın” gibi düşünceler geçti. Ama acele edecek bir konu olmadığı için sakince yarın başlamak istedim. ",
        "15": "Bugünlük bu kadardı.",
        "16": "44. Gün",
        "17": "Ben aslında yavaş öğrenen bir insan olduğumu düşünüyorum. Yani çok zeki olmadığımı, ama çok çalışarak istediğim sonuca ulaşacağıma inanıyorum. Neyse insan faktörü ile alakalı bir şey yazmadan konumuza geleyim. Çünkü işin içine insan girdiğinde çok fazla parametre oluyor ve bu şu an benim değil sosyologların, psikologların, ve diğer sosyal bilimcilerin uzmanlık alanları.",
        "18": "Bugün genel olarak araştırma ile geçti. Aslında çok hızlı bir şekilde veritabanına PHP ile bağlanıladabilirdi ama biraz fazla okudum. Araştırdım. Veritabanından bir satır silence, sonra eklenecek satırların neden silinen satırın primary key’inden sonraki sayı oluyor ona pek anlam verememiştim. Hâlâ daha biraz mantıksız geliyor. Ben bir kullanıcı sildiysem onun yerine artık başka bir kullanıcı o id’yi alabilmeli düşününce. Ama sistem buysa, buna göre çalışıp çok da sorgulamamak lazım belki de.",
        "19": "Bugün en etkilendiğim konu veritabanı ya da PHP konusunda değil, mesai sonrası baktığım “metaverse” kavramı ile ilgiliydi. Ütopik mi yoksa Black Mirror gibi distopik bir evrene mi sebep olur bilinmez ama okuması keyifliydi üstüne yazılan yazıları, hayalleri, yatırımları.",
        "20": "Bugün en keyif aldığım konu ise veritabanına PHP’den ulaşıp dilediğim gibi işlem yapabilmemdi. SQL sorgusu da aslında biraz pratikle rahatça yapılabilecek bir şey çünkü her sorgu aslında bir cümle gibi. Çok basitleştirilmiş kullanıcı (bizim) için. O yüzden pek zorluk çekeceğimizi sanmıyorum. Kullanıcı verilerini kaydettim. Client’tan gelen veri ile database’dekini karşılaştırıp işlemler yapabildim. Sonrasında bilgi güncelleme gibi konulara girecektim ki kullanıcıya session id ya da genel anlamda cookies göndermem gerektiğini fark ettim. Sonra onun üstüne de biraz araştırma yaptım, sebeplerini, nasıl kullanıldığını, ve örneklerini. Daha önce de baktığım şeylerdi aslında ama aşırı hızlı tempoya şu an ihtiyaç olmadığı için ağırdan almak istedim. ",
        "21": "Bugün en rahatlatan konu ise şuydu: İki gün önce yaptığımız “.txt” uzantılı dosyayı veritabanı gibi kullanıp veri kaydetme işleminden çok çok daha kolaydı bugün yapılanlar. Arasında bu kadar fark olduğunu bilmiyordum. “.txt” dosyasından bir veriyi almak biraz daha uğraştırıcıydı. Oysa burda uğraştıracak bir şey yoktu. SQL sorgusu zaten  basit bir cümle olduğu için yazımı çok daha kolaydı. ",
        "22": "Yarın farklı bir görev verilmezse, client’a cookie (daha doğrusu session id) gönderip, onu tanıyıp (stateless kavramını esneterek) veritabanı ile işlemler yapmaya çalışacağım.",
        "23": "46. Gün",
        "24": "Bugün de veritabanı ve PHP ile ilgili çalışmalarla geçti. Ürün bilgilerini ve ürünlerin ait olduğu kategori bilgilerini veritabanına ekledik ve onlar ile ilgili işlemler yaptık. Switch-case konusunda gerçekten over-engineering denilen kavramı sonuna kadar yaşatmışım. Bunu görememem bir hataydı. Hem object oriented hem de procedural şekilde veritabanı ile ilişki kurmam da hatalıydı. Kullanıcıdan veri alışverişinde sadece prepare ve object-oriented yapı kurmam gerekli olur diye öyle yapmıştım fakat bundan sonrasında buna kesinlikle dikkat edip aynı hataya düşmemeye çalışacağım. Bunlar dışında bugün verilen görevi yerine getirebildiğimi düşünüyorum. Kod okur yazarlığımın da geliştiğini düşünüyorum ayrıca. Üniversitede dersler genelde sadece dersi verip geçme üstüne kurulu olduğu için ve çıkmış sorular çalışarak konuya özel bir ilgi duymuyorsa insan sadece ezber yaptığı için genelde bir şey öğrenmeden ya da edinmeden tamamlıyor süreci. Oysa şu 2 ayda birçok şey öğrendiğimi düşünüyorum. Çünkü ne çıkmış soru vardı, ne de ders geçme derdi. Görevler verildi. Gerekli bilinmesi gerekenler anlatıldı. Ve ben de üretmeye çalıştım. Elbette copy-paste’ler ve başka insanların yaptıklarından yaralanmak vardı bu süreçte. Tekerleği yeniden icat etmedim fakat tekerleğin hangi arabaya nasıl takıldığını, hangi tekerlek takıldığını, tekerleğin ne işe yaradığını öğrendim. Ve ben bundan çok memnunum. Umarım bir ilüzyon değildir yaşadığım çünkü verilen emek ve çalışmanın gerçekten bir karşılığı olduğunu hissediyorum.",
        "25": "47. Gün",
        "26": "Bugün gerçekten de en verimsiz geçen gündü. Aklıma takılan sorunlardan dolayı. İyi ki konuştuk. Gün içinde ne yaptım dersem. Görev olmadığı için genel olarak bol bol bir şeyleri araştırdım, karşıma PHP ile ilgili bilmediğim çıkan ve anlayabileceğim ne varsa. Mesela veritabanına kullanıcıların şifrelerini eklerken password_hash() yapısı ile şifreledim. Sonrasında kodumun her yerinde şifre ile ilgili kullanılan her kısmı buna göre düzelttim. Neden bunu kullandın derseniz onca hyapı arasında; sha1,sha2, md5, crypt() gibi ve daha birçok yapıyı araştırdım. Hashing ile oluşturulan kriptografi  ile alakalı farklı kütüphanelerin de yine PHP için kullanılabileceğini  öğrendim. Fakat en genel manada md5 veya sha1’in içerdiği hash yapısının çözülmesi çok daha kolay olduğu için günümüz teknoloji ve ekipmanları ile, hash yapısına ayrıca “salt” diye bir şey eklendiğini öğrendim. Bunu manuel olarak girmek veya oluşturmak mümkün olsa da PHP için konuşacak olursak, built-in olarak PHP içinde bulunan password_hash()’in otomatik olarak rastgele bir salt yapısı atayıp kullandığını öğrendim. Ve gerek PHP manual’ında gerek farklı sitelerde de en çok tavsiye edilen şifreleme yöntemlerinden biri olduğu için bunu kullandım. Başta farklı hash yapılarını iç içe kullanırsam çok daha güvenli olur diye düşünmüştüm fakat bunun zararları olduğu söylenilmişti birkaç iyi kaynakta. Doğruyu söyleyeyim o zararları da okumuştum ama biraz havada kalmış. ",
        "27": "Günün bir kısmında ise MVC yapısını araştırayım dedim. Ama konu hakkındaki okuduklarım ve anlayabildiklerim tam oturmadığı için bu konuya sonra tekrar bakıp güzelce yazacağım.",
        "28": "Günün başka bir kısmında da PHP aracılığı ile ismini veritabanına, kendisini bir dosyaya kaydettiğim fotoğrafı, client’a göstermeye çalışmaktı. Bunu yapamadım. Biraz denedim olmadı fakat yine deneyeceğim. ",
        "29": "Tekrar teşekkür ederim, aslında hiç de ihtiyacınız olmasa da bugün bizimle aklımıza takılan konularda ilgilendiğiniz ve detaylı olarak konuştuğunuz için toplantı odasında.",
        "30": "48. Gün",
        "31": "Günün ilk kısmında tekrar hash metodlarına, ve veritabanına adı eklenen dosyanın nasıl client’a gösterileceğine bakmıştım. Bunları tamamladım. Sonrasında kendime bir görev vermek istedim. Kullanıcı bir ürünü seçip sepetine eklemek isterse, sepetteki ürünleri sepetim.html dosyası ile gösterip bir de toplam tutarı ve sepetteki ürünler üstüne işlemlerin nasıl yapılacağına bakacaktım. Biraz araştırdım ve konu hakkında çok güzel bir örnek buldum. Class-object yapısı içinde işlemlerin yapıldığı bir örnekti. Konsepti oturtup o örneği inceleyecekken yeni görev verildi. Sonrasında ne yapacağım üstüne bol bol düşündüm. Daha önceki ödevlerde yapmış olduğum header’ı çok beğenmediğim için tekrar düzenledim. Yine içime tam sinmedi fakat şimdilik yeterli diye düşünüyorum. Yarın content kısmına giriş yapıp html ve css kısımlarının ana konseptini çıkarabilmek istiyorum. Beğenmediğim kısımları tekrar düzenlerim böylece. Bir iskelet oluşturduktan sonra, ve tasarım iyi görünürse sonrasında javascript ile bir şeyler eklemeyi sonraki güne bırakacağım. Kısacası yarınki en büyük amacım, genel manada istediğim yapının iskeletini çıkarmak. Sonrasında o iskelet üstünde iyileştirmeler yapmak.",
        "32": "Genel olarak tasarımı nasıl yapacağımı ve farklı sitelerde nasıl yapıldığına bakarak geçti aslında bugün. Şeye çok şaşırdım. Dünyanın en büyük e-ticaret sitesi olan Amazon’un tasarımı belki iyi olabilir fakat içeriği aşırı karışık. Hem amazon.com hem de amazon.com.tr sanki artık pr, güvenilirlik ve tanınmışlıktan ekmek yiyor gibi geldi. Farklı sitelerde en beğendiğim tasarım açıkçası hepsiburada’nınki oldu. Fakat bazı yerlerde trendyol’un yaptıkları da güzeldi. Açıkçası genel kullanıcı kitlesine hitap etmek gerektiği bariz ortada. Sanatsal bir yaklaşımla mükemmeliyetçiliği yakalamaktan çok, kullanıcı nasıl rahatça “bizden alışveriş” yapacak ve hiç zorlanmayacak onu anlamalıyım aslında.",
        "33": "Bugünlük bu kadardı.",
        "34": "49. Gün",
        "35": "Bugün sadece iki tane karosel yapmaya çalıştım. Birincisi oldu çünkü o sadece yön okları, alt tarafında bulunan yer imleci tarzı noktalar ve tabii ki fotoğraflardan oluşuyordu. Bunu birkaç kez yaptığım için zorlanmadım. Ama ikincisinde farklı bir şey denemek istedim. Sürüklenebilir bir karosel hiç yapmamıştım ve bu sefer denedim. Yapabildim mi? Kısmen evet, ama hâlâ tam çalışmıyor. Süre kısıtı olduğu için şimdilik orayı bırakıp sayfanı geri kalan kısımları yapacağım.",
        "36": "Kısaca bugün yapılanlar: Birinci karosel ile güncel ve ilgi çekecek ürünleri, markaları, ya da listelemek istediklerimizi göstermek istedim. İkinci karosel ile  kullanıcıya indirimli ve popular ürünleri gösterebileceğimizi düşündüm. Ve son olarak da sadece markaların logolarının bulunduğu bir ‘div’ oluşturdum. Hiçbir geçiş ya da başka bir özelliği olmasa da en popular, en çok bize kazandıran, en trend olan veya kullanıcının en sık aradığı markaları listelemek istedim. ",
        "37": "Yarın ne yapılacak?",
        "38": "Kategori, fiyat, marka gibi filtre araçlarını ekleyeceğim. Sonrasında da tabii ki ürünlerimizi. Birçok şey öğrendiğimiz için ve Google devasa bir kaynak sağladığı için; nasıl bir tasarım olmalı sorusuna araştırdıkça farklı yanıtlar alıyorken, daha da aklımın karışmaması için basitçe bir şeyler tasarlamaya çalışacağım. En temel iskeleti oluşturduktan sonra üstüne eklemeler, düzeltmeler yapmaya çalışacağım. ",
        "39": "50. Gün",
        "40": "Bugün ürünleri filtrelemek için olan kısımların tasarımını tamamladım. Bazı yerlerdeki ufak sorunlar fazla zamanımı aldı fakat gün sonunda ortaya çıkan sonuçtan şahsi olarak memnun kaldım. Flex yapısını kullanmam gereken neredeyse her yerde kullandım. Bazı yerlerde ‘position’ attribute’ünü kullanmam gerekti. Ürünlerin gösterildiği “card”ların birinin iskeletini oluşturdum. Yarın onun üstünden ilerleyip görselin bütününü ve eksik olan her şeyi toparlamak istiyorum. Dün carousel’de çok uğraşıp tam istediğim sonucu alamamış olsam da bugünkü kısımlar daha kolay olduğu için daha çabuk bitti. ",
        "41": "Filtreleme kısmının tasarımında sadece bir yerde Javascript kullanıldı. O da çok karışık olduğu için açıkçası copy paste aldım. Fakat geri kalan hepsi kendi emeğim diyebilirim. Header kısmını tekrar yazmıştım ilk görev verildiği gün. Fakat footer kısmını eskiden yazdığım kod ile oluşturacağım. O kısımda gereksiz çok ayrıntı olabilir çünkü ilk CSS HTML örneklerimizdendi. Fırsat bulabilirsem orayı da düzelteceğim fakat önceliğim bizden asıl istenen kısım."
    },
    "part6": {
        "1": "51. Gün",
        "2": "CSS ve HTML konularında artık bir zorluk çektiğimi hissetmiyorum. Tasarımın nasıl olacağına dair düşünceler ve yapılabilecek şeylerin olasılığı çok fazla olduğu için neyin, nasıl ve nerede kullanılacağı zaman alıyor biraz. Sadece Javascript kullanılan yerlerde kodlamayı kullandığımız için elbette daha uğraştırıcı oluyor. Geçenlerde bir İranlının “a mystery is simple when its solved” gibi bir sözünü duymuştum. Gerçekten de öyleydi. Çözüme ulaşıldığı takdirde kolay görünse de, öncesinde zor olabiliyor. Javascript ya da herhangi bir dilde istenilen çözüme ulaşmak için bir problem çözme yeteneği gerekse de çözüldüğü zaman kolay olduğu anlaşılıyor.",
        "3": "Bugün HTML ve CSS tasarımları tamamen bitti verilen site tasarımı için. Font awesome yerine ufak icon görselleri kullanmıştım o kısımları düzelttim. Ürün Card’ları biraz düzelttim ve üzerlerinde bulunan efektleri düzenledim. Sıralama kısmını ve karosellerin hemen yanında bulunan resimli kısmı yaptım. Eksik ya da sorunlu kısımlar şunlar: Kodumdaki gereksiz ayrıntıları silip düzenlemedim bazı  yerlerde. Onlara tekrar bakmam gerekli. İkinci karoseldeki fotoğraflar birinci döngüden sonra çok hafif kalıyor görünen kısımda. Ve sıralama butonununda buton dışında bir yere tıklayınca içerik kayboluyor. Oysa ki butona ikinci kez tıklayınca da kaybolması gerekiyor. Onu da fırsat olursa düzelteceğim. Ama genel istenen tasarım yapısının tamamlandığını düşünüyorum.",
        "4": "52. Gün",
        "5": "Bugün SOLID kavramını  araştırdım, öğrenmeye çalıştım. 5 tane prensibimiz var bir class-obje yapısının solid  olabilmesi için. Güzel bir örnek bulup onun üstünden anlamaya çalıştım bu yapıyı. Öncelikle referans olarak en anlaşılır bulduğum kaynak buydu:",
        "6": "Solid Principles- The first five principles of object oriented design",
        "7": "Amacımızın bazı şekillerin alanını bulmak olduğunu farz edelim. Normalde bunu hiçbir prensip kullanmayarak da yapmak mümkün olsa da bizim konumuz SOLID yapısını kullanmak olduğu için ona uygun şekilde tasarlayacağız kodumuzu. Şekillerimizin birinin kare, diğerinin de daire olduğunu düşünelim. Alanlarını bulmak için bilmemiz gereken şeyler kenar uzunluğu ve dairenin yarıçapı her ikisi için ayrı olarak. Biz de bunlar için iki sınıf oluşturabiliriz. Ve alanları hesaplamak için de ayrı bir sınıf oluşturup yine bu sınıfta çıktısını üretebiliriz öyle değil mi? Ama bir sorun var. Eğer  bizim çıktımızın JSON formatında olmasını istersek yine hesaplama yaptığımız sınıfta bunu yapmamız gerekecek çünkü çıktımızı o sınıf sağlıyor. Oysa SOLID prensiplerinden birincisine bu durum aykırı. Çünkü birinci prensip diyor ki “bir sınıf sadece tek bir amaca hizmet etmeli ya da sadece tek bir görevi olmalı bir işi yapabilmek için”. Dolayısıyla hesaplamaların yapıldığı sınıftan farklı olarak çıktının ister JSON formatında ister HTML formatında üretildiği bir başka sınıf yaparsak birinci prensibi sağlamış oluruz.",
        "8": "Sonuç olarak, şekiller girilir. Sonrasında alanlar hesaplanıp toplanır ve çıktıları alınır. Tüm işlemler farklı class’lar ile gerçekleştirilir. Her sınıf ya da modül farklı bir göreve sahip olur bu şekilde. ",
        "9": "İkinci prensibimiz ise “Open-Closed Principle”.  Bu prensip der ki “bir sınıf genişletilebilir fakat sınıfın kendisi değiştirilmez”. Az önceki örneğimizden devam edelim. Diyelim ki kullanıcı alan hesaplamalarının yapıldığı sınıfa farklı şekiller, yani farklı hesaplamaları gerektiren veriler girdi. Bizim burda normalde yaptığımız şey yeni if/else statement’ları açarak o sınıfta değişiklikler yapmaktı. Ama ikinci prensip diyor ki, sen her yeni değişikliği bu sınıfta oluşturma. Sınıfın içeriğini değiştirme. Ve bu matematiksel işlemleri, şekillerin bulunduğu sınıflarda method olarak yap. Bunu yaptıktan sonra ise karşımıza şöyle bir problem çıkıyor. Hesaplama yaptığımız sınıfta, kullanacağımız şekil sınıfından gelecek olan method’un varlığını nasıl bilebiliriz?  İşte burada interface kavramını kullanmamız gerekmektedir. Şekillerin bulunduğu sınıfta yapacağımız alan hesaplamanın bulunduğu method’u bir interface aracılığı ile deriz ki “bu şekil sınıfı, bu interface’i implement etmekte yani uygulamaktadır”.  Bu sayede şekil sınıflarımızın interface’ımızın instance’I olup olmadığını check edebiliriz ve eğer o uygulamıyorsa o interface’I hata mesajı vermesini sağlayabiliriz.",
        "10": "Üçüncü prensibimiz ise “Liskov Substitution Principle”.  Der ki “ her alt class veya türetilmiş class, parent class’I için değiştirilebilir olmalı”.  Ufak bir özet ve sonrasında devam edelim:",
        "11": "Şimdiye kadar ne yaptık? Şekillerin alanını bulmak istiyorduk. Her şekil için ayrı bir sınıf açtık. Sınıflarda şekillerin property’leri ve method’u vardı. Alan hesaplamak için gerekli property ve alanlarının hesaplanması için gerekli matematiksel denklemlerin olduğu fonksiyonlar. Alanları farklı bir sınıfta hesapladık bu denklemler ile ve kullanıcın girmiş olduğu sınıfta öyle bir method var mı yok mu sorgusunu normalde yapamayacağımız için interface kullandık. Dedik ki her şekil o interface’i implement etsin, yani uygulasın/kullansın. Sonrasında da farklı bir sınıfta çıktılarımız üretilsin. Bu sayede ilk iki prensibi sağlamış olduk. ",
        "12": "Diyelim ki şimdi hacim hesaplaması yapacağız.  Ve bunun için de alan hesaplaması yaptığımız class’ı extend ettiğimizi düşünelim. Sonuçta biliyoruz ki hacim hesabı için alan da gerekmektedir.  Fakat bu hesaplamayı yaptıktan sonra oluşan çıktımızda “error: array to string conversion”  gibi bir hata ile karşılaşabiliriz. İşte burada son oluşturduğumuz sınıfta bir değişim yaparak bu hata mesajından kurtulabilir ve çıktımızı dizi yerine  bir integer değer olarak alabiliriz. Bu yaptığımız değişim Liskov’un değişim prensibine örnek olarak verilebilir (Açıkçası vermişler, ben onu söylüyorum şu anlık. Çünkü farklı farklı kaynaklardan bunu teyit edebileceğim araştırma henüz yapamadım).",
        "13": "Dördüncü prensibimiz ise “Interface Segregation Principle”.  Bu prensip der ki “ client, kullanmayacağı method’lara maruz kalmamalı ya da kendisiyle alakası olmayan ve kullanmadığı arayüz implement edilmemeli”.  Daha önce oluşturduğumuz arayüzde  sadece 2 boyutlu şekiller için alan hesaplaması vardı. Diyelim ki 3 boyutlu cisimler/şekiller için de hacmi hesaplayacağız.  Ama kare gibi şekillerin hacmi yok, yani bu interface’I açıkça dayatmak zorunda kalacağız 2 boyutlu şekillerin sınıflarına da. İşte burada arayüz ayrımı prensibi devreye giriyor.  Yani 3 boyutlu cisimlerin hacmini hesaplamak için ayrı bir arayüz oluşturalım. Bu sayede tek bir arayüzde hem hacim hem alan hesaplaması yapmaya çalışırken, alanı olmayan şekillere de aynı arayüzü dayatmayalım. Çünkü onlar da o arayüzde bulunan hacim hesaplama metodu bulunamaz. Bunun üstüne bir geliştirme daha yapılabiliyor. İki ayrı arayüzü tek bir arayüzde birleştirme ya da yönetme işlemi uygulanıyor. Yani tek bir API kullanıyoruz gibi düşünebiliriz. Örneğin bu arayüzde bir hesapla fonksiyonu olursa, hem alan hesabını hem de hacim hesabını bu fonksiyon üstünden yönetebiliriz. ",
        "14": "Beşinci prensip ise “Dependency Inversion Principle”. Bu prensip der ki, “class, module gibi kodumuzda bulunan ‘varlıklar’ somutlamanın aksine soyutlanmak zorundadır.” Bu da şu manaya gelir: High level module’ler, low level module’lere bağlı olmak zorunda değildir ve sen bunları birbirinden soyutlamalısın.  Sebebine gelelim:",
        "15": "Bir sınıfımız olsun şifre hatırlayıcı diye, ve bu sınıf veritabanına farklı bir sınıf aracılığı ile bağlansın. Veritabanı ile bağlantı oluşturulan sınıf low level, şifre hatırlamak için oluşturulan sınıf high level diye geçer.  Böyle adlandırılmalarının sebebi ise: Bir tool ile execution’ın yapıldığı sınıf high level, execution’ın yapılabilmesi için var olan tool ise low level olarak geçmektedir. Devam edelim. Veritabanımızın MYSQL sunucusu olduğunu ve bağlantının MYSQL’e yapıldığını düşünelim.  Eğer biz bir gün veritabanı motorunu(engine) değiştirmek istersek, Bunun için ayrıca şifre hatırlama sınıfında da değişiklik yapmak zorunda kalacağız.  Bu da “open-closed” yapıya ters düşecektir.  Amaç şu: high level sınıf, low level’e olabildiğince az bağlı yani soyutlanmış olmalı. Örneğimizde low level sunucunun mysql’e bağlanması ya da başka bir veritabanı motoruna bağlanması high level sınıfı etkilememelidir. Bunun için de yine arayüz kullanılır. Arayüzü MYSQL bağlantısı oluşturacağımız sınıf implement eder. Bu şekilde de high level sınıfta kullanabiliriz. Bu sayede high level ve low level sınıflar biribirinden soyutlanır.",
        "16": "Zaman olursa çok daha iyi araştırıp anlamaya çalışacağım. ",
        "17": "Not",
        "18": "Dün yazdığım raporda SOLID yapısı hakkında detaylı bir örnekle açıklamalarda bulunmaya çalışmıştım. Yeterli olduğunu düşünmekle birlikte tekrar bir özet geçtikten sonra kendimce bir örnekleme girişiminde bulunacağım. Benzetme başarısız olabilir ama üstünde düşünmek keyifli olur diye bu şekilde düşündüm. Önce özetleyelim SOLID'i:",
        "19": "SOLID yapısı OOP için kullanılsa da functional programming'e de uyarlanabiliyor kısmen. Evet bu yapıyı obje-class yapılarımız için düşüneceğiz ama bunun da REST API kavramı gibi \"inanç,felsefe, kavramsal tasarım, optimize sonuçlar için oluşturulan kurgusal tasarım modelleri, design pattern, mimari\" nasıl adlandırırsak adlandıralım bunun kodumuzu yazarken dikkat etmemiz gereken bir fikirler bütünü olarak ele almamızda fayda var.",
        "20": "İlk prensip her modülün tek bir işi olması gerektiğini ve bu işte iyi olması gerektiğini söyler.  Modüllerin farklı farklı amaçlar ya da rollere bürünmesi değil tek bir işi olmasını öğütler. \"Make the best thing you can\" gibi.  Demet Akalın'ın işi şarkı söylemekse mesela, bu objeyi(class'ı ya da modülü veya genel anlamda entity'yi), yani Demet Akalın'ı Tokyo Olimpiyatlarında Türkiye'yi kurbağalama 200 metre için temsil etmesini ve yarışmasını istemek abesle iştigal olur. Yani onun işi bir tane olmalı. Onu en iyi yapmalı.",
        "21": "İkinci prensip diyor ki modüllerimiz değiştirilmemeli sürekli, ama genişletilebilmeli.  Bunu yapmanın bir nedeni şu: Yazılan class'ın yazarına bağlı kalmamak. Ya da başka bir açıdan eğer bizim bir kodumuz varsa ve bunu 3. parti olarak dışarıdaki kullanıcıya açtıysak, kullanıcının class'ımızda bir değişiklik yapmamasını isteriz. Sadece istediğimiz alanlara erişsin, izin verdiğimiz ölçüde kendince oynasın, bir şeyleri genişletebilsin diye.  Burada yine Demet Akalın'ı devreye sokabiliriz. Şimdi biz dedik ki bu kadın, bu obje, bu varlık sadece şarkı söylemeli. Olimpiyatlarda yüzmeye gitmesi gerekenler bu konunun ehli sporcular. Şimdi diyoruz ki  Demet Akalın başka şeyler de yapsın. Ama şimdi bunun kodlama ile bağlantısını nasıl kurabiliriz onu düşünelim. Normalde Open-closed prensibinde Demet Akalın class'ından farklı olarak başka class'ları da düşünelim. Mesela yüzücümüzü örnek verebiliriz. İkisinin de farklı method'ları meşgaleleri var. Ben bu ikisini de bir restaurant'a koydum diyelim. İkisi de yemek yiyecek. Ve onların property'lerinde (default olarak) yemek yeme, bir şeyler içme özellikleri de var.  Bu insanların yemek yeme hızlarını, biçimlerini, yemek yerken konuşmalarını, garsona tavırlarının hepsi ayrı bir method aslında. Ve bizde bu methodların toplandığı farklı bir class oluşturabiliriz. Yani davranışlarının olduğu bir class olabilir bu. Yani bu class'ımızın ismi de amel defteri olsun. Burda herkesin amel defterinde işlemler yapılıp ayrı ayrı sonuçlar elde ediliyor olsun ve hepsi toplanıp bir yere kaydedilsin.  Şimdi her işlem öncelikle birinci prensip gereği farklı class'larda olmalı ki SOLID'e uysun. Bizim bu amel defterinde matematiksel işlemlerimizi yaptığımız yerde sadece veriler gelip çıktıları sayısal olarak ya da bir array içinde tutarak döndürmemiz gerekiyor. Ama Demet Akalın, Snopp Dogg, Ricky Martin, Hz.  İsa, Buğra, Ömer Hayyam gibi insanların hesaplamaları için kullanılan hesap yöntemleri farklı. Evet Hepsinin adı hesaplama fakat hepsi farklı şekilde hesaplanıyor. O yüzden biz bu class'ta sadece ilgili class'lardan gelen metodları kullanıp hesaplamamzıı yapıyoruz. Demet Akalın'ı değerlendirildiği ilahi formüller farklı, yüzücününki farklı oluyor. Peki, bir sorun var mı? Şimdi biliyoruz ki doğmamış bebekler direkt cennete gidiyor konusu var buna örnek olarak verilebilecek. Yani onların bir methodu yok diyebiliriz. Direkt geçiş hakkına sahipler işlemsiz.  Ama bizim bu hesaplama class'ında doğmamış bebek, şehit veya başka birçok dinlerde olan \"iyi insan\"ı nasıl hesaplamaya dahil edeceğiz. Methodları yoksa ve  hesaplanmaya çalışılırsa fatal error alabiliriz. İşte o yüzden diyoruz ki biz her insanın kullandığı bazı aynı arayüzler vardır. Hepsi yemek yer, hepsi uyur, hepsi doğar ve ölür, hepsi yalan söyler ya da ağlar(En azından bir kere) diye. Biz bunların hepsini bir arayüzde toplayabiliriz. Ama bu arayüzdeki method'ların hepsine uygun olması gerekir. O arayüzdeki bir metodu kullanmayan bir insan, direkt fatal error'la sistemi sonlandırır.  Sonuç olarak çok uzatsam da şuraya gelmeliyim: hesapların yapıldığı class'ta her metodun uygulanışını farklı farklı defalarca kez tanımlamakla uğraşıp, defalarca kez değiştirmek ve sisteme kötü sonuçlar doğurabilecek hatalar verdirmek yerine hepsini bir arayüz kullanarak yapmak ve bu işlemi ayırmak çok daha iyidir bizim için.",
        "22": "Liskov üçüncü prensibinde özetle şunu söyler: Eğer bir şey, diğer şey ile aynı şekilde davranıyorsa, sen bunu değiştirebilmelisin. Obje class yapısında daha çok inheritance mantığında buna şöyle bakılır: Parent'ın bir özelliğini bir çocuk alır. Ve bunu değiştirebilir kendince. Mesela Demet Akalın'ın babası çok fena bir alkolik olabilir fakat Demet Akalın sadece her akşam bir bardak viski içiyor olabilir. Genetik ya da öğrenilmiş/davranışsal mirasın hepsini sürdürmek zorunda değildir. Ama her zaman onun izlerini taşımak zorundadır. Demet Akalın bir gün yabancı ülkelere gidip oralarda yaşamak istese ve bundan çok mutlu olacağını düşünse de, kendinden kaçamayacağını bilmelidir. Geçmişinden, öğretilenlerden.  Ama ufak değişiklikleri elbette yapabilir.",
        "23": "Dördüncü prensibin özeti ise, client'a istediğini ver. Yani ona kullanmayacağı arayüzü sunma  ya da onu zorlama gereksiz şeylerle. Demet Akalın'a geri dönelim. Demet Akalın konserde şakı söylüyorsa eğer psikoloğunda anlattığı problemlerini konserde anlatmamalı. Eğer çok hisli ya da dertli ise bunun üstüne şarkı yazıp client'a yani hayranlarına duygularına aktarabilir ama onlara istemediği şeyleri vermemeli. ",
        "24": "Beşinci prensibimizde ise high level ve low level entity'ler arasındaki bağda soyutlamayı kullanmalısın. High level entity(modül, sınıf, obje, ne derseniz), işlemlerini yapmak için low level entity'leri kullanır. Ve low level entity'i biraz soyutlamamız gerekir high level'den. Bu sayede low level'deki bir değişimde high level entity'imizde bir değişim yapmamıza gerek kalmaz. Tabii ki bu yapı için de interface kullanılabilir. Gördüğüm örneklerde en azından o şekilde kullanılmış soyutlamak için. Diyelim ki Demet Akalın'ın sevgilisi var. Ve ona çok bağımlı, düşkün, onsuz yaşayamam diyerek gizli gizli \"Join me in death\" dinliyor hâlâ. İşte bu çok hatalı. Yani sen Demet Akalın'sın. O senden ayrılırsa çok üzülür kendini değiştirmek zorunda kalırsın onu tekrar elde edebilmek için. Ama prensibimiz diyor ki, \"Demet ilişikide değer görmek istiyorsan çok değer vermiceksin.\"Onu da diğer erkeklerden bir farkının olmadığını düşün. Biri gelir biri gider gibi düşünüp ahlaksız ol(neye göre kime göre). Bu sayede kimle sevgili olsan yıpranmazsın. Hemen alışır kabul edersin.\".",
        "25": "Entity olarak Demet Akalın'ı seçmek hiç aklımda yoktu ve büyük ihtimal çok kötü bir fikirdi ama yine de denemek istedim. Normalde obje/class olarak galaksileri alıp, kodumuzu evren olarak düşünmek istemiştim ama konu nerden Demet Akalın'a geldi ben de anlamadım.",
        "26": "Örneklem, dün  baktığım siteden öğrendiklerimle konu ile bağlantılı olarak oluşturulmaya çalışıldı daha çok.",
        "27": "53. Gün",
        "28": "Bugün SOLID ve OOP prensiplerini iyice kavramaya çalıştım. SOLID mimarisini kendimce örnekledim. SOLID için hem dün hem de gün içinde anladıklarımı ve örnekler üstünden anlatmaya çalıştığım için, Bu rapor biraz daha aklımda kalan farklı şeylerle alakalı oldu.  Bütün bunları en özetinde neden kullanıyoruz? Kodumuzu parçalıyoruz aslında. Her görev için farklı bir obje yapısı oluşturuyoruz. İleriki aşamalarda kodumuzun belirli bir kısmında değişiklik yapmak istediğimizde systemin tamamına zarar vermeyecek ya da etkilemesini engellemek ve çok daha iyi bir şekilde düzeltme işlemini yapabilmek için SOLID yapısını kullanıyoruz. Bu tabii ki SOLID’in tüm maddeleri için geçerli. Clean code, agile gibi kavramlarda bu mimari felsefeyle beraber işlemektedir. SOLID yapısını kullanınca ister istemez çok daha clean bir kod yapısına sahip oluyoruz. ",
        "29": "Bu kod üstündeki sonrasında yapılacak değiştirilme hâli “maintenance ve extending” olarak düşünülebilir. Veritabanı motorunda bir değişim yaparsak eğer, arayüz kullanarak bu değişimden etkilenecek olan high level bir module kolayca adapte olabilir yeni sistemimize soyutlamayı kullanarak örneğin.",
        "30": "Peki biz SOLID mimarisini anlamaya çalıştık ve pratik yapmadan okuyarak ne kadar anlaşılabiliyorsa anladığımızı düşünüyorum. SOLID’ e bugün çalışırken biraz OOP kavramlarını araştırdım çünkü biz neden OOP üstüne bir tasarım gerçekleştirmeliyiz bunu da anlamam gerekiyordu. Aslında basitti. OOP’nin sağladığı en güzel sonuç onun yapısındaki Encapsulation ilkesi ile ilgili. Kodumuzun bir yerinde hata oluştuğunda normalde OOP kullanmayacak olsaydık nerede hata olduğunu  bulmak çok daha zor olurdu fakat belirli bir objede bir sorun varsa diyebiliyoruz ki demek ki onun bulunduğu sınıftan kaynaklanan bir sorun olmalı. Araba objem bozuksa eğer, araba class’ımda bir sorun var diyerek sorunun kaynağını çözümleyebilirim. Kodun tekrar kullanılabilirliği konusunda, Araba class’ımızda birçok farklı aracı ve özelliklerini child class olarak ekleyebiliriz. Base class ta yapılan değişiklik ile hepsinde bir değişim yaratabilir, ya da her araba objesi için ayrı method’lar yaratıp onlara özel yapabiliriz.  Üstelik tek bir “sür” fonksiyonu ile tüm araba objeleri için(child class’lardan oluşacak instance’lar olarak yani) bir method belirleyebiliriz. Ya da bunu interface olarak yaratıp her class bu interface’I implement ediyor diyebiliriz. Bize obje/class yapısının vermiş olduğu en iyi yarar, çok daha verimli bir şekilde problemleri çözme yeteneği sağlamasıdır diyebiliriz (top-down language-C gibi-, functional style language-Haskell veya ML gibi-  mimarilere göre).  Son kez 1 cümlede toplayacak olursak faydalarını: kolay bir şekilde sorunları gidermek için modular yapı kullanması (yapboz gibi her parçanın yeri belli bu modular yapıda), inheritance ile kodun tekrar kullanılabilirliğinin sağlanması, polymorphism ile flexibility’nin sağlanması, ve tabii ki vermiş olduğu vermeli problem çözme yetisi.",
        "31": "54. Gün",
        "32": "Öncelikle bu akşam eve döndüğümde uyuyakalmışım, sonrasında çalışacaktım oysa ki. Gelelim ne yaptığıma dün. SOLID’I okurken güzeldi, çoğunluk olarak anladığımı düşünüyordum ama iş pratiğe gelince istenen şekilde yapamadım. En azından denedim diyorum. Yine bir gizem çözülünce kolay göründü tabii. Aslında inheritance yapısını oluştursam benim kodum da neredeyse olacakmış fakat benim aklıma hiç gelmedi ineritance I o şekilde oluşturmayı düşünmek. Çünkü eğer bir fonksiyonn varsa parent ta ve child bunu değiştirip kullanmıyorsa ne gerek var ki bu akrabalığa diyordum fakat anladım ki hem değiştirip hem de parent’taki haliyle de kullanabiliyormuş.",
        "33": "55. Gün",
        "34": "Bugün Depenedency Injection kavramını net olarak öğrendim. Bu bir design pattern, bir teknikmiş. Design pattern’lerde anladığım kadarıyla net bir kural yok. Her durum için farklıbir şekilde oluşturulabiliyorlar. Mesela Dependency Injection'ı kullanmak için, bağımlılığı bulunan class’ımıza, farklı bir class’tan obje alırken contructor ya da seeter method’larında parametre olarak alıyoruz. Bu konuda şu anlık bir sorunum yok gibi.",
        "35": "XML ile alakalı işlemlerde hep benzer yerlerde sorunlar yaşıyordum ama hala kendimi sorun çözmede yetersiz hissediyorum. Yani önceleri çok daha fazla sorunla karşılaşırken şu an basit gibi görünen bir şeyi neden bu kadar bol zamanda yapamadım ben de anlamadım. Büyük ihtimal aynı hataları alıp, aynı işlemleri tekrar ediyorum. Yani kendimi tekrar ediyorum. Günün sonuna doğru yanlışlıklarımı biraz tamamladım. Gün sonunda da hatanın tam olarak nereden kaynaklandığını buldum. Ama yarına kaldı artık. asXML() bize bir string döndürüyor evet fakat XML formatında döndürüyor. Oysa ki başlangıç taglarını tekrar bizim yazmaya ihtiyacımız yok. Oysa ki ben de yazıyordu. Yarın sabah asXML() kullanmadan nasıl objeyi string’e dönüştürebilirim (XML ile alakalı fonksiyonlarda başka bir seçenek var mı ona da bakacağım) ona bakacağım.",
        "36": "Bazı konularda sebep-sonuç ilişkisini ve yine bazı konularda çok şeyi merak ettiğim için gelişimime katkı sunduğu için sevinsem de 2 ay olmasına rağmen hâlâ daha kodda aldığım hatayı düzeltebilmek için uzun zamana ihtiyaç duyma ihtiyacımın olması ya da olma ihtimali(basit olduğunu hissettiğim yerlerde) üzüyor. Ama bir yandan da daha da merak ettirip hırslandırıyor. Her şey çok karışık bu düşüncelerimizin dünyasında. Neyse bu konulara girmeyelim. İstediğim gibi olacağıma dair inancımı hiç bozmayaraktan.",
        "37": "56. Gün",
        "38": "Bugün öğrendiğim ve pratikte gördüğüm konular genel olarak OOP ile  alakalı konulardı. Trait’in kullanımı, class’ların eğer aynı isimde olurlarsa farklı namespace’ler ile o dosyaların tutulması gerekliliği yoksa birbirlerini etkilemeleri gibi yeni şeyler öğrendim. Sabah dün yaptığımız görevi tamamladım. Öğleden sonraki görevi açıkçası tam anlamamıştım ve anladığım kadarıyla yapmaya çalıştım. Biraz  kesin kuralları olmadığı için genel olarak her yerde fonksiyon kullanmıştım. Bugün genel olarak araştırmalarla dolu geçti. SOLID prensiplerinin örneklerini tekrar inceledim farklı kaynaklardan. Bir tekrar niteliğinde gibiydi.",
        "39": "57. Gün",
        "40": "Dün raporu unuttuğum için bugün gönderiyorum. Dün sadece clean code ile alakalı güzel bir dokümanı inceledim. Her ayrıntıyı öğrenmeye çalıştım. Okurken ve incelerken neredeyse her şeyin sebebini anlayabiliyordum, gerçekten iyi yazılmış bir kod ve kötü yazılmış bir kodun farkını kavrayabiliyordum. Bu iş(yazılım), dedikleri gibi okuma yazma öğrenmek gibi. Her okuma yazmayı bilen insan iyi bir edebiyatçı olmuyor. Cümleleri iyi kuramıyor ya da imla kurallarına dahi uymayabiliyor. Evet ben de hem php hem de javascript ile okuma yazmayı biraz öğrendiğimi düşünüyorum. Fakat bu işin cümle kurmalarını, uzun yazılar, hikayeler, romanlar yazmayı çok istiyorum. Bunu da yapabileceğime inanıyorum kesinlikle. Sadece bol bol prtaik yapmam gerekecek. Aklıma çok takılan bir sorun olmadı Cumartesi günü. O yüzden o tür bir şey belirtemiyorum. Competitive programming diye bir şeyi keşfettim. Ve o açıdan da harika kaynaklar buldum. Boş zamanlarımda kodlama becerilerimi, düşünce yapımı, makine ile en iyi anlaşabileceğim seviyeye getirmek için o konulara bakacağım. O kısım, işte bize verilen görevlerle çok alakalı olmadığı için mesai saatleri dışında bakacağım.",
        "41": "58. Gün",
        "42": "Bugün, verilen görevle geçti tamamen. Tasarım neredeyse aynısı oldu.",
        "43": "JavaScript kısmında yardımcı oldu. Henüz bitmesine var çünkü başta çok kolay gibi görünse de detayları biraz uğraştırdı. Genel olarak istenen yapı oluşuyor fakat günün sonlarına doğru bazı yerlerde javascript kodunun bazı kısımlarını tam oluşturamadığım için(ya da gözümden kaçan kısımlar olduğu için) istenilmeyecek sonuçlar oldu. Defalarca aynı hatayı yapıp durmaktansa (Ve aklıma farklı bir çözüm yolu henüz gelmediği için) yarın sabah tekrar bakmak daha faydalı olacaktır diye düşündüm. Ve dinlenmek istedim. Bugünlük bu kadardı.",
        "44": "59. Gün",
        "45": "Bugün ameleliğin keşfini yeniden yaşamış olabilirim. Gerçekten bugün ne yapılmaması gerektiğini yaşayarak öğrendim. Html içine javascript karıştırmadan çok daha rahatça yapmak istediklerimi yapabilirdim. Yapabilirmişim. Aslında o konulara daha önceden bakmıştık ama bu işime gelir diye düşünerekten onclick’li yapıyı (inline event handler olarak adlandırılan yapıyı) kullanmıştım. Bundan sonrasında kaçınacağım bir konu olacak. Onun haricinde ben tasarımın olduğunu düşünüyorum. Dediğim gibi, gün biraz fazla ayrıntıyla uğraşmakla geçti. Ama yine de eğlenceliydi, ortaya çıkan sonucu görmek bile yeterliydi tatmin olmak için. ",
        "46": "60. Gün",
        "47": "Bugün yaptığım işten oldukça keyif aldım. Ne kadar doğru yaptım, ne kadar daha iyi yapabilirdim açıkçası çok bilmiyorum ama foreach’leri kullanarak yapmam gerekenlerin çoğunluğunu oluşturdum. Sabah da javasctip kodundaki eksiklikleri tamamladım. 2-3 günde upuzun kodlar yazdığımızı farkettim (HTML ve CSS sayesinde kabardı tabii ki). İlk sizin bilgisayarınızda yle uzun kodlar görünce çok hayret etmiştim, bu kadar uzun kod yazılsa da nasıl okunuyor diye. Şimdi en azından HTML ve CSS de olsa neredeyse hepsi, gayet yazılabilir ve okunabilir şeyler olabiliyormuş (En azından kendi yaptıklarımız)."
    },
    "part7": {
        "1": "61. Gün",
        "2": "Bugün sizin bize yorumlamamız için gönderdiğiniz javascript kodlarını hayranlıkla okudum. O kadar iyi düşünülmüş ki ben 5 gün düşünsem yine de yapamazdım gibi geldi. 2 ayda okur yazarlık edinildi fakat iyi bir yazar,edebiyatçı,şair olmak için çok uzun bir yol var bugün yine anladım. İngilizce için söylenen “anlıyorum ama konuşamıyorum” ifadesini çok iyi hissettim bugün. Evet yazılan kodun amacını, kullanılan terimlerin anlamını biliyorum ya da kısa bir araştırmayla hemen bulabiliyorum ama iş yapmaya gelince kıvrak ve zeki bir yaklaşımı hâlâ sergileyemiyorum. Biraz da tecrübe ile gelişir diye umuyorum. Çok inanıyorum olacağına, çünkü çok seviyorum. Çok fazla umut, inanç,sevgi gibi pozitif içerikli kelimeler kullandım sanırım. Sebebi ise mesai bitiminde DOM ve event handlers konusuna tekrar bakarken dinlediğim Daft Punk şarkısı sanırım. ",
        "3": "Günü o şarkı sözü ile bitirmek istiyorum:",
        "4": "“Work it harder, make it better",
        "5": "Do it faster, makes us stronger",
        "6": "More than ever, hour after hour",
        "7": "Work is never over”",
        "8": "62. Gün",
        "9": "Günün başlangıcında satranç oyununun OOP yöntemi ile nasıl yazılacağı üstüne bir kaynak buldum. Java kullanarak yazılmış kodu PHP’ye döndürüp, sonrasında HTML ve CSS kullanarak bunu bir web sayfasında göstermek istedim. OOP için pratik olur diye düşündüm fakat uzun sürecek gibiydi ve boş durmamak için onunla uğraştım. Sonrasında sizin gönderdiğiniz kodu inceledim. Kullanılan yapıları anlamaya çalıştım. Neden ve nerede kullanılabileceği üstünde çok düşündüm. Aklıma çok bir şey gelmedi amacı konusunda ama en azından kodu okudum. Yorumlamaya çalıştım. Tüm gün bununla geçti diyebilirim. ArrayObject yapısı ile ilk kez karşılaştım(karşılaşmışım daha önce ama onun ne demek olduğunu bilmiyormuşum) ve direkt dokümandan anlamaya çalıştım. Bu kodu anlamak ya da anlamaya çalışmak zorladı. Ve zorlanmadan da gelişim olmayacağı için çabaladım elimden geldiğince. Bugünlük bu kadardı.",
        "10": "63. Gün",
        "11": "Dün sadece inheritance, abstract class , ve interface konularını tekrar ettim. Oturmayan yerler kaldıysa oturtmaya çalıştım. Teorik olarak oturmayan bir yer keşfedemedim, üstüne bir şeyler katmaya çalıştım. Bol bol okumalar yaptım üstüne. Interface, senin ürettiğin sistemde başka developer’lar çalışacağı zaman üretecekleri class’larda bulundurmaları zorunlu metotları tanımlamak için var. Abstract class ise senin sisteminde çalışacak developer’lara birtakım abstract method’ları kullandırtmak ve childs class’larını üretirlerken bazı base method’ları onlara sağlamak için kullanılır, kullanılmalıdır. İkisinin de artıları ve eksileri bulunmaktadır. Nasıl bir yapı kurulacağına göre tercih edilme sebepleri de değişkenlik gösterecektir. Kesinlikle interface ya da kesinlikle abstract kullanmalısın gibi bir durum söz konusu değil. Projeye, systemin gerekliliklerine göre değişebilir. Bildiğimiz gibi interface’I implement edecek her class, interface’de bulunan her method’u kullanmak zorundadır. Birden fazla kez class’lar tarafından implement edilebilirler. Tamamen farklı ve alakasız sınıflar tarafından da kullanılabilirler. Inheritance bu işin neresinde peki denilirse cevap şu olabilir: Interface yapısı sadece fonksiyonel bir inheritance sağlar. ",
        "12": "Inheritance konusunda çokça duyduğum bir bakış açısı var:",
        "13": "Abstract class  bir “is a” ilişkisini concrete class’lar ile kurar. Bu sadece abstract class için değil aynı zamanda herhangi bir “base class-child class” ilişkisi için de geçerlidir. Interface ise “has a” capability’sini(yeteneğini) class’lar için sağlar.",
        "14": "Interface kısaca bir contract, bir sözleşmedir.  Interface’I yazan kişi der ki, “Dostum, ben şey’leri bu şekilde kabul ederim”. Kullanan kişi de der ki, “Tamamdır, yazacağım class’lar bu şekilde olacak size temin ederim”. Yani arayüz boş bir kabuk gibidir. Sadece method’ların ne olacağını belirtir. İçi dolu değildir. Kendi başlarına bir şey yapamazlar. Onlar sadece bir pattern’dir.  Interface’ler çok az CPU tüketirler. Çünkü onlar bir class değildir.  Bunun önem kazandığı noktada, gömülü yazılım gibi konularda dikkate alınabilirler bu açıdan.",
        "15": "Abstract class’lar ise interface’in aksine bir class’tır. Interface lere benzemektedirler elbette ama birkaç fark bulunmaktadır. Örneğin Onlara bir davranış tanımlayabilirsin. Yani method’ların içi dolu olabilir ya da içinde değişken-property tanımlaman mümkün. Abstract class’ta daha çok “Bu class’lar şu şekilde görünmeli, ve onların ortak yanları da olabilir. Ayrıca aynı yöntemi farklı şekilde kullanabilirler. Ben sana kullanacakları yöntemi söyleyeyim. Onu sen istediğin şekilde doldur.” düşüncesi hâkimdir.",
        "16": "64. Gün",
        "17": "Bugün tekrar niteliğindeydi. Daha önce görmüş olduğumuz konulara tekrar baktım. Nesneler arası ilişkileri tekrar ettim. Abstaction kavramını, polymorphism’I, inheritance’I ve OOP ile alakalı diğer bir birçok konuyu. OOP tarafında bugün baktığım konularda eksik olduğum noktaları size ve google’a sordum. Aklımda kalan sorulara cevap bulabildim. Daha ayrıntılı olarak ne anladığımı yarın genel manada yazacağım. Gün içinde anladığım ve anlamadığım birçok ayrıntıyı not aldım. Yarın design patterns konularına kaldığım yerden devam edeceğim. ",
        "18": "65. Gün",
        "19": "Bugün ve dün aldığım notların bir kısmını bugün raporuma eklemek istiyorum. Özet niteliğinde yazmak istediklerim:",
        "20": "OOP’yi kullanma amaçlarından bazıları: Karmaşıklığı azalt, bakım maliyetini düşür, modülariteyi arttır, nesneler arası hiyerarşiyi kur.",
        "21": "OOP dört temel ilke üzerine kurulu: Encapsulation, abstraction, inheritance, polymorphism.",
        "22": "Nesneler arası ilişkiler: Inheritance, implementation, association, dependency, composition, aggregation.  Bu yapıların basitçe kodlanması:",
        "23": "Inheritance: is+a (A is a B),",
        "24": "Implementation: should + do (A should do B),",
        "25": "Dependency: references (A references B),",
        "26": "Composition: has + a, wholepart, ownership,",
        "27": "Aggregation: has + a, wholepart.",
        "28": "Dependency",
        "29": "Bir sınıfın tanımında yapılan değişiklikler, başka bir sınıfta değişiklilklere neden oluyorsa iki sınıf arasında bir bağımlılık vardır. SOLID’ de buna dependency injection konusunda yer verilir.",
        "30": "Hem aggregation hem de composition için bir örnek",
        "31": "Bir üniversite çeşitli departmanlara sahiptir. Her departmanda farklı profesörler bulunur. Eğer üniversite kapanırsa departmanlarda kapanır. Ama profesörler varolmaya devam ederler. Bu yüzden, üniversite, departmanların composition’I olarak görülebilir. Oysa ki departmanlar, profesörlerin aggregation’ına sahiptir. Ek olarak, professor birden fazla departmanda çalışabilir. Ama departman birden fazla üniversitenin parçası olamaz.",
        "32": "Bu konuda son bir örnek",
        "33": "Association: Bir obje ile ikişkim var. “Foo uses Bar”.",
        "34": "Composition: Bir objeye sahibim ve onun lifetime’I ile yükümlüyüm. “When Foo dies, so does Bar”.",
        "35": "Aggregation: Başka birinden ödünç aldığım bir objeye sahibim. “When Foo dies, Bar may live on”.",
        "36": "Farklı bir konuda aldığım farklı bir örnek. Abstraction’a dair",
        "37": "Hash function’I nasıl kullanırız? Bir input veririz fonksiyona, o da kendi gerekli hesaplamarını yaptıktan sonra bize çok farklı bir output üretir. Hash yöntemini bilmemize gerek yoktur. Kullanıcı sadece input ve output’u bilse yeterlidir. İşlemlerin olduğu kısımdan soyutlanmamız abstraction’a genel bir örnektir. Abstract class ile tek ortak yanı, abstract kelimesinin ikisinde de geçmesidir. Başka bir ortaklıkları yoktur. İkisi bambaşka konseptler.",
        "38": "SOLID",
        "39": "Yazılım geliştirirken sürüdürülebilir kod yazmamızı sağlayan bir prensipler bütünüdür.",
        "40": "Her sınıf, method, fonksiyon tek bir sorumluluğa sahip olmalıdır. Eğer sen bir sınıfa birden fazla sorumluluk verirsen, ilerleyen süreçte kodda bir değişikliğe gitmen dahilinde sorunlar çıkacaktır. Bu da maliyeti arttıracaktır. Clean code’da şöyle denir:",
        "41": "“There should never be more than one reason for a class to change”.",
        "42": "Open Closed Principle",
        "43": "Yapılarımız(sınıf, metod, fonksiyon) gelişime açık, değişime kapalı olmalıdır. Yeni bir davranış ya da özellik eklemek istediğimiz durumda; yapmak istediğimiz değişikliği mevcut koda dokunmadan, değişimi sadece yeni kodlar üzerinden sağlamaktır. Bertrand Meyer şöyle ifade eder: ",
        "44": "“Software entities should be open for extension, but closed for modification”.",
        "45": "Yani kullanıcılara mevcut kodu değiştirmeksizin yeni fonksiyoneliteler eklemeyi sağlamalısın.",
        "46": "Alt sınıflardan oluşan nesnelerin, üst sınıfın nesneleri ile yer değiştirdiklerinde aynı davranışı sergilemesi gerekmektedir.",
        "47": "Alt sınıflar, üst sınıflardan türediği için onların davranışlarını devralırlar. Eğer üst sınıflara ait davranışları gerçekleştirmiyorlarsa davranışı yapan metodu muhtemelen boş bırakır ya da bir hata fırlatırız. Fakat bu işlemler kod kirliliğine ve geçersiz kod kalabalığına neden olmaktadır. Bunların yanı sıra projeye daha sonradan dahil olacak geliştiriciler için de sorun oluşturmaktadır. Geliştirici systemin sağlıklı yürüdüğünü düşünerek gerçekleştirilmeyen bir davranışı kullanmaya çalışabilir. ",
        "48": "Sınıflar,  kullanmadığı metodları içeren arayüzleri uygulamaya zorlanmamalıdır.",
        "49": "Bir sınıf, birden fazla arayüzü uygulaması özelliğiyle de birlikte bu prensip, bu tür durumlarda arayüzlerin ayrılmasını ve ihtiyaç hâlinde olanların kullanmasını söylemektedir.",
        "50": "“Clients should not be forced to depend upon interfaces that they do not use”.",
        "51": "Yüksek seviye sınıflar, düşük seviye sınıflara bağlı olmamalıdır. Her ikisi de soyutlamalara bağlı olmalıdır. Soyutlamalar, detaylara bağlı olmamalıdır. Detaylar, soyutlamara bağlı olmalıdır.",
        "52": "“Her desen, çevremizde tekrar tekrar ortaya çıkan bir sorunu açıklar ve daha sonra bu soruna çözümün uygulanmasını, bu çözümü iki kez aynı şekilde yapmadan milyonlarca kez kullanabileceğiniz şekilde tanımlar.” - Christopher Alexander",
        "53": "“Design patterns are solutions to recurring problems; guidelines on how to tackle certain problems”.",
        "54": "“Aklında tut! Design pattern’ler problemlere çözümdür. Problem bulmaya yarayan bir çözüm değildir. Eğer doğru yerde doğru şekilde kullanırsan onlar birer kurtarıcıdır, aksi hâlde kodunda korkunç sonuçlara neden olabilir.”",
        "55": "Bir nesnenin ya da bir grubun esnek ve tekrar kullanılabilir biçimde nasıl oluşturulacağı ile ilgilenir.  Çeşitleri: Singleton, Simple factory, factory method, abstract factory, builder, prototype.",
        "56": "Bir sınıfın sadece bir örneği olmalıdır ve bu örneğe global bir erişim noktası sağlanmalıdır. ",
        "57": "Sistem boyunca aksiyonları koordine etmek için sadece ama sadece bir tane object isteniyorsa kullanılması faydalıdır. ",
        "58": "Conctructor private olmalıdır. Bunun amacı, nesne oluşumunu tek bir yerden sağlamak; istemcinin, “new” anahtar kelimesini kullanmasını engellemektir. Statik bir değişken olmalıdır, referansı tutmak için. Tutulan referansa erişmek için bir metod olmalıdır, getInstance().",
        "59": "Multithread uygulamalarda aynı anda birden fazla thread nesne oluşturabilir farklı farklı. O an bulunan dilde bunu önleyen yapılar var (lock, synchronized gibi).",
        "60": "Singleton’ın dezavantajları",
        "61": "En büyük dezavantajı, varoluş sebeplerinden biri: global olması. Ayrıca anti-pattern davranış sergilemesi. Global instance olarak kullanılması neden kötü peki? Uygulamanın dependency’lerini bir interface ile göstermek yerine kodunda saklarsın. Bir şeyi global yapmak code smell’e sebep olur. (Code smell’I henüz çok araştırmadım).",
        "62": "Single responsibility prensibine tersitr. Çünkü kendi oluşturduklarını ve yaşam döngülerini control ederler.",
        "63": "Kodu kalıtımsal olarak sıkıca bağlı yaparlar (tightly coupled).",
        "64": "Tightly coupling’e çözüm olarak interface kullanılabileceği, test sorunlarında ise singleton class’ının yapısının değiştirilip kullanılabileceği kimi örneklerde söylenmiş. Bu şekilde kullanımla singleton’ın sorun çıkarabilecek kısımları çözülebilmektedir. Ama kullanırken(eğer doğru yerde doğru şekilde kullanmayı çok iyi bilmiyorsan) çok dikkatli olmak gerekiyor.",
        "65": "Uygulamanın lifetime’I boyunca statelerini korurlar. Bu da yine unit test için kötü bir şeydir. Çünkü her test diğerinden bağımsız olmalıdır.  Yani application’ın davranışına etki edemeyecek şekilde kullanılmalıdır.",
        "66": "Bu konudaki özlü söz:",
        "67": "Creational Design patterns’lara devam ederken kısa bir ara: Prefer composition over inheritance. Neden composition’I inheritance’a tercih etmeliyiz fırsat buldukça?",
        "68": "Runtime sürecinde superclass’lardan miras alınan implementation’I değiştiremezsin (Çünkü inheritance compiled time’da tanımlanır).",
        "69": "Inheritance, sublass’ın parent class’ın implementation’ını detaylandırmasını ortaya çıkarır. Bu yüzden inheritance’ın encapsulation’I kırdığı belirtilir.",
        "70": "Inheritance tarafından sağlanan tight coupling, subclass’ın implementation’ını parent’ın implementation’ına sıkı sıkıya bağlar. Yani parent’ın implementation’ındaki her değişim subclass’I değişime itecek, zorlayacaktır.",
        "71": "Subclass’ın aşırı kullanımı, kalıtım yığınını çok derin ve kafa karıştırıcı yapabilir.",
        "72": "Diğer yandan, object’ler diğer object’lere referans kazandırırken, object composition’I runtime’da tanımlanır. Bu durumda bu objeler, diğer object’lerin protected data’sına ulaşamayacak (no encapsulation break) ve her birinin interface’ine saygı duyacaktır.",
        "73": "Kısaca deniliyor ki, inheritance’I kullanmak için aşağıdaki 3 koşulun sağlanıyor olmasına bak. Eğer bunlar yoksa composition’I tercih etmen senin için daha yararlı:",
        "74": "A Bar is a Foo ( Inheritance “is +a” ilişkisini kuruyorsa ve “has + a” ile alakası yoksa),",
        "75": "Bar, Foo’nun yapabildiği her şeyi yapabilir ( Base class’lardaki kodu tekrar kullanabiliyorsan),",
        "76": "Base class’I değiştirerek türetilen class’larda global değişiklik yapmak istiyorsan.",
        "77": "Bu kısmın özeti: Subclassing daha fazla karmaşa ve bağlantılılık ifade eder. Hata yapmadan değiştirmesi, bakımı, ölçeklendirmesi zordur. O yüzden bu kısmı eklemeyi de gerekli gördüm ve tekrar design pattern’lere devam edebiliriz.",
        "78": "Bu kısımlara bugün çalıştım fakat saat geç olduğu için yarın kaldığım yerden aldığım notları burada yazmaya devam edeceğim. Yarın sabah creational design patterns’ları bir kez daha tekrar edip ikinci kısma geçeceğim.",
        "79": "66. Gün",
        "80": "Birbiri ile ilişili nesneleri oluşturmak için bir arayüz sağlar ve alt sınıfların hangi sınıfın örneğini oluşturacağına olanak sağlar. Örneğin kapı yapacaksın diyelim. Marangoz kıyafeti, tahtalar, yapıştırıcı gibi birçok malzeme ile uğraşıp yapabilirsin. Ya da sadece marangozu arayıp, yani factory’yi arayıp sana teslim etmelerini isteyip bu karışıklıktan kurtulursun.",
        "81": "Kısaca başka object’leri yaratmak için kullanılan bir object’dir.",
        "82": "Ne zaman kullanılır? Object oluşturmak birkaç basit işlemle olmuyorsa ve biraz mantık içeriyorsa oluşturma aşamasında, her yerde kodu tekrar etmek yerine bir “dedicated factory” yazmak mantıklı olur.",
        "83": "İşe alma müdürünü düşünelim. Her pozisyon için bir görüşmeye girmesi imkansıza yakındır. Oluşturulan iş ilanına göre görüşmeye girecek kişilere karar verir ve temsilci atar. Bu factory method için verilebilecek en basit örneklerden biridir. Child class’lara instantiation logic’i verir. Superclass’lar da object yaratmak için bir arayüz sağlar. Ama yaratılacak olan nesnenin tipini değiştirmek için sublass’lara izin verir.",
        "84": "Örneğin logistic app’imiz var diyelim. Bu app ile sadece kara lojistiğini destekliyoruz. Eğer biz deniz taşımacılığını app’imize dahil etmek istersek bir sorun var! Kodumuzda varolan class’lar birbirleriyle tightly coupled vaziyette. Böyle bir durumu çözmek için ne yapabilirsin? Factory method burada kullanılıyor ve çözüm sağlayabiliyor.",
        "85": "Ne zaman kullanılmalıdır? Kodun çalışması için boject’lerin dependency’lerini ve exact type’larını önceden bilmiyorsan kullanabilirsin. Library ve framework’ümüzün dahili component’lerini extend edecek bir yol ile kullanıcılara sağlamak için de kullanılabilir. Varolan object2leri her zaman tekrar inşa etmek yerine onları tekrar kullanarak sistem kaynaklarını korumak için de kullanılabilir.",
        "86": "Ek olarak, factory method ürün üretimi ile ürünün asıl kullanıldığı yeri ayırır. Bu da ürün üretimi tarafını kodun diğer kalan yerlerinden bağımsız olarak genişletebilmemizi sağlar. Örneğin app’ine yeni bir ürün eklemek için, sadece yeni bir creator subclass’ı yaratıp factory method’u override etmen yeterli.",
        "87": "Artıları: Creator ve concrete product’lar arasındaki tight coupling önlenir. SRP ve OCP’ye tamamen uymaktadır doğru yazıldığı takdirde.",
        "88": "Bu konuya bir örnek daha verelim. Diyelim ki sitemize giriş yapmak ya da üye olmak için sosyal medya hesaplarını kullanarak oluşturmak/girmek isteyen kullanıcı Facebook ile giriş yapabiliyor. Bizim sistemimiz buna tamamen uyumlu olsun. Ama eğer kullanıcılar artık linkedin hesabı ile de girmek isterse ve gelecekte başka eklemeler yapmak istersek burada factory method ile bu imkanı sağlarız. Kodumuzu daha flexible hale getiririz.",
        "89": "Factory method içeriklerinin çalışma prensipleri:",
        "90": "Creator class’ımız factory method’u tanımlar ve ürün class’ının objesini döner. Creator’ın subclass’ları genelde bu metodun uygulanmasını sağlar.",
        "91": "Creator isterse factory methodun default implementation’ını da sağlayabilir.",
        "92": "Creator’ın asıl yükümlülüğü product yaratmak değildir. Method İle geri dönen product objesi ile alakalı temel business logic’ini içermektedir. Subclass’lar dolaylı olarak method üstüne overriding yaparak business logic’i değiştirebilir ve başka bir product tipini döndürür.",
        "93": "Concrete creator’lar product tipini değiştirmek için factory method’un üzerine yazarlar.",
        "94": "Product interface’leri tüm concrete product’ların uyması gereken operasyonları tanımlar.",
        "95": "Concrete product’lar, product interface’inin implementation’larını sağlar.",
        "96": "Tüm bu yazdıklarım sonradan okuyunca çok manasız görünüyor çünkü örnek bir kod olmadan bir anlam taşımıyor gibi. O yüzden bu kadar detaylı kısımları atlayacağım. Fakat abstract factory ve factory method  şu üç günde en zorlandığım kısımlar olduğu için biraz fazla not aldım. O yüzden önemli görülen yerleri buraya yazmaya çalışacağım.",
        "97": "Birbirleri ile ilişkili ürün ailelerini oluşturmak için bir arayüz sağlar. Factory tasarım deseninde bir ürünün oluşturulması soyutlanmışken , abstract factory deseninde birbirleri ile ilişkili ürün ailelerinin oluşturulması soyutlanmıştır. Factory üreten factory deseni olarak da düşünülebilir.",
        "98": "Birden fazla ürün ailesi ile çalışmak zorunda kaldığımız durumlarda, istemciyi bu yapılardan soyutlamak amacıyla Abstract Factory doğru bir yaklaşım olacaktır.",
        "99": "Simple factory’deki kapı örneğimize dönelim. İhtiyacına göre marangozdan tahta, demirciden demir kapı, plastikçiden PVC kapı alırsın. Ayrıca bunların her biri için de ayrı ayrı takacak usta bulman lazım. Çünkü hepsinin ustası farklı. Bir tahta kapı oluşturmak için tahta ve ustası gerekir. Diğerleri için de aynı şekilde geçerlidir. Kapısı oluşturmak için iki farklı objeyi aynı noktada buluşturuken Abstract Factory’den yararlanırız. ",
        "100": "Ne zaman kullanırız? İlgili ürünün farklı aileleri ile kodun çalışmaya ihtiyaç duyarsa, ama bu product’ların concrete class’larına bağlı olmasını istemezsen (Öncesinde bilinmeyebilirler ve future extensibility’ye izin vermek istersin) kullanabilirsin. ",
        "101": "Farklı bir örnek verelim: Bir web sayfasının farklı elementleri için değişik tipte templates’lerin yaratılması için bir altyapı sağlayabilirsin. Bir web uygulaması aynı anda farklı rendering engines’leri destekleyebilir ancak onun class’ları rendering engine’in concrete class’larından bağımsızsa. Bu yüzden, app’in object’leri ile yalnızca onların abstract interface’lerini kullanarak iletişim kurmak zorundasın. Senin kodun direkt template object’lerini yaratmamalı, ama onların yaratılması için özel factory object’leri atamalıdır. Son olarak, kodun factory object’lerine bağımlı olmamalıdır, ama yerine abstract factory interface aracılığı ile onlarla çalışmalıdır. Sonuç olarak , app’e, rendering engines’lerden birine denk gelen factory object’sini sağlayabileceksin. App’te yaratılan her template, factory tarafından yaratılacak ve ve onların tipi factory’nin tipiyle eşleşecek. Eğer sen rendering engine’I değiştirmek istersen, mevcut kodu bozmadan client koduna yeni bir factory geçebileceksiniz.",
        "102": "Farklı kaynaklardan ek olarak şunlar söylenebilir:",
        "103": "Particular dependency yaratmak için runtime değerlerine ihtiyaç duyduğun her yerde Abstract factory’yi kullanabilirsin.",
        "104": "Abstract factory’nin gerçek hayat örneklerini araştırdıkça Dependency Injection konularında sıkça kullanıldığını gördüm. Esasında kullanılan yerlerden bazılarına örnek olarak:",
        "105": "Kısaca Abstract factory Dependency Injection için gayet merkezi bir design pattern olarak yer alır.",
        "106": "Factory method ve Abstract Method arasındaki farklar:",
        "107": "Abstract factory, yaratılması gereken object’ler için abstract method’ları içeren base class’ları yaratır. Base class’tan türeyen her factory class, her object tipinin implementation’ını kendi yaratabilir.",
        "108": "Factory method, bir class’ta object’ler yaratmak için kullanılan basit bir method’dur. ",
        "109": "Özetle; Factory method’u içeren class’ın asıl amacı obje yaratmak değildir. Abstract Factory ise sadece object yaratmak için kullanılmalıdır. Diğer bir fark ise; abstract factory composition ile implement edilir, ama factory method inheritance ile. Kavranması gereken en önemli nokta abstract factory client’a enjekte edilir. Bu yüzden composition var deriz.",
        "110": "Not: Nesneleri yaratırken LSP’ye ters bir şey yapmak kolay olduğu için factory method’ları kullanırken dikkatli olmalısın. ",
        "111": "Karmaşık yapıdaki nesnelerin oluşturulmasında istemcinin sadece nesne tipini belirterek üretimi gerçekleştirmesini sağlamak için kullanılan bir desendir. Bu desende istemcinin kullanmak istediği gerçek ürünün birden fazla sunumunun olduğu durumlarda kullanılır.",
        "112": "Burger King'e gittik diyelim. İkili menu istedik ve onlarda getirdi. Bu basitçe simple factory’ye benzetilebilir. Ama creation logic’inin daha fazla adım içerme ihtimali de vardır. Mesela  “Burger’ın nasıl olsun? Et az pişmiş mi? Hangi sosları eklememizi istersiniz? İçinde turşu ister misiniz? “ gibi. İşte burada builder pattern bizi kurtarmaya gelir. ",
        "113": "Constructor pollution’ından kaçınarak bir object’nin farklı niteliklerini yaratmaya izin verir.",
        "114": "Constructor’ımızın için birçok parametre varsa bunu karışma ihtimali çok fazladır. Parametre sayısı daha da artarsa içeriğini düzenlemek daha da zorlaşır. Bu durum telescoping constructor anti-pattern diye geçer literatürde. Buna tek alternatif ise builder pattern’i uygulamaktır. ",
        "115": "Factory pattern ile arasındaki ana farklılık: “üretim tek adımlı bir işlemden geçiyorsa factory pattern, üretim birçok aşamadan oluşuyorsa builder method kullanılır.”.",
        "116": "Eğer telescoping constructor pattern’ine karşı olarak;  instance’ı cilent’ta oluşturup her method’u tek tek çağırırsan,birkaç çağrı üzerine object yaratıldığı için concstruction’ın herhangi bir anında inconsistent (tutarsız) bir durum oluşabilir. Bu da thread safety’yi sağlamak için ekstra çabaya neden olabilir. Bu yüzden en iyi alternatif builder pattern’dir.",
        "117": "Faydaları:",
        "118": "Parametre değerlerinin hepsi tek bir lokasyonda bulunur.",
        "119": "Kodun daha kolay yazılıp, okunmasını, ve anlaşılmasını sağlar.",
        "120": "Parametreleri control etmek için build method modifiye edilebilir ve eğer geçersiz bir parametre değeri verildiyse “IllegalStateException” hatası throw edilebilir.",
        "121": "Flexible’dır. Gelecekte parametre eklemek çok daha kolaydır.",
        "122": "Dolly’yi hatırladın mı? Klonlanmıştı. Buradaki tek konu klonlama. Varolan object’yi klonlayarak yeni bir object yaratmak.",
        "123": "PHP’de klonlama işlemi direkt  “__clone”  magic method’u ile yapılabilir. Ya da direkt  “clone” ile de yapabilirsin. ",
        "124": "Ne zaman kullanmalı? Varolan bir objenin bir benzeri gerekliyse veya cloning’e kıyasla creation daha masraflı ise kullanabilirsin. Maliyetleri üretimi olan nesneleri az maliyetle üretmek için (Maliyetten kasıt parametreli constructor vb. olabilir). Shallow copy ve deep copy olarak iki türü var. Shallow copy ile nesnelerin bellekteki adresleri kopyalanır. Yüzeysel bir işlem olduğu için yeni bir nesne üretilmez. Deep copy ise bizim istediğimiz şekildedir. Birebir kopyalayıp, bu kopya ile asıl nesne farklı referanslar ile işaretlenebilmektedir.",
        "125": "Amaç: “intends to do is reduce the creation time of an object”.",
        "126": "Nesnelerin birbirleriylse nasıl birleşecekleri üzerinde durur.",
        "127": "Bir sınıfın arayüzünü istemicinin beklediği arayüze çevirmeye yarar. Ya da uyumsuz bir yapıyı, istemcinin beklediği bir yapıya getirir diyebiliriz.",
        "128": "Bir örnek verelim gerçek hayattan: Şimdi bir sistemde external DVR’lar ile ilgili bir arayüze ihtiyaç duyulduğunu düşünelim. Her DVR üreticisi aletlerinin bizim tarafımızdan kontrol edilebilmesi için kod yazmamıza izin veren bir kütüphane sağlar. Bu kütüphaneye SDK diyelim. Her SDK, DVR’ların en temel fonskiyonalitilerini sağlayan arayüzlere sahip olsa da onların hepsi aynı benzerlikte değildir. Yani SDK’dan SDK’ya fark gösterebilmektedir.  Bizim yazacağımız yazılım ise tüm DVR’lar ile etkileşimde olamlı. Her farklı SDK için ayrı bir switch case durumu açmak yerine, ortak bir arayüz yaratıp, tüm sistem kodumuzu bu arayüz vasıtası ile geliştirebiliriz. Her farklı SDK için farklı bir adapter yazılıp bizim interface’imizi implement eder. Bu şekilde kodumuzu daha basit yapabiliriz, Adapter pattern sayesinde.",
        "129": "Daha basitçe anlaşılacak örnek ise: JSON işlemleri için sistemimiz JsonSerializer arayüzünü kullanıyor. Ama sonrasındaki süreçte 3. Parti bir şey ekleyip farklı bir arayüz kullanmak istiyoruz diyelim. Bizim sistemimiz JsonSerializer üstünden yürüdüğü için adapter pattern’I kullanarak  JsonSerializer gibi görünerek 3. Parti yazılımının çalışmasını sağlıyoruz.",
        "130": "Abstract yapıpı, implementasyonundan ayırmaya, bağımsız olarak geliştirilebilir iki yapı elde etmemize yarar.",
        "131": "Örnek: Farklı sayfaları olan bir websitemiz olduğunu düşünelim. Kullanıcıların sayfaların theme’ini (dark mode gibi) değiştirebildiğini düşünelim. Ne yapardın? Her sayfanın tek tek kopyasını oluşturup hepsi için theme yaratmak mı? Ya da sadece kullanıcının tercihine göre yüklenecek ayrı bir theme yaratmak mı? Bridge pattern 2.’yi yapmamıza izin verir. ",
        "132": "“Bridge pattern, ‘prefer composition over inheritance üzerinedir. Implementation detayları,ana hiyerarşiden uzaklaştırılıp başka bir objenin ayrı bir hiyerarşisine itilir”.",
        "133": "Saat geç olduğu için yarın kaldığım yerden devam edeceğim. Direkt defterden yazığım için bazı yerler haddinden fazla uzamış ve karışık olmuş olabilir. Yazarken farkındaydım. Ama şu ana kadar en oturmayan ya da karşıma çıksa zorlanacağım dediğim yer Abstract Factory oldu. Şimdiye kadar zorlandığım birçok yer sonradan tekrar ve tekrar üstüne gidince oturmuştu. Onun da oturacağına inanıyorum. ",
        "134": "67. Gün",
        "135": "Nesneleri ağaç yapısına göre düzenleyerek ağaç yapısındaki alt üst ilişkisini kurmaya yarayan bir desendir.",
        "136": "\"Composite patttern, client'ın aynı tavırla  bireysel nesnelere davranmasına izin verir.\"",
        "137": "\"Farklı nesneleri gruplayıp, bir nesnenin tek bir instance'ı şeklinde davranılmasını tanımlar.\" - Wikipedia",
        "138": "Amaç:",
        "139": "Part-whole hiyerarşini temsil etmek için nesneleri ağaç yapısına \"compose\" eder. Composite pattern'i uygulamak client'ın indivual nesnelere ve compositon'lara homojen şekilde davranmasına izin verir.",
        "140": "Örneklendirelim:",
        "141": "Her organizasyon, her şirket çalışanlara sahiptir. Çalışanların her biri aynı özelliklere sahiptir. Maaşa sahiptirler. Sorumlulukları vardır. Birine rapor vermeleri gerekebilir yada gerekmeyebilir. Astları bulunabilir ya da bulunmayabilir.  Bunları aynı collection'a alıp istersek maaşlarını toplayabilir ya da hepsi için başka method'larda uygulayabiliriz.",
        "142": "Nesnelere dinamik olarak yeni sorumluluklar atamamızı sağlayan tasarım  desenidir. Object'lerin class'ını subclassing ile tüm object'lerin türetildiği class'a işlevsellik eklemek kolaydır. Ama tek bir nesneyi bu şekilde extend etmek imkansızdır.Decorator pattern ile, tek bir nesneye işlevsellik ekleyebilir",
        "143": "\"Aynı class'tan türeyen diğer objelerin davranışını etkilemeden, statik veya dinamik olarak, bir tek nesneye davranış eklemeye izin verir. Single responsibility principle'a bağlı kalmak için kullanışlıdır.\" - Wikipedia",
        "144": "Bilgisayarı nasıl açarım? Bir güç düğmesine basarak. Bu aslında senin inandığın şey çünkü bilgisayarın dışarıda sağladığı basit bir arayüzü kullanırsın. Dahili olarak bilgisayar bu işlemleri yaparken çok daha karmaşık bir ilişkiler bütünü vardır. Kompleks alt sisteme verilen basit arayüz Facede olarak adlandırılır.",
        "145": "Design Pattern tekrar eden bir problemi çözmenin ortak bir yolunu sağlar. Design Pattern'lerdeki class'lar sadece normal birer class'tır. Önemli olan onların nasıl yapısal olarak kurulduğu ve bir problemi çözmek için en iyi şekilde nasıl beraber çalıştıklarıdır. ",
        "146": "Facade design patterns karmaşık bir sistemin arayüzünü basitleştirir. Complex bir sistemin subsystemlerini oluşturan class'ların tümünden oluşur. Facade, kullanıcıyı sistemin karışık detaylarından korur ve kullanımı kolay basitleştirilmiş bir görünüm sağlar.  Ayrıca sistemi kullanan kodu alt sistemlerin ayrıntılarından ayırarak sistemi daha sonra değiştirmeyi kolaylaştırır.",
        "147": "Daha önce de yazmıştım ama tekrar etmekte kendim için fayda var. Tasarım kalıplarını öğrenirken önemli olan, verilen problemimize hangi kalıbın uyduğunu fark edebilmek ve sonra onu uygun şekilde kullanabilmektir. Bir pattern'i yanlış biçimde kullanmak veya bir pattern'i bildiğin için problemini sadece onunla çözmeyi denemek büyük bir sorundur. Bu tuzaklara düşmeden design pattern'ları öğrenmekte fayda var.",
        "148": "Facade için özetle şunu diyebiliriz: amaç sistemi yeni bir altyapıya sokmak değil, alt sınıflardaki karmaşıklığı soyutlayarak pratiklik sunmaktır.",
        "149": "Askerlik sırasında kahvaltı için yemekhaneye gidldiğinde birçok bardak çayla doludur ve sırasıyla her gelen er çayını ve yemeğini alıp yerine oturur. Birçok çay bardağı birden doldurulur sebebi ise kaynaklardan tasarruf etmek olabilir. Burada kaynak, zaman insan işgücü, hız, çayın az ve eşit oranda doldurulup çaydan tasarruf yapmak da düşünülebilir. Kısaca Flyweight pattern tamamen paylaşmak hakkındadır. Sık kullanılan nesnelerin bellek yönetimini kontrol etmek için kullanılır.",
        "150": "\"Flyweight, diğer benzer object'ler ile mümkün olduğu kadar veri paylaşarak hafıza kullanımını minimize etmeye çalışan bir object'dir. Basit bir tekrarlanan temsilin kabul edilemez miktarda bellek kullanması durumunda, nesneleri çok sayıda kullanmanın bir yoludur.\" - Wikipedia",
        "151": "Gereksiz nesne initialize etmeyi bırakıp hafızada daha az yer kaplamak amaçtır dediğimiz üzere. GoF'ta bir object'nin iki durumundan bahsedilir:",
        "152": "\"Esas Durum(Intrinsic State): Flyweight'te depolanır. Flyweight içeriğinden bağımsız bilgilerden oluşur. Bu da onu paylaşılabilir kılar.",
        "153": "Eğreti Durum(Extrinic State): Flyweight'in içeriği ile değişebilir ve ona bağlıdır. Bu yüzden paylaşılabilir değildir. Client object'leri ihtiyaç olduğu durumda eğreti durumu flyweight'e geçirmekle yükümlüdür.\" ??Bu cümleyi pek anlamadım.??",
        "154": "İstemcinin orjinal nesneye direkt erişimi yerine bu erişimi nesneyi temsil eden proxy(vekil) sınıflar üzerinden gerçekleştirmesini ve bu proxy sınıfların sunduğu imkanları kullanmasını sağlayan tasarım desenidir.",
        "155": "Çoğu PHP uygulamasında pek kullanılmasa da yine de kullanıldığı bazı alanlar var: caching, logging, access control, delayed initialization gibi. Örneğin downloader da bu konuya örnek verilebilir. Proxy sayesinde caching kullanarak downloader'ın performansı arttırılabilir. Mesela bir dosyayı indirdin diyelim. Sonrasında tekrar indireceksin aynı ürünü. Birinci indirmende bu veriyi caching ile direkt sana vermek hem zamandan hem de trafikten tasarruf sağlar.",
        "156": "Gerçek dünyadan bir örnek olarak da kredi kartı verilebilir. Banka hesabımız için kredi kartı bir proxy'dir. Nakit para yerine kullanılabilir ve gerektiğinde nakit parayı çekmemize yarar.  Bu da tam olarak proxy'nin yaptığı şeydir:",
        "157": "\"En genel haliyle proxy, başka bir şeye arayüz olarak işlev gören bir sınıftır. Proxy, sahne arkasında gerçek hizmet veren nesneye erişmek için istemci tarafından çağrılan bir sarmalayıcı (wrapper) veya aracı (agent) nesnedir. Proxy kullanımı, gerçek nesneye yönlendirme olabilir veya ek mantık sağlayabilir. Proxy'de, örneğin gerçek nesne üzerindeki işlemler kaynak yoğun olduğunda önbelleğe alma veya gerçek nesne üzerindeki işlemler çağrılmadan önce ön koşulların kontrol edilmesi gibi ekstra işlevsellik sağlanabilir.\" - Wikipedia",
        "158": "Structural design pattern'ları bir sonraki konuya geçmeden önce özetleyelim. Aralarındaki farkları yazalım. Çünkü hepsi birbirine yapısal olarak benzemekte ve kafamızın karışma ihtimali çok fazla.  Proxy, decorator, adapter, ve bridge; hepsi bir sınıfı \"wrapping\" (saramalamak) üstüne varyasyonlardır. Ama kullanımları farklıdır.",
        "159": "Bir nesneyi lazy-instantiate etmek istersen, veya remote bir service'i çağırdığını gizlemek için, veya nesneye erişimi kontrol etmek istersen kullanılabilir.",
        "160": "\"Smart Proxy\" olarak adlandırılır. Bir nesnenin türünü genişletmeden, ona yeni bir işlevsellik eklemek istersen kullanılabilir. Bu, runtime'da yapmanızı sağlar.",
        "161": "Bir abstract arayüzün olduğunda ve farklı bir arayüze ama çok benzer bir işleve sahip başka bir objenin arayüzü ile eşleştirmek istersen kullanabilirsin.",
        "162": "Adapter'a çok benzerdir ama sen hem abstract interface'i hem de temeldeki implementation'ı tanımladığında onu kullanırsın. Örneğin, bazı 3. parti kodlara adapte olmuyorsun ve tüm kodun designer'ı da sahibi de sensin. Ve sadece bazı farklı implementation'ları değiştirmek istiyorsun.",
        "163": "Bir veya birden fazla sınıfın alt sınıflarına yönelik oluşturulan bir high-level interface'dir. Düşünelim ki birden çok nesnenin oluşmasını gerektiren kompleks bir yapıya sahipsin. Bu nesneler kümesinde değişimler yapmak kafa karıştırıcı olabilir çünkü hangi nesnenin senin çağırmak istediğin metoda sahip olduğunu her zaman bilmeyebilirsin. Nesnelerin koleksiyonuna yapabileceğin kompleks işlemler için high-level methodlara sahip bir facade yazma zamanı gelir!",
        "164": "Nesneler arası ortak haberleşmeyi efektif ve esnek bir yapıya getirmemizi sağlar.",
        "165": "Bir amaca yönelik bir dizi işlemi gerçekleştiren nesnelerin birbirinden bağımsız bir şekilde çalışmasını ve her bir nesnenin sadece kendisiyle tanımlı işleri yapmasını sağlayan bir tasarım desenidir.",
        "166": "\"Nesne zinciri üretmeye yardım eder. Uygun handler'ı buluncaya dek istek bir nesneden yerden başlar ve tek tek nesneleri gezerek devam eder.\"",
        "167": "3 ödeme şeklim var diyelim. Birincisi banka hesabım, ikincisi Paypal hesabım, üçüncüsü de bitcoin olsun diyelim. Bankada 100 liram var, Paypal hesabımda 200 lira var, bitcoin cüzdanımda da 300 liram var toplamda diyelim. Şimdi ben 259 liralık alışveriş yapacağım. Diyorum ki, \"sevgili banka hesabım sende bi 259 almam lazım\". Ama görüyoruz ki orada o kadar yok. Banka hesabım da diyor ki \"Ben seni Paypal hesabına yönlendireyim. Bende o kadar bozukluk yok\" dedi. Paypal hesabında da o kadar para olmayınca, bitcoin cüzdanına yönlendirdi ve sonunda orada para olduğu için işlemin tamamlandı. Burada yapılan şey nesnelerin davranışı ile ilgiliydi. Yükümlülük zinciri gibi bir ismi var, ve tabii ki nesneler için. En azından biz OOP üstüne ilerlediğimiz için. ",
        "168": "\"Eylemleri nesnelerde kapsüllememizi (encapsulation) sağlar. Bu kalıbın arkasındaki ana fikir, istemciyi alıcıdan ayırmanın yollarını sağlamaktır.\"",
        "169": "\"Bir eylemi gerçekleştirmek veya sonraki bir zamanda bir olayı tetiklemek için gereken tüm bilgileri kapsüllemek için bir nesnenin kullanıldığı davranışsal bir tasarım kalıbıdır. Bu bilgiler, yöntem adını, yöntemin sahibi olan nesneyi ve yöntem parametreleri için değerleri içerir.\" - Wikipedia",
        "170": "Örnek verelim.  Bir restaurantta sipariş verdiğini düşün. Sen (Client), garsona (Invoker) iskender (Command) getirmesini söylersin. Ve garson senin talebini şefe (Receiver) iletir, ki şef iskenderi nasıl pişirileceğine dair bilgisi olan insandır). Diğer bir örnek ise: Sen (Client), uzaktan kumandayı (Invoker) kullanarak televeziyonu (Receiver) açarsın(Command).",
        "171": "Bugün behavioral design pattern'lara geçiş yaptım. Yarın tamamen bitirip cumartesi günü hepsini tekrar edeceğim.",
        "172": "68. Gün",
        "173": "UML'e Giriş",
        "174": "Giriş",
        "175": "UML yürürken ayaklarına bakmak gibidir. Genellikle bilinçsizce yapabileceğin şeyleri bilinçli ve açık hâle getirir Hepimiz kodları okuruz, yazarız, yorumlarız. Bizim hobimiz, işimiz, ya da mecburi alınan bir programlama dili dersini geçmek gibi sebepleri olabilir. Ve bir yazılım geliştiricisi genelde kodu yorumlamak veya diyagramlarını çizmeye pek eğilimli değildir. Direkt kodun kendisini okumak daha akla yatkın gelir. Ama bazı faydaları vardır ki onu da göz önünde bulundurup kullanmak gerekebilir. Hem forward engineering hem de reverse engineering için kullanılabilir.",
        "176": "UML'i sadece yaptığın bir şey ile alakalı düşünmemek gerekir. Örneğin gece ormandasın ve yağmur yağmaya başladı. Ortalık kapkaranlık. Kendi ayaklarına baksan bile fayda etmeyecek çünkü hiçbir şey göremiyorsun. Ama birisi  bir meşale ile yakınında olsaydı onun ışığını ya da ayak izlerini takip edebilirsin. Çamur, karanlık, ağaçlar, dikenli otlar arasında yolunu bulurdun. Bu benzetmeye örnek olarak,bir projeye başlandı şirkette. 5 yıl sonra, bu projeye önceden dahil olan insanlar gittiğinde ne olacak peki? Projeye daha sonra katılan herkes için bazı temel güncel belgelerin mevcut olması inanılmaz derecede yararlıdır. Şöyle bir gerçek de var. Bir projenin her kısmı tamamen method ve parametre isimleri ile dolu dolu açıklanmaya çalışılırsa bunun sürdürülebilirliği ve bakımı zordur. Yine de sistemdeki yapılar arasındaki ilişkilerin temel diyagramlarını göstermek çok değerlidir. Genelde hiç kimse 50 sayfalık herşeyiyle tam oluşturulmuş bir UML diyagramını okumayı istemez. Bu yüzden ölçülü bir şekilde bir sistemin UML diyagramını oluşturmak gerekir. UML'in bir diğer yaralı olduğu nokta da şu: Yazılım departmanında senior olan bi geliştirici bir yapıyı dizayn etmekten sorumlu olup, tasarımın uygulamasını junior geliştiriciye bırakması.",
        "177": "Genel olarak UML'in ne için kullanıldığı, eşsiz olmayan benzetmelerle (based on stack overflow entries) açıklanmaya çalışıldı. Şimdi UML'in ne olduğuna bakalım.",
        "178": "Gelişme",
        "179": "UML bir modelleme dilidir. Temel amacı tasarlanan bir sistemi görselleştirmektir. UML bir programı dili değil, görsel bir dildir aslında. UML nesne yönelimli programlama ile bağlantılıdır ve elementler arası ilişkinin görselleştirilmesini diyagramlar ile sağlar. Bu diyagramlar ikiye ayrılabilir: Behavior (Davranış) diyagramı, Structural (Yapısal) diagram.",
        "180": "UML'i herşeyiyle tam olarak anlatmak aşırı uzun ve zaman alacak bir şey olduğu için sözü direkt class diagrams'lara getirelim. Class diyagramları her nesne yönelimli metodun ana \"building block\"larıdır. Sınıflar arası ilişkileri, arayüz kullanımını, ve diğer sınıflar ile alakalı şeyleri göstermek için kullanılır. Class diyagramları şu yapılardan oluşmaktadır:",
        "181": "Her class dikdörtgen bir kutunun içinde ismi, özellikleri (nitelikleri), ve kullandığı metotları ile oluşturulur.",
        "182": "Metotların ve özelliklerin görünümünü (public, private, protected) belirtebilceğimiz 3 tip \"modifier\" vardır: \n \"+\" public görünürlük sağlar (Herkes için). \"#\" protected görünürlük sağlar (Kendisinden türetilen sınıflarda da görünebilmesi için). \"-\" private görünürlük sağlar (Sadece kendisi için).",
        "183": "Sonuç",
        "184": "Bugün aldığım notlar bu şekildeydi. Genel olarak class diagram'daki elementlerin neler olduğunu öğrendim. Nesnelerin-class'ların birbirleri ile olan ilişkilerinin nasıl bir diyagramda gösterildiğini öğrendim. ",
        "185": "69. Gün",
        "186": "UML ile class diyagramın nasıl oluşturulduğunu öğrendim. UML ile oluşturulan diyagramı okuyup bir programlama dilinde(PHP) yazmayı öğrendim. Cumartesi günü kısaca bunun üstüne okumalar ve pratik üzerine geçti. Sizin yazdığınız kodu genel olarak anladım oluşturulurken. UML’de bir interface yaratırken biraz ezbere oluşturmuş gibi hissettim. Çünkü siz kodu yazarken ihtiyacı farkettiğinizde kodu ona göre şekillendirmiştiniz. Bense biraz daha düz mantıkla hareket etmiştim. İhtiyaca göre elementler ekleme fikri biraz daha oturdu aslında. Ben de kendim için aynı metodu uygulamak istiyorum. ",
        "187": "70. Gün",
        "188": "Bugün veritabanı bağlantısını ve query builder’ı object oriented nasıl yapabileceğim üstüne çalıştım. Query builder’I spesifik bir tablo için yapmak hiç zor değildi. Aslında her tablo için yapmak da çok zor olmamalı fakat çok basit görünen kısımlarda sürekli hata aldım. Neydi bu kısımlar? En kolay görünen array’den string’e dönüştürme, sql sorgusunu doğru yazma gibi şeylerdi. Quotation marks’ların birbiriyle çakışmasını düzeltmeye çalıştım ama başarılı olamadım. Yarın ilk iş, sabahtan hatalarımı tekrar düzeltmeye çalışmak olacak. Query builder için arayüz sağlamak ve factory method kullanmak istememizin sebebini çok net anladım. Sorgunun doğru çalışmasını sağlayabilirsem oraları düzenlemek kolay olacaktır diye düşünüyorum. Kısaca ne yaptığımızın, nasıl yapmamız gerektiğinin farkındayım fakat günün ikinci yarısı hataları düzeltemedim. Yarın zinde bir kafa ile tekrar bakacağım."
    },
    "part8": {
        "1": "71. Gün",
        "2": "Bugünü düşününce, bu kadar bol zamanda verilen soruyu nasıl yapamamışım onu anlamadım. Yani aşırı uzun bir zamanda yine de tam olarak yapamamak üzdü şimdi düşününce. Ama yazdığım kodda her ne kadar mantık hatası olsa da (ki sonradan dediğiniz yerleri düzelttim) bence çok sadeydi ve yerindeydi. Fakat tam istenilen yapıyı oluşturmak için (string ifadelerde kesme işareti koymak gibi) yeterli mi bilmiyorum. Onun için de bir düzenleme yapmam gerekecek. Ya da sil baştan değiştireceğim gibi. Şu anki koda uygulanabilir mi deneyeceğim yarın. Bugün güzeldi. Javascript e uzun zamandır bakmamıştım ve bugün bir dili(Js’i) özlediğimi farkettim. İlk forEach’i gördüğümüz zaman aklıma geldi şimdi. Resmen ezberliyordum. Kendime “'map' daha kolay, ben hayatta  bu forEach’I yapamam” demiştim içten içe. Aradan zaman geçti. Şimdi bu dediğime şaşırıyorum. Elbette hâlâ iyi değilimdir ama o hâlimi düşününce şu kısa süreçte (göreceli) “nereden nereye” dedim. Çok uzatırsam subjektif konulara gireceğim gibi geldi. O yüzden günü Aristo’ya ait olduğu iddia edilen, oysa ki sadece Aristocu felsefe için bir yazarın kendi kitabında değindiği sözüyle bitirelim: ",
        "3": "“Biz, tekrar tekrar yaptığımız şeyleriz. Demek ki mükemmellik bir eylem değil, bir alışkanlıktır”.",
        "4": "72. Gün",
        "5": "Gerçekten anladım ki saatlerce uğraşıp istenilen sonuca ulaşılamasa da, bir ara verip tekrar bakınca en azından takılınan noktalar düzeltilebiliyor. Bu neden böyle oluyor hâlâ anlamadım. Belki buna inandığım için \"plasebo\" etkisi gibi bir şey olabilir.",
        "6": "Bugüne dönelim. Verilen görevi ilk gün bitiremedim. Sonraki gün istenilen sonucu hem Javascript'te hem PHP'de oluşturdum. Tabii ki de en iyi performansı veren, en mantık hatalarının olmadığı kod değildi fakat en azından ana fikirleri (recursive, algoritmanın oturtulması, switch-case kullanımının \"şık\"lığı ve okunabilitesi) sizden aldıktan sonra kendim çabaladığım şeylerdi. O yüzden memnunum şahsi olarak. Bugün öğleden sonra ise tamamen \"string olarak gelen sorguyu, nasıl bir array içinde anlamlı node'lar hâline getirebilirim\" diye düşünüp sonrasında pratiğe dökmek ile geçti. Başlangıçta bir yanlışım oldu. Gelen veriyi dediğiniz gibi manipüle ettim. Tabii ki bu yanlıştı. Sonra nasıl manipüle etmeden yapabileceğimi düşündüm. Eğer ben manipüle edemiyorsam manuel olarak, yazdığım kod etmeliydi. Eğer string ifadeyi yine boşluklarından split ile ayırırsam ve daha anlamlı hâle getirirsem karakterlerin düzenlenmesi daha kolay olur diye düşünmüştüm. Ama o şekilde işin içinden çıkmak kolay değildi. O yüzden her karakteri ayrı ayrı ele alıp ona göre işlem yaptım. Başta bu çok uzun sürer diye hiç denememiştim bile. Oysa ki o kadar da uğraştırıcı değilmiş.",
        "7": "Şimdi istenilen sonuca ulaşamasam da belli bir yere kadar geldim (Tanrım, umarım doğru yerlerdir). Yarın kaldığım yerden devam edeceğim. ",
        "8": "Bu tür sorular ve sorunlar karşıma çıkınca bazen stres yapsam da genel olarak çok keyif alıyorum. Yapamasam bile daha da yapmak istiyorum. ",
        "9": "Şeyi farkettim geçenlerde: Yıllardır stresle mücadele etmeye çalışmıştım bireysel olarak. Çünkü stres sağlık sorunlarına da yol açıyordu ve benden uzak olmasını çok istedim. Sonra farkettim ki yıllar boyunca ben stresle mücadele ederken asla beni bırakmıyordu. Madem gitmiyor, gitmeyecek, o zaman benimle kalsın barış içinde yaşayalım dedim. Hâlâ daha şımarıklık yapıyor ama onunla kavga etmekten daha iyidir bu bakış açısı sanki. Öylece kabullenmek stresi. Evet sıradan motivasyon konuşmaları, Amerikan filmlerindeki rehabilitasyon grubu (hani \"Evet arkadaşlar Martin Eden 3 aydır alkol almıyor, hep beraber onu alkışlayalım\" repliklerinin bol olduğu) konuşması gibi oldu. Çok uzatmayayım. ",
        "10": "Son geldiğim noktayı paylaşmak istiyorum. Tam olmadığı için hiç açıp bakmasanız bile hiç sorun değil. Sadece paylaşmak istedim.",
        "11": "73. Gün",
        "12": "Bugün sabah baktığım görevde sonuca çok yaklaştığımı hissetmiştim. Fakat kendi kurduğum yapının karışmaya başlaması ve çokça şey yaptıktan sonra kalem oynatamadım nerdeyse. Sonrasında verdiğiniz görevi yaptım. Daha sonrasındaki için ise ne yapabileceğim üstüne fikir yürütüp bir mantık kurdum. Yarın onun üstüne çalışacağım sabah. ",
        "13": "Bir cümlemiz var. Biz onu nasıl okurken anlamlandırıyorsak, makine için de aynısını yapmamız gerekiyor. Gelen veriyi anlamlı hale getirmek amacımızdı. Son örnekte (\"mer(h)aba\" (\"a\" asd) benim \"sss\"  asdasd') tırnak işareti içindeki parantezin de tırnak işaretinin bir parçası olduğunu ve ayrı bir anlamı olmadığını nasıl ifade edebilirdim? Ve tabii ki aynı şey diğer kısımlardaki benzer durumlar için de geçerliydi. O zaman şu  yapılabilir: Verideki her bir eleman tek tek gezilir. Eğer bir iç içelik söz konusu ise (anlamı oluşturmak için kullanılan anahtar kelimelerde), iç kısımda bulunan anahtar elementin pozisyonunu(index’ini) eğer bir yere kaydedersem ve onu sonrasında anlamlı yapıyı oluşturmak için kullanmazsam sorun çözülür. Bu iç içelik durumunda görmem gereken sadece içteki elemanı anahtar element olarak görmemek olacaktır o örnek için. Fakat iç içe yapılarda alt düğüm(sub-node) oluşturacaksam, elbette onu da yine hesaba katmam gerekecektir. Kısacası, karşımızda bulunan soruna göre farklı sonuçlar üretebiliriz. Makinenin dilini kullanabilmek için en temel mantıksal çıkarımları yapmak gerekiyor sanırım. Ve bu şekilde bir yapı oluşturmak ya da oluşturmaya çalışmak, felsefe ve matematiğin içine itiyor insanı. 4 ay önce bana bunları dese inanmazdım herhalde. Ancak yapay zeka gibi içinde “fazla zekice görünen kelimeler” bulunan konularda sanırdım. Oysa ki bir string varlığı anlamlı hale getirmek bile gayet “zekice” bir konuymuş.",
        "14": "74. Gün",
        "15": "Bugün aslında daha hızlı çalışıp tekrar query building’e de bakabilirdim. En olmadı mesai sonrasında da bakabilirdim. Ama yapmadım çünkü bugünkü görevin üstüne farklı neler yapabilirim onları denedim. Nasıl daha “clean code” yazarım diye düşünüp bir şeyler denedim fakat yine de pek clean olmadı. Yazarken sadece en rahat yazdığım şekilde ilerliyorum fakat sonrasında üstünde değişiklikler yapabiliyorum. Yazarken bunu düşünüp yazmaya çalışacağım elimden geldiğince. Bazı konularda problemin köküne inebildiğimi düşünüyorum fakat her yerde olmuyor. Gözden kaçan bazı noktalar sonrasında düzeltmem gereken farklı problemlere sebep olabiliyor. Ama bir şeyler yazdıkça ve üzerine gittikçe daha da oturacaktır. Bu hafta bir şeyler yaptım. Gerçekten de istenilen sonuçlara biraz da olsa yakın ya da problemlerin köklerine biraz da olsa yaklaştım. Yaklaşmamışsam da biraz öyle hissettim.  Ama hep eksikler vardı. Sizin “algoritma çalışın” demenizi anlıyorum. Ben de boş zamanlarımda “competitive programming” gibi internette bolca bulunan kaynaklara bakmak istedim fakat onun yerine farklı şeylere vakit ayırdım. Şimdi anladım ki elimden geldiğince bakmalıyım. Eğer kitap gelirse kendime bir amaç koydum. O kitaptaki her algoritmayı PHP ve Javascript’te deneyeceğim. Ortaya işe yarar ve “clean” olan uygulamalar koyacağım. Tabii ki mesai dışında olan boş zamanlarda  bunu deneyeceğim. Anlayarak adım adım ilerleyerek biraz zamanımı alır sanki ama denemekten zarar gelmez sanırım.  Bugünlük bu kadardı.",
        "16": "75. Gün",
        "17": "Dün bir önceki görevdeki ana eksikler tamamlandı. Hâlâ daha eksikleri mevcuttu fakat onlara henüz çözüm getiremedim. Ama ilerleme kaydettiğimi düşünüyorum. Çok farklı bir şeyler üstüne düşünmemiştim bir yerden sonra. O yüzden biraz farklı konular da araştırdım. Sonra geri dönüp tekrar baktım ama yine olduğu kısımda kaldı. Yarın tekrar bakmaya devam edeceğim farklı bir görev verilmediği sürece. ",
        "18": "76. Gün",
        "19": "Bugün biraz karışık ilerledim. Sabah 2. göreve tekrar bakıp ufak düzeltmeler yaptım. Sonrasında sizin verdiğiniz görev tamamlandı. Başta dediğiniz gibi hardcoded'dı ve ve sonrasında düzeltince sizin bize anlattığını mantığa uygun hâle yaklaşmıştı ama farklılık vardı. Siz anlattıktan sonra onu da anladığımı düşünüyorum. Sonrasında biraz Selenium nedir diye araştırma yaparken karşıma eskiden baktığım linklerden gargabe collector'ün ne olduğu ile ilgili bir stack overflow sayfası çıktı. Biraz da onu araştırıp notlar aldım. En yüzeysel şekilde ne işe yaradığını biraz anladım diyebilirim. Sonrasında ise sizin boş zamanlarınızda bakmamızı söylediğiniz PDF'e dönüp okudum. Saat 8'den sonra da tekrar 2. göreve dönüp parantez açmadaki problemlerimi düzeltmeye çalıştım. Maalesef ama maalesef hâlâ daha problemleri devam etmekte. Tam yaptım diyorum sonrasında birkaç farklı şekilde test edince yine istenmeyen sonuçlarla karşılaşıyorum. Hep çözümün çok yakınlarında gezip ona ulaşamadığımı hissediyorum. Belki de hislerime güvenmekten öte, neden sonuç ilişkilerini iyi kurup programın işleyişini daha iyi incelemem gerekiyor. ",
        "20": "Bugün en karmakarışık ilerlediğim gündü sanırım. Enteresan şekilde kafamın çok karıştığını hissetmedim. Ve bir şeyden eminim: bir şeyi programlamaktan (ya da bunun için çabalamaktan) gerçekten büyük keyif alıyorum. Umarım hep böyle devam edecek. ",
        "21": "Günü, kendime hep öğütlemeye çalıştığım sözlerden biriyle kapatmak istiyorum:",
        "22": "\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\"",
        "23": "77. Gün",
        "24": "Bugün tekrar 2. görevimiz üstüne çalıştım. Daha önce bulduğum temel hataları düzelttim. Daha az hatalı sonuçlar elde edebildim bu sayede fakat kodun kalitesini biraz düşürmüş olabilirim. Onunla ilgilenmekten çok çözüm odaklı baktım bir süre sonra. Sonrasında tekrar iyileştirmeler yapabilirim. Parantez açma ve kapamalarda mysql fonksiyonunun parantezi dışında bir sorun yer almıyor test ettiğim kadarıyla. Sonrasında üstüne yeni şeyler geliştirmekte zorlandığımı ve üretkenliğimin azaldığını hissedince ilgimi boş zamanlarımızda okumamızı söylediğniiz PDF’e yönlendirdim tekrar. En büyük ortak bölenin nasıl bulunduğu ile ilgili bir örnek vardı. Buna yüzyıllar önce Öklid’in geliştirdiği algoritma ile bir çözüm sunulmuştu. Biraz da internette araştırarak benzer matematiksel örnekleri, daha da hayran kaldım. Programlama ve programlama dilleri ile ilgili en temel bilgilerin verildiği giriş kısımlarını bitirdim. Kitapta şimdi C diline geçildi ve orada kaldım. Yine boş kaldığım vakitlerde o PDF’teki konulara çalışmaya, öğrenmeye devam edeceğim.",
        "25": "78. Gün",
        "26": "Bugün o PDF’in çoğunluğunu okudum, anlamaya çalıştım. Genel olarak C dili ile programlamanın nasıl yapıldığını, programlama temellerini anlatıyordu. Örneklerin birçoğuna baktım ama zaman kaybettirecek gibi olanlara bakmamayı tercih ettim. PHP ve Javascript’i şimdiye dek gördüğümüz kısımlar içerisinde hatim ettiğimiz için C’ye bakarken biraz şaşırdım aslında. Sebebi şuydu: örneğin memory yönetimi pointer kullanılarak kullanıcıya devrediliyor. PHP ve Javascript’te böyle bir şeyle hiç karşılaşmamıştık. Ya da numaralandırma kısmına bakınca şaşırmıştım. Bunun PHP ve Javascript te de yapılabilme şekilleri olsa da C’de daha ayrıntılıydı ve üstüne düşülmüştü. Ve object-class ilişkileri şimdiye dek en çok üzerine durduğumuz konulardı bugüne kadar. Fakat her ne kadar C’de de polymorphism ve inheritance’ın uygulanabilirliği söz konusu olsa da (stack overflow’da okuduklarıma göre) block yapılı bir dil olduğu için (bunun anlamını henüz tam kavramadım) OOP’nin uygulanması biraz zoraki göründü. Aklımda bazı soru işaretleri kaldı hâlâ daha (konunun cahili olduğum için olabilir) : örneğin Python ve Java gibi dillerin hem derleme hem yorumlama yönteminin pozitif yanlarını alarak çalıştıklarını okudum. Eğer böyle bir şey mümkünse neden şu an sadece derleme ya da yorumlama ile çalışan diller var biraz ona şaşırdım. Ama bunun cevabını basitçe google’a sormak yerine biraz daha soru işareti olarak kalmasını ve düşünmemi istedim. ",
        "27": "Sizin bugün konuşmalarınızda “axios” kelimesini duyunca hemen aklıma Node.js kullanarak sunucu taraflı yaptığımız ufak çalışma geldi. “axios”un ne olduğuna tekrar bakarken react.js ile bir yerde karşılaştım ve biraz göz attım. Gerçekten hep bilmediğim ve öğrenecek çok şey olduğu için gözlerim ışıldadı. Kendi sitesindeki gördüğüm demolarda class yapısının kullanılarak client-side bir şeylerin geliştirilebildiğini (içinde bolca div ve diğer elementlerin bulunduğu), javascript’in farklı kullanım şekilleri ile karşılaştığımı görünce mutlu oldum sebebini bilmediğim bir şekilde.",
        "28": "Sanırım bu hafta boş bırakılınca bizim ne yaptığımıza bakmak istediniz ya da yoğun olduğunuz için serbest bıraktınız biraz. Gerçi her zaman bir görev verilebilir. En son üstüne çalıştığım görevde her ihtimali düşünerek bir şeyler yazmaya çalışmak gerçekten uzun zaman alacak gibiydi. Ve mantığını bir nebze çözebildiğimi, bir şeyler yapabildiğimi düşündüğüm için orada bıraktım. Ama query builder geçen hafta nerede bıraktıysak orada kaldı. Onu bitirememek hâlâ aklımın köşesinde kaldı. Ama tam anlamıyla bitirmek biraz daha zaman alacak gibiydi. Ama o görevler sayesinde farklı farklı bakış açılarını kazanabilmiştim her problem karşıma çıktığında. Bulabildiğim sorunlara çözüm getirmeye çalışmak ve bir kısmına getirmek de çok memnun etti. Kodlama becerimi daha çok kod okuyarak, yazarak, ve tabii ki hepsinin varoluş amaçları ile mantığını anlayarak daha da geliştireceğime inanıyorum. ",
        "29": "Bazı zamanlar çok problemle karşılaşıp çözüm üretmeye çalışıyorum. Bulamadığımda ya da yanlış yaklaşımlarım olduğunda siz ve google sayesinde yanlışlarımı düzeltebiliyorum.Bazı zamanlarda ise okuduğum her şeyi anlıyormuşum gibi hissediyorum fakat bu bana yanlışmış gibi geliyor. “Hayır Buğra, kesin bir şeyi kaçırdın. Anlamış olmamalısın” diyorum. Bugün o PDF’e bakarken bolca kendime, “ tamam çözdüm bunu” dedim bol miktarda. Birçok yerde sadece bilgilerimi pekiştiriyorum gibi hissettim. C ile alakalı konularda syntax farkları, varlıkların kullanılış biçimindeki farklar, ve yorumlanan dillere göre farklarını görünce onları araştırdım biraz. C’de bir kod yazmayı denemediğim için sanırım böyle demiş de olabilirim ama gördüğüm kısımlar için konuşacak olursam biraz zaman alsada halledebileceğimi düşünüyorum. Bugünlük bu kadardı.",
        "30": "79. Gün",
        "31": "Bugün verilen görevi yapmadan önce bol bol farklı sitelerde benzer örnekleri incelemeye çalıştım. İnceledim diyemiyorum çünkü benzerini örnek alabileceğim güzellikte bir site bulamadım. Verilen problem şuydu: Bayi ve yazıcı sistemi için başvuracak kişilere ithafen bir sayfa hazırlamak. İki durum için tek bir sayfa olmalıydı. Bir sayfa içinde iki farklı sekme olursa sayfanın karışıklığı ve uzunluğu azalır diye düşündüm. Default olarak bir sekmenin başlangıçta açık olarak gelmesi gerekir bu düşünceyle. Yayıncı insan zaten bilgisayarla oldukça haşır neşir olduğu için, bayi sistemi default olmalı diye düşündüm. Peki içerikte ne olmalı? Bayi olmak için başvuracak birey bilgilerini bize bir şekilde ulaştırmalı. Bunun için de iletişim adresi verebiliriz ya da kullanıcıdan istediğimiz verileri form aracılığı ile alabiliriz. Peki kullanıcı bayi olmak istiyorsa, bu linke kadar geldiyse neden tercih etmesi gerektiğini biraz süslü bir dille anlatıp ikna etmek iyi olmaz mı? Bence olur. O yüzden sitenin (şirketin) temel özelliklerinden birkaçını sayısal olarak sunmak (kaç yıl sektörde bulunulduğu, kaç firmanın yetkili satıcısı olduğu, yetkili satıcısı olunan firmaların ürünlerinin sektördeki genel hacmi, vb) verilebilir diye düşündüm. Özetle iki şey düşünebildim: Kullanıcıyı ikna etmek, gönül rahatlığı ve istekle ile bizimle iletişime geçmesini sağlamak. ",
        "32": "Akşam mesai sonrasında ise önsöz, teşekkür kısımlarını dahi okuyarak, bazen de sapıkça kitabı koklayarak (ilk alınan kitap kokusu (sayfaların iç kısmı)) başladım. Big O notasyonunun ne olduğuna kadar geldim. “Giriş kısmını okuyarak zaman kaybediyorum” düşüncesi olsa da bilgisayarın, hesaplamanın makine ile yapılmasının tarihini okumak güzeldi. Charles Babbage’dan Alan Turing’e, John Mauchly’nin çabalarından ve bolca fikirlerinin  çalınması ya da üstüne konulmasından Apple’a, tarihte ilk programcının hep erkek olduğunu farzeden cinsiyetçi idrak yeteneğimi Ada Lovelace’ın kırmasına kadar çokça şeyle karşılaştım. Sanırım yazmaya devam edersem rapor, rapor niteliğinden çıkabilir çünkü sonrasında Ada Lovelace’ın Lord Byron’un kızı olduğunu, Lord Byron ayağı sakat halde Çanakkale Boğazını yüzerek geçtiğini, Don Juan’ı yazdığnıı ve Albert Camus’nun Sisifos Söyleni kitabında Don Juan hakkındaki çıkarımlarına kadar gideceğim. Uyku zamanı geldi. ",
        "33": "Yarın görevi bitirmeye çalışacağım. Yeni şeyler deneyerek bir şeyler yapmak istediğim için biraz zaman alıyor. Sadece eski öğrenmiş olduğum şeyleri tekrar edersem elbette daha kısa sürer fakat kendimi zorlamak istiyorum yeni şeyleri de kullanabilmek için. Deneyeceğim.",
        "34": "80. Gün",
        "35": "Bugün tamamen CSS ve biraz da Javascript ile geçti. Bir şeyler yaptım fakat pek içime sinmedi. Kendim, “tamam işte, bu oldu” diyemedim. Oysa ki kargolu ürünler tasarımında diyebilmiştim. Yine de üstüne düşünülse daha da iyi şeyler yapılabilir. ",
        "36": "Bugün bayi sisteminin form kısmı ve yayıncı sisteminin tasarımı gerçekleştirildi. Ekstra bir kütüphane kullanılmadı. Sadece Google Charts’tan yararlanıldı ama basitçe resim dosyası haline çevrilebilir. Yayıncı kısmında renkler ve düzen tam oturmadı. Responsive’liğe dikkat edilmeye çalışılsa da sayfa küçültüldüğünde bozulmalar oldukça fazlaydı. Elle tutular sonuçlar elde edildi fakat istenen düzeye gelmedi."
    },
    "part9": {
        "1": "81. Gün",
        "2": "İlk defa kendi açımdan responsive’liğe uyduğunu düşündüğüm bir tasarıma yaklaştım. Konu CSS olunca biraz sihir gibi hissetmiyor değilim, her ne kadar kurallara uyulduğu sürece istenilen çıktıları vereceğini bilsem de. Bugün toplantıda konuştuğumuz konular tekrar bazı konuları düşünmeme ve farklı açılardan bazı problemleri düşünmeme katkı sağladı. Ve gerçekten zamanın o esnada nasıl geçtiğini ve ne kadar zaman geçtiğini farketmemiştim. Gün sonuna doğru farklı farklı CSS örneklerine baktım tekrar. Mesela SCSS’in CSS’e çeviren online formatter’larda varmış bunu bilmiyordum. Codepen’deki birçok güzel tasarımda SCSS kullanılıyordu ama onları direkt es geçiyordum kullanmayıp ve dikkatle incelemeyip. Artık onun da bir kısayolunu öğrenmiş oldum eğer işime yarayacaksa.  Bugün genel olarak tasarımı güzelleştirmeye çalışmak ve arta kalan zamanlarda benzer konuları, örnekleri araştırmakla geçti. ",
        "3": "82. Gün",
        "4": "Bugün de CSS ile geçti. Daha çok, farklı neler yapabileceğim üzerine düşündüm. Farklı tasarımlarda güzel görünen kısımları kendim de uygulamak istedim bazen ama o güzel görünümü sağlayamadım. Birinci tasarımda elimden geldiğince özgün (örnekleri birçok yerde olan uygulamalar tabii ki ama bütün olarak bakınca böyle görünebilir) ve sade bir içerik üretmeye çalıştım. İkinci tasarım hâlâ daha gün sonuna doğru şu aşamada kaldı: “Deftere eskizlerini çizme aşaması”. Amaç sadece hızlı olmak olsa üstüne çok az düşünüp bir şeyler çıkarıbilir. Amaç mükemmel bir görünüm çıkarmak olsa uzun zaman sürer fakat oldukça iyi bir tasarım oluşturulabilir. Ama amaç aradaki dengeyi koruyabilmekte sanırım. Yani zaman ve kalitenin trade-off’unu doğal bir şekilde oturtabilmek kafada şu an. Ve bizden ikinci kez tasarım istemenizi iki şeye bağlıyorum: Daha iyisini yapmamızı istemeniz ya da farklı açılardan bakmanızı istemeniz. Ben de her iki vardığım sonuca göre bir şeyler çıkarmak istiyorum.",
        "5": "Mesai saatleri sonrasında iki şey yaptım: Ülke ekonomisini, gündemini, insanların konuştukları konuları görüp moralimi bozdum. Sonra da algoritma kitabında kaldığım yerden okumaya devam ettim. Henüz kitabın en başlarındayım. Yüzyıllar önce Arapların ve sonrasında Rusların geliştirdiği çarpma algoritmalarını gördüm. Yarın da Karatsuba’nın çarpma algoritması ne imiş ona bakacağım akşam. Bu hafta kitabın giriş kısmındaki basit algoritmaları bitirmek amacım. Hızlıca biterse ikinci bölüme devam edeceğim (Bence geçerim ve ilerlemeye devam ederim). İlginç bir şey farkettim: Mısırlıların sayı sisteminde, “1,10,100,1000, hatta 1 milyon” sayıları bulunuyor. Düşündüm, Mısırlıların olduğu devirde 1.000.000’u kullanacak kadar ne yapmış olabilirler diye. Elbette piramitler (mühendislik), sağlık, astronomi gibi alanlarda çok gelişmişlerdi. Hatta vergi sistemi ve askerlikle alakalı şeyler dahi olabilirdi. Ama ben 3000 yıl önce yaşasam 1 milyon sayısını hiç kullanmazdım herhalde bir çölde diyerek şaşkınlığımı düşünürken gizleyemedim.  Belki de öyle bir sayıyı hiç kullanmadılar ama bizim “sonsuz ya da belirsiz” ifadelerimiz gibi bir şeydi onlar için. Gerçi bu fantastic düşüncem İskenderiye Kütüphanesindeki 900.000 civarı el yazması kitabın varlığı ile yıkılabilir gayet. O kadar çok kitaba ev sahipliği yapan; Öklid, Arşimet, Batlamyus gibi devlerin içinde çalıştığı kütüphaneyi bile kurmuşlarsa kesinlikle bir yerlerde de o sayıya ihtiyaç duyup kullanmışlardır.",
        "6": "Öğrendiğim algoritmaları hobi olarak sadece javascript ile programlamayı ya da işin içine görsellik katıp HTML ve CSS ile de zenginleştirebilirim. Ama bunlar ana görev değil sadece hobi amaçlı yapılabilecek şeyler olmalı.",
        "7": "Ülke gündemi, olumsuz “enformasyonlar” gibi bunaltıcı konuların ötesinde “hobi” gibi yaptığım (ve yapacağıma inandığım) bir işim olduğundan dolayı mutluyum.",
        "8": "83. Gün",
        "9": "Bugün kendimi biraz kötü hissettiğim için (sanırım üşüttüm) çalışırken biraz zorlandım. Kafamın içi çok dolu ve ağırmış gibi bir his gün boyu hakimdi. Gün sonunda ortaya çıkan tasarımımı beğenmedim. Evet yerine göre responsive bir tasarım oldu. Evet her şey yerli yerinde oldu fakat o kadar karışıktı ki sonuca baktığım zaman gözüm kanadı. Daha iyi nasıl hale getirebilirim onu düşünmeliyim. Açıkçası birinci tasarımın sadeliği hoşuma gittiği için bu kadar karışık birçok kutunun dip dibe olması hiç hoşuma gitmedi. Bardağa çok boş tarafından baktım sanırım fakat içimden gelen düşünceler bunlardı. Çok daha iyisi yapılabilir inanıyorum.",
        "10": "84. Gün",
        "11": "Dün yaptığım tasarıma bugün ne kattım? Parallax kullanılan fotoğrafın genişliğini azaltıp, bayi sistemi ve yayıncı sistemi aynı sayfa içinde olduğu için onlara sayfa içinde erişimi sağlayan iki tane navigator düğme ekleyip, gördüğüm eksik kısımları düzelttim. Açıkçası çok bir yenilik katamadım. O yüzden hep farklı siteleri inceleyip neler yapabilirim onu düşündüm. CSS'in bilmediğim özellikleri nelermiş onları araştırıp öğrenmeye çalıştım. Bol bol Codepen ve kaynakça niteliğindeki sitelerden tasarım konusundaki örneklere ve araştırmalara baktım. ",
        "12": "Güneş battıktan bir süre sonra yapılanlar üzerine",
        "13": "Algorima kitabına tekrar baktım. Kitaptaki çarpım algoritmalarını kavradım. Karatsuba algoritması özetle 14 hane ve üstü sayıların çarpımında daha etkili çünkü işlem sayısını oldukça kısaltıyor. Ama daha az hanesi bulunan sayılar için elverişli değil. Sonrasında bilgisayar çarpma işlemi için hangi algoritmaları kullanıyor diye baktım fakat mikroişlemcilerin kullandığı Booth’un algoritmasını öğrenmek biraz vaktimi alabilir diye sadece göz gezdirdim. Detaylara ve ALU gibi konulara girmedim.  Öğrendiklerim biraz arttıktan sonra koda dökmeye çalışacağım. Kitapta sadece bugün eski konuları tekrar edip biraz da roma rakamları ile ilgili algoritmaların başlangıcına baktım. ",
        "14": "Sonrasında biraz Pi sayısı üstüne biraz okumalar yaptım. Daha da yapacağım fakat tahminimce modern fizik konularına da bakmam gerekecek. Bu kendim için de faydalı olabileceğinden (spor gibi, sadece tek kas sistemini çalıştırmak yerine vücuttaki tüm kas sistemlerini dengeyle çalıştırıp hepsini güçlendirmek gibi belki) bakarım diye düşünüyorum.",
        "15": "Dün olan zihin yorgunluğu bugün çok şükür yoktu ve verimli geçti gibi hissettim, ürün olarak çok verimli sonuçlar olmasa da.",
        "16": "85. gün",
        "17": "Günlük rapor tutmaya başlayalı 3 ay olmuş neredeyse. Aslında bunu severek yapıyorum. Mühendislik okumak ile bir alakası olduğunu sanmıyorum fakat kendimi hep bir mecrada ifade etmeyi, anonym olarak günlük tutmayı çok severdim. Şimdi de günlük tutma kısmını teknik bir dille harmanlamaya çalışıyorum. ",
        "18": "Bugün CSS’e baktım tabii ki. Farklı şeyler deneyebilir miyim diye düşündüm. Bazı denediklerimi beğenmeyip sildim. Bugün, dün gördüğüm en büyük iki soruna (firma fotoğrafları ve websitemiz hakkındaki metin içeriği) çözüm üretmeye çalıştım genel olarak.",
        "19": "86. Gün",
        "20": "Bugün biraz karışık ilerledim. Sabah sadece algoritma kitabına baktım. Veri yapıları kısmına kadar geldim. Sonrasında sizin görev için düşünmeye başlamamızı söylemenizle çok farklı konulara girdim biraz. Scrum, agile, extreme programming gibi konularda okumalar yaptım. Günün sonlarına doğru OOP ve e-ticaret sitesi oluşturmakla ilgili farklı kaynaklar buldum. Yarın sabah ilk işim onlara bakıp farklı fikirler edinmek olacak.",
        "21": "Bugün biraz ateşimin çıktığını hissettim ve çok kırgındı vücudum o yüzden pek verim alamadım. Acilen kendimi toplamam gerekiyor. Sabah erken uyanabilirsem eczaneden C vitamini olan bir şey alabilirim (ne kadar çok işe yaramayacağını bilsem de).",
        "22": "87. Gün",
        "23": "Sitede neler olması gerektiği üstüne kullanıcı, site admini, ve satıcı gözünden hikayeler oluşturup gerekli modülleri ve alt sınıfları, metodları belirlemeyi düşünüyordum. Toplantı sonrası ise sadece bize telefon satmak için e-ticaret sitesi kurmak isteyen bir müşteri ile iletişim, onun benimle iş yapması için ikna edebilmem, işin detaylandırılması, projenin fiyatlandırılması ve süresi gibi konularda nasıl bir yol izleyeceğim, nasıl bir rapor oluşturacağım onu düşündüm. Bol bol araştırdım. Tam istenilen yapıyı bulamadım açıkçası. Ama bana yardımcı olabileceğini düşündüğüm yapılar buldum. Onlar üstünden giderek pazartesi günü raporu istenen şekilde teslim etmeye çalışacağım.",
        "24": "88. Gün",
        "25": "Bugün müşteriyle iletişimimin ve bilgi alışverişinin en temelini inceleyip, buna göre bir doküman hazırlamaya çalıştım. Benden bir websitesi tasarlamamı isteyen bir müşteriden hangi bilgileri temel seviyede almam gerektiğini öğrendim. Bir web sitesi hazırlanırken sunulan seçeneklerin ne olduğunu gördüm. Fiyatlara ve süreye sadece tahminle ulaşabildim. İnternette hazır paketlerle sunulan website tasarımları ve “iş yaptırmanın” bedelleri her ne kadar olsa da spesifik bir iş için ne kadar ücret alınır bunu tam bilmiyordum. Süre olarak çeşitli zaman aralıklarını görmüş olsam da genelde 4-16 hafta arasında biteceği söyleniyordu bulduğum farklı kaynaklarda. Bu tamamen gelecek olan iş ve yapacak ekip ile alakalıydı. Yarın tam olarak ne yapacağımı tam olarak bilmiyorum fakat Cuma günü üzerine çalıştığım konu ilerideydi ve yarın ona bakabilirim diye düşünüyorum. İlk işi teslim alma aşamasından sonra (eğer alabildiysem) sistemi tasarlama aşamasına yaklaşıyorum gibi hissediyorum. ",
        "26": "Akşam olduğunda Algoritmalar kitabını kaldığım yerden okumaya devam ettim. Özyinelemeler konusuna geldim. Temellerin anlatıldığı bölümü bu hafta bitirebileceğimi düşünüyorum. Temel olarak veri yapılarından kısaca bahsedildi ve bahsedildiği kadarıyla anladım.  Özyinelemelerden sonra rastgele sayı üretme algoritmaları karşıma çıkacak. Bu hafta tamamlamam gerektiğini kendime şart koştum. Üstüne de kendim problemleri tekrar ele almaya çalışacağım 2. bölüm tamamlanınca. Hem gün içi görevleri, hem de bunu halledebilirim diye düşünüyorum.  ",
        "27": "89. Gün",
        "28": "Bugün tamamen araştırma, yapılan örnekleri inceleme, ve kendi raporum için oluşturacağım outline’ı düşünmekle geçti. Evet elde somut bir sonuç şu an yok ama birçok örneği inceleme fırsatım oldu. Ve bu yüzden geçen zamanın değersizleştirildiğini düşünmüyorum. Buna da ihtiyaç olduğunu düşünüyorum. Yarın somut olarak bazı çıktıları ele almaya başlayacağım. Verilen süre içerisinde tamamlayacağıma inanıyorum görebildiğim her ayrıntıyı raporuma ekleyerek.",
        "29": "90. Gün",
        "30": "Neden Agile?",
        "31": "Waterfall modelinin sorunu, problemi ele alış ve çözüm biçiminde. Neydi bu? ",
        "32": "Tüm gereksinimler müşteriden toplanır.",
        "33": "Bir ekip bu gereksinimleri ve dokümanları analiz eder ve dizayn ekibi için spesifikasyonları, özellikleri hazırlar.",
        "34": "Dizayn ekibi bu spesifikasyonları kullanarak dizaynlarını gerçekleştirirler ve ve uygulamaları için yazılım geliştirme ekibine verirler. Geliştiriciler de bu dizayna göre kodlarını yazıp son halini test ekibine gönderirler ve işlem tamamlanır. Ürün müşteriye teslim edilir.",
        "35": "İstatistiklerin genel olarak söylediği şey de, waterfall modeliyle çıkarılan işin genel olarak müşteri tarafından kabul edilmediği ya da beğenilmediğidir. Ve müşteri her zaman haklıdır bilindiği üzere.Bu yüzden projeye verilen tüm emek, zaman, para boşa gitmiş olur böyle bir sonuçla karşılaşılırsa.",
        "36": "Bu soruna başka bir felsefi yaklaşım daha vardır: yinelemeli ve evrimsel (iterative and evolutionary) geliştirme. Scrum, XP, Rational Unified Process bu felsefi yaklaşımla yazılım geliştirmeye örnektir. Agile development process olarak da geçerler.",
        "37": "Yinelemeli (iterative) geliştirme kavramı basittir.Yazılım geliştirme, yineleme (iteration) adı verilen bir dizi küçük proje halinde düzenlenir. Her yinelemenin kendi analizi, tasarımı, uygulaması, ve testi vardır. Her yinelemenin (iteration) sonunda müşteri girdisi alınır. Yani müşteriye de o iterasyon izah edilerek dönüşü sağlanır. Eğer müşteri beğenmediyse ya da kabul etmediyse o iterasyonu, sadece o kısım tekrar düzeltilir. Bu sayede waterfall modeline kıyasla çok daha az kayıpla süreç tamamlanabilir.",
        "38": "Kısacası Agile geliştirme yöntemlerinin varoluş sebebi, kutsal dinlerin (kutsal olmayanlar ne diyor pek bilmesem de) de söylediği gibi \"israfı en aza indirgemek\"tir.",
        "39": "Bunları yazma sebebim: hem benim için notlarıma geri döndüğümde elimde kısa ve öz olarak anlayabileceğim bilgilerin olması hem de başlamış olduğumuz çalışmanın özündeki mihenk taşlarından biri olması.",
        "40": "Benim yazılım geliştirmeden anladığım şuydu: Her şeyi en baştan kusursuz bir şekilde tasarlayacağım. Sonrasında kodlayıp bu mükemmelliği izleyeceğim. ",
        "41": "Oysa bu iterasyonlu modelde bahsedilen bu değildi: Tasarımımı değiştirmem gerekebilir. Başta kusursuz gibi görünen analizim ve dizaynım berbatsa bunu düzeltebilmeliyim. Sil baştan her şeye başlamamalıyım. Ve dedikleri gibi kusursuz bir tasarım sadece bir efsanedir belki. Ki öyleymiş.",
        "42": "Bilgiler edindiğim kaynaklarda ayrıca şunlara ulaştım: Başlangıçta tüm gereksinimler için tasarım yapılmamalı. Üzerinde çalışılan yineleme için ayrıntılı bir tasarım yapılmalıdır. Büyük resme bakmadan küçük detayları bu şekilde tasarlamak şu aşamada bana pek mantıklı gelmedi ama bu bakış açısını da beynimde bir yerlere kazımaya çalışacağım. Ama onların dediklerine de katılıyorum: \"Tasarladığınız her şey mükemmel değildir ve projenin yaşam döngüsü boyunca değişecek veya gelişecektir.\"",
        "43": "Şimdi neden Agile bir yöntem kullanılması gerektiği anlaşıldı. Peki neden nesne yönelimli analiz, dizayn, ve programlama kullanılıyor ve kullanacağız?",
        "44": "Neden Object Oriented?",
        "45": "Yapacağımız projeye, programlama diline çok hakim olabiliriz. Gerçekten de çalışan ve müşterinin beğeneceği bir ürün de çıkarabiliriz nesne yönelimli programlama olmadan. Ama kodun küçük bir bölümden yapılacak ufak bir değişimle her şey çok zorlaşabilir ve ürünün sürdürülebilirliği kaybolur. Nesne yönelimli dizayn ve programlamada bize sunulan \"modülerlik\"tir. Modülerlik bize kodu güncellemede, okumakta büyük kolaylık sağlar.",
        "46": "Nasıl Bir Analiz ve Dizayn?",
        "47": "Nesne yönelimli analizde ilk adım müşteriyi dinlemek. Müşterinin problemlerini dinlemeliyiz ki çözüm üretebilelim. Bir iteration da bir veya iki kullanıcı hikayesi ele alınmalı. Tüm hikayenin yüzde 10'undan fazlasını tek bir iteration da ele almamamız tavsiye edilir genelde. Sebebi Agile'ın varoluşuna aykırılığı içermesi aslında.",
        "48": "Müşteri hikayesini dinledikten sonraki adım, bu hikaye ile domain model'i dizayn etmektir. Bunun basit bir yolu şu: kullanıcı hikayesini dinle ve isimlerin altını çiz. Bu isimler, gelecekteki potansiyel sınıflarımızı gösterir ve domain model'e eklenir. Domain model' de basitçe sınıfların isimleri ve attribute'leri (nitelikleri) tanımlanır. Sınıfların davranışları (behavior'ları) domain model' e dahil değildir.",
        "49": "Bu kısmın özeti:",
        "50": "Müşteri/kullanıcı hikayesini dinle.",
        "51": "Domain model'i tasarla.",
        "52": "Yani analizin amacı, müşteri/kullanıcı hikayesinden domain class'ları elde etmek; dizaynın amacı ise kullanıcı hikayesine dayanan domain model'deki objeler arasındaki ilişkiyi kurmaktır. Dizayna ek olarak, nesne yönelimli programlama için oluşturulmuş bazı prensipler (SOLID gibi) ve tasarım kalıpları (Gang of Four'un yazdığı) bulunur. Bunları da sınıflarımızı oluştururken göz önünde bulundurmalıyız.",
        "53": "Nesne yönelimli analizin 3 aşaması:",
        "54": "Sınıf isimlerini tanımla",
        "55": "Sınıf niteliklerini (attributes) tanımla",
        "56": "Sınıflar arası ilişkiyi (association) tanımla",
        "57": "Nesne yönelimli dizaynın 3 aşaması:",
        "58": "Her senaryo için sequence diyagramı oluştur",
        "59": "Sınıf diyagramı dizaynını oluştur",
        "60": "Tasarım kalıplarını ve SOLID (bunu öğrendiğim için, yoksa farklı prensiplerden de faydalanılabilir) prensiplerini uygula",
        "61": "Pazartesi sabah son teslimi olan görevi 4 parçaya ayırdım: ",
        "62": "Use case'leri belirle, kullanıcı/müşteri hikayesine göre",
        "63": "Domain model'i oluştur",
        "64": "Interactions(sequence) diyagramlarını oluştur",
        "65": "Sınıf diyagramlarını oluştur",
        "66": "Bugün birinci aşamadaydım. Aklıma gelen her kullanım durumunu kullanıcı ve admin için oluşturmaya çalıştım. Bazı yerlerde üçüncü bir aktör olarak sisteme de ihtiyaç duydum. Bazı kullanım durumları çok temelken, bazıları çok daha spesifikti. Benim bu birkaç günde öğrendiğim en büyük şey \"modülerliği sağlamanın ve nesneler arası ilişkileri iyi bir şekilde oluşturmanın en temel amaçlar olduğunu öğrenmek ya da bu bilgileri tekrar etmek\" oldu. Sadece aklıma 1 günde gelen kullanım durumlarını not aldım ve bunlar bile bir hâyli fazlayken aralarındaki ilişkileri nasıl düzenleyeceğim henüz bilmiyorum. Ama yarın her kullanım durumuna göre domain model'ler oluşturmaya çalışacağım. Birbiriyle bağlantılı kısımlarda neye göre modüller veya \"modüler bir yapı\" oluşturacağımı henüz hiç bilmiyorum. Bilindiği üzere de asıl problem ve çözmem gereken de bu. Tek istediğim yarın oldukça çok ilerleme kaydetmek yoksa proje teslim tarihine kadar zorlanacağımı hissettim.",
        "67": "Biraz daha işin kitabını okuyup, sonrasında uyuyacağım. "
    },
    "part10": {
        "1": "91. Gün",
        "2": "Dün kullanım durumlarını oluşturmuştum ama çok karışıktı. Bugün biraz daha düzenleyip temize çektim bilgisayar üstünde. Hâlâ daha domain model’I oluşturmadım o yüzden. Yarın onu kesinlikle bitirmem, hatta sequence diyagramlarını da tamamlamam gerekiyor. O yüzden bugün uykumu iyice alıp yarın kaldığım yerden devam edeceğim. ",
        "3": "92. Gün",
        "4": "Toplam 11 tane kullanım durumu oluşturdum. Bugün sadece 1 tanesinin domain class model'ini, sequence diyagramını, ve son olarak class diyagramını oluşturdum. Eksik, hatalı kısımları olabilir ama elimden geldiğince iyi yapmaya çalıştım. Yarın kalan 10 kullanım durumunun hepsini ilerletemeyeceğime göre sanırım pazar günü de tam gaz çalışmaya devam edeceğim. ",
        "5": "93. Gün",
        "6": "Bulunduğum projede yapacak olduğum  görevin süresini nasıl tahmin edebilirim bilmiyordum. Çünkü ilk defa öyle bir şey yapacaktım. Eğer matematiği hiç bilmeyen bir insansam 1+1’in 2 olduğunu ne kadar zamanda hesaplayacağımı varolan bilgilerimle tahmin edemem. Ancak uydurabilirim. Ama daha önce bu hesaplamayı ya da buna benzer bir hesaplamayı yaptıysam daha gerçekçi bir tahmin oluşturabilirim. Eğer ben bu hesabı yapmadıysam nasıl tahminde bulunabilirim? Tekerleği tekrar icat etmeyerek tabii ki de. Ben tekerleği tekrar icat etmeden bu zaman problemine uygun bir çözüm getirmek istedim ama farklı insanların sunduğu zamansal verileri bulamadığım için, açıkçası en başta proje süresini mantıklı olmaya çalışarak uydurmuştum. 1 hafta sonrasında kendi tecrübeme dayanarak projenin bir kısmını ne kadar sürede bitirebileceğim hakkında fikir edinebilmiştim. Sonrasında ona göre bir tahminde bulundum fakat bu tahmini oluştururken kendim için en az riskli şekilde oluşturmaya dikkat ettim. ",
        "7": "Son gün öğrendiğim şey şuydu: Ne kadar sürede biteceğini bilmediğim ve tamamlamam gereken bir proje önümdeyse eğer, öncelikle o proje hakkında araştırma yapmam gerekli. Daha önceki tecrübelerim, farklı insanların tecrübeleri yardımcı olabilirse tahminimi yüksek doğrulukla oluşturabilirim. Eğer yoksa projeyi daha ufak kısımlara ayırıp, referans (ben ya da başkası) bulabileceğim kısımlar için bir tahmin oluşturabilirim. Bu henüz aklıma geldi açıkçası. Bilinmeyen kısımları ise projeyi bana ileten kişiye iletip, doğrulukla varolan durumu anlatırım.",
        "8": "Bazen karşıma çıkan problemle oynamayı ve basitçe bir yaklaşımla onu çözmeyi çok severken, bazen de onu canavarlaştırabiliyorum. Bu da benim için ilerleme açısından zorluklara neden olabiliyor. Ne yaptığımın genelde farkında oluyorum ama canavar bazen çekici gelebiliyor ve beni daha da derine çekiyormuş gibi hissediyorum. Bu projede bunu birkaç defa hissettim. Ama onunla savaşırken her ne kadar yorulsam ve zaman kaybetsem de, yine de ben kârlı çıkıyorum diye düşünüyorum. Çünkü o gerçek değil. Ben ve benim ilerlemem ise gerçek. Sanırım çok gereksiz detaylara boğuldum. İnsan işte. Beyni gelişmiş sıradan bir canlı.",
        "9": "94. Gün",
        "10": "Bugün kaldığım yerden devam ettim. Ürün arama ve inceleme, ürünü sepete ekleme kısımlarının class diyagramı bugünün konusuydu. Yarın da iki-üç tane kullanım durumu için bu diyagramları yarılamış olacağım. Çarşamba günü de raporun detaylarını (sözel kısımlarını) tamamlarım diye düşünüyorum.",
        "11": "95. Gün",
        "12": "Günün başlarında kullanım senaryosunun sınıf diyagramına dönüştürülmesine bakıyordum. Sonrasında sürekli ve sürekli olarak nesnelerin iletişimini düşünüp dururken kendimce uçuk fikirler oluşturmaya başlamıştım. Nesneler ikili iletişim kuruyor ve bu ilişkiler metotlarla sağlanıyordu. Nesneler oluşturulurken güncel hayatla bağdaştırıldığı için (ayazılımda değil tabii ki), düşündüm ki neden bir nesne ona başka bir nesnenin temas etmesine ihtiyaç duyuyor mesajlaşma için? Bugün sinema salonunda fragmanı geçen bir filmde “Aradığın,seni arayandır” (tasavvufu örnek almamak lazım bu konuda belki ama aklıma gelince eklemek istedim) diye bir söz geçmişti. Benim bir nesneyi diğeriyle iletişime geçirmem için, onu araması gerekiyor. Diğer nesne ise aranmayı bekliyor. Bu biraz “zaten aranıyordu” gibi oldu ama öyle bir durum. Üçüncü bir nesne diğer nesnelerin konuşmasını dinlese ne olur diye düşündüm. Yani iki ya da daha çok nesne konuşurken onları dinleyen bir nesne. Nesneler sadece kendilerine seslenince iletişime geçiyorlar. Bana dokunmayan yılan bin yaşasın gibi. Aslında amaç da bu olabilir zaten şu anki kullanımda. Aksi durum (her şeyi duyan ve iletişime geçen nesneler)  procedural  yöntemde olan sanırım. Çok gereksiz hayaller kurdum bir yere varmayacak gibi hissettim. En azından hayal kurmak da önemli diye bu paragrafı sonlandırayım.",
        "13": "Daha sonra Actor Model’e baktım. Alan Key’in Quora hesabı varmış ve oradan birçok soruya yanıt vermiş. Bunu görünce çok fazla etkilendim çünkü gözümde masallardaki kahramanlardan  biri olmuştu. Actor Model’in OOP’den aslında çok da bir farkı olmadığından bahsetmiş. Aslında o ilk oluşturulan pure object oriented mantığı, sonrasında biraz daha class oriented’e döndüğü için; Actor Model’in pure OOP’ye güncel olarak kullanılan OOP’den daha çok benzediğini söylemiş. Sebebi ise mesajlaşmaya odaklanması anladığım kadarıyla. Eşzamanlılık konusundaki artısını anladım fakat pratikte görmediğim için sadece mantık olarak kavradım. Onun dışında Actor Model PHP’de de kullanılabiliyormuş sanırım. Peki neden şimdi Actor Model şu an kullanılan OOP yerine kullanılmıyor diye düşündüm. Bulduğum cevaplar vardı. Fakat tam anlamadım. Tek bağdaştırdığım nokta, şu an neden SmallTalk'un kullanılmadığı ile ilgili bir benzerlik olabilir. Tabii ki kullanılıyor bu arada, ayrık (mikroservis gibi. Sadece kavram olarak biliyorum. Detaylarını dair bir fikrim yok) sistemler için özellikle. Fakat  çok yaygın olmadığını anladım.",
        "14": "Sonrasında self reference class’lara baktım. Bu da mümkünmüş farklı yollar kullanarak. En dikkatimi çeken özelliği ise algoritmalara bakarken karşılaştığım linked list’lere benzerliği. Tıpkı linked list’ler gibi linked object’lerde oluşturulabiliyormuş. ",
        "15": "Bugün biraz fazla araştırmalara daldım açıkçası. Yapmam gerekeni de yaptım fakat bol bol da bu tür konuları araştırdım.",
        "16": "96. Gün",
        "17": "Bugün projedeki sözel kısımların hepsini tamamladım. Sonrasında daha önce yaptığım çalışmaları da dosyaya ekleyip tamamladım. Çok ama çok fazla eksik var farkındayım. Özellikle diyagramlar oluşturulurken resmen evrim geçirmiş gibiler. Çünkü öyle, gerçekten evrim geçirdiler. Yeni öğrendiğim şeyleri hep yeni oluşturduğum kısımlarda denemeye çalıştım. Bazı sınıfların nitelikleri yetersizdi bazıları da fazlalık içeriyor olabilirdi. Bunların üstüne yeterince düşünmeye başladığımda programlama mantığına çokça girmeye başlıyordum o yüzden biraz daha yüzeysel bıraktım. ",
        "18": "Gün sonunda İngilizceyi düşündüm. Benim de konuşma kısmında epey eksiğim var. Bunun sebebi yabancı dil konuşurken kelimeleri bulmakta sıkıntı yaşamam ve bence bu konu özelinde özgüven eksikliğim de var. Çünkü bir yabancıyla konuşurken çok rahat rahat oluyorken, bir türkle yabancı dil konuşmaktan hiç keyif almıyorum. Çünkü hep bir yanlışımı arayacakmış gibi geliyor ve bu yüzden alçakgönüllü normal bi insan değilse konuşmamayı tercih ediyorum Türkler özelinde. Neden İngilizceden bahsettim? İngilizce konuşmanın özündeki tavsiyeler, türkçe düşünmemek ve gündelik hayatta da çeviri yapmadan İngilizce konuşmaya düşünmeye çalışmak var. Bense gündelik hayatta karşıma çıkan şeylerin genelde kelime anlamlarını bilmediğim için hep bundan vazgeçiyorum genelde. Buna nasıl bir çözüm üretilebilir? Gündelik hayatta sıkça kullanılan kelimeler cümleler düşünülerek, o kelimeleri öğrenerek olabilir. Nesneler arası haberleşmede diyagramlar oluşturuluyordu. Bunun için de diyagram oluşturabileceğimi varsaydım. Ben makineye cümleyi türkçe söyleyeceğim. O ingilizce karşılığını bana verecek. Mesela Cortana veya Siri ile bir dilde konuşuluyor evet. Peki ya makine benim cümleme ingilizce karşılık verseydi? O kelimeleri özellikle bana belirterek ve beni konuşturmaya çalışsaydı. Bir nevi makine İngilizce öğretmenim olurdu. Elsa’daki gibi yanlış telaffuzlarımı  bana istatistik olarak sunabilirdi. Konuşmalarımızı metin şeklinde bana iletebilirdi. Dilersem okuyabilirdim. Burda biraz farklı teknolojilerden bahsettim. Hepsi tek bir noktada olmalı gibi. Belki böyle bir şey vardır da haberim yoktur. Kısacası İngilizce düşünüp konuşmaya yardım edebilecek bir uygulama düşündüm sadece. Çeviri kısmını translate ile ilgili bir API ile sağlayabilirdi. Fakat onun bana sorması gibi konularda yapay zeka devreye girerdi ki bu konuyu hiç bilmiyorum. Yine de üstüne düşünebileceğim bir konu gibi geldi.",
        "19": "97. Gün",
        "20": "Bugün ortaya karışık bir gündü. Mozilla Developer Network’te bol bol ilgimi çeken konuları okudum. Bir nevi tekrar yaptım aslında. Sonrasında Web sayafası yayınlamak ile ilgili yine MDN’de gördüğüm bir yazıda Github’ta static web sayfası oluşturmaktan bahsedilmiş. Bunu görünce biraz araştırayım dedim. Medium’daki bir yazıdan bu sayfaya Firebase API’si kullanarak veritabanı sağlanabileceğini öğrendim. Statik sitede sadece Javascript, HTML, ve CSS var normalde. Javascript’I kullanarak kullanıcıdan aldığım bilgiyi veritabanına çekmeye çalışacağım API yardımı ile. Ama henüz tamamlayamadım. Yarın boşluk olursa bakacağım. Eğer yapabilirsem burası arka bahçem ya da garajım olabilir diye düşünüyorum. En azından API nasıl kullanılır, NoSql veritabanına veriler nasıl gelir ve nasıl işlem yapılır, GIT nedir ve nasıl kullanılır, Github’ta proje oluşturmak ve GIT ya da Github Desktop ile projesi anlık olarak güncelleyebilmek gibi konuları öğrenmiş olurum diyorum. Haftasonu buna bakmayı düşünüyorum boş olduğum zamanlarda. Bugün biraz GIT’e baktım ama yabancısı olduğum için karışık geldi başlangıçta. O yüzden Github Desktop başlangıç için çok basit olduğundan onu kullandım proje güncellemeyi basitleştirmek için. Ama GIT’i de çözeceğim. Aslında Firebase ile hem mobil uygulama geliştirmede hem hosting de hem veritabanı kısmında çözümler varmış fakat şimdilik veritabanı kısmını çözmek istiyorum.  Birinci not: GIT ve Github Desktop'ı kendi bilgisayarıma kurdum. Kurulmasa da olurdu fakat öğrenmek amaçlı. İkinci not: Heroku diye bir site daha Firebase'in yaptığının benzerini yapıyor fakat bazı sorunlara sebep olabiliyormuş:",
        "21": "O yüzden hiç bakmadım diyebilirim. Üçüncü not: Bugün Libra ( Yeni ismiyle Diem) ve SDR nedir diye ufak bir araştırma da yaptım. Paranın birkaç farklı paraya sabitlenmesi ve enflasyondan etkilenmemesi gibi konulara bakarken karşılaştım. Konu hakkında bolca stabil coin kavramı da geçiyordu. Fakat henüz konuya vakıf değilim. Tekrar bakacağım. Bu da hem insanlık hem de benim için küçük bir adım:",
        "22": "98. Gün",
        "23": "Biraz daha erken döneceğimizi düşünüp akşama bırakmıştım raporu. Ama geç vakte kaldı. Dün baktığım konular üstünden gittim bugün. Github Pages’te dinamik web sayfası oluşturmak anladığım kadarıyla backend bir servis olmadan yapılabildiği için onun üstüne çalışmak gereksiz geldi. Hâli hazırda static bir web sayfasını yapmak gibi bir amacım olmadığı için o konudan vazgeçtim. Sonrasında yine OOP ile ilgili konulara baktım biraz daha. Bir şeyi ya bilmiyordum ya da sonradan tekrar keşfettim: Javascript’te conctructor fonksiyonlar varmış. Sınıf dışında bir fonksiyonun constructor olarak tanımlanmasını daha önce görüp görmediğimi hatırlamasam da yeni öğrenmiş hissediyorum.",
        "24": "Bugün de yine bol bol yazılımla ilgili konular hakkında araştırmalar üzerine geçti diyebilirim.",
        "25": "99. Gün",
        "26": "Bugün sonuç odaklı olmak yerine yol odaklıydım. Nereye varacağım değil, varışa giderken aşılan yollardı belki önemli olan... Evet edebi ve felsefi konuşmaktan çok teknik olmalıyım. ",
        "27": "Daha önce üstüne çalıştığımız tasarım desenleri ve SOLID ile bugün verilen görevi bağdaştırmaya çalıştım. Ona göre ortaya bir şeyler çıkarmak istedim. Başardım mı? Hayır. Ama deniyorum, deneyeceğim. Gerçekten de okurken olduğu kadar kolay değil onu farkettim tekrar. Bir şey üretmek zor olduğu kadar da keyifli. Evet bir sınıf diyagramı oluşturuyorum fakat aralarındaki bağlantılar o kadar eksik ki kendim de farkındayım. Örneğin giriş ve çıkış parametreleri hangi tipten olacak bunu henüz yazmadım. Sınıfların birbirleri arasındaki iletişimi ve ilişkiyi elimden geldiğince öğrendiklerim gibi yapmaya çalışsam da, kod yazarken o sınıf diyagramına ne kadar benzeyeceğini henüz bilmiyorum. Her ne olursa olsun başaracağım. En azından deneyeceğim.",
        "28": "beni oldukça fazla etkiledi. Mobil oyunlarda beni tek cezbedebilen konular strateji oyunları. Bu yüzden tema olarak stratejiyi seçmiştim. Osmanlı ve dönemindeki devletlerin deniz savaşlarından esinlenen bir oyun neden olmasın diye düşündüm. Ve uygulamanın verdiği fikirlere şaşırdım. Olabilecek düşmanlarımı, ittifaklarımı, savaşılacak bölgeleri (Akdeniz, İstanbul eksenli, Kuzey Afrika kıyıları gibi), hangi dönemlerde oyunun geçebileceğini (ikinci dünya savaşı sonrası modern Türkiye'si bile dahildi mesela), zorluk seviyelerini, karaya yakın bölgelerden savaş gemisine veya uçak gemisinden karaya yapılabilecek saldırıları hikayelendirdi. Yapay zeka körebe oynuyordu sanki. Gözleri bağlıydı ve sadece onu \"sıcak soğuk\" diye yönlendirdim. Bir sorun vardı fakat. O sadece daha önce yapılmış ve yayınlanmış oyunlardan feyz alıyordu sanırım. Çünkü şöyle bir senaryo geliştirmek istedim fakat hep tam tersi argümanları önerdi. Oluşturmak istediğim senaryo: \"Peki ya Adolf Hitler Kazansaydı?\". Bunun oyununu oynamak ya da kurgusunu okumak-izlemek bana haz verebilirdi örneğin. Ama uygulama çoğu oyunda olduğu gibi Almanya'ya kaybettirme çabasında olduğundan o konuda başlangıçta kaldım. ",
        "29": "En sevdiğim özelliği insanın yaratıcı yönünü açığa çıkarıyor. Sana fikirler veriyor başlangıç olarak ve sen onun üstünden farklı kurgular yaratabiliyorsun. Biraz oyun yapımından bağımsız olsa da AI hakkında daha çok düşünmeme sebep oldu. Eğer bu senaryoları bir uygulama oluşturabiliyorsa, neden AI bir şekilde şiir yazamasın diye düşündüm? Çünkü ciddi ciddi var olan senaryoları kullanarak ortaya karışık bir ürün çıkarabiliyor. Bizi kurguladığı hikayeleriyle manipüle edebilir düşününce. Ki bunu dating app'lerle de kanıtlamışlardı karşı cins bir insan olabileceğine dair. Düşünmesi o kadar keyifli ki insana ve aklına hayran kalıyorum. Primitif akrabalarımızın el aletleri kullanarak yiyecekleri parçalaması, kovanda ulaşamadığı kısımlardan çıkarması, ateşi kullanmaları, kendileri yeterince hızlı olmadığı için farklı hayvanları ulaşım ve iletişimde kullanmaları, ve o kadar çok şey var ki. Şimdi ise zekamızı bazı konularda yeterli bulmadığımız için belki de daha zeki bir şeyi bizim için kullanmak istiyoruz. Umarım varoluşsal kaygılarımın sebebi benden çok daha zeki varlıkların eylemlerinin sonucu yaşadıklarımdır diyerek sözü daha fazla uzatmamak istiyorum. ",
        "30": "100. Gün",
        "31": "OOP'ye bakış açım zamanla gelişim gösterdi onu farkettim. Birçok hatam hâlâ bulunmakta fakat iyiki o okumaları yapmışız diyorum çünkü sindirmek için pratikte üzerine düşünmek, üretmek, gerekirse yorulmak, acı çekmek varmış. ",
        "32": "İlk nesne yönelimli programlamanın ne olduğuna baktığımız zamanı hatırlıyorum. Ürünler ve içerdiği kategorilerle ilgili bizden bir şeyler beklemiştiniz. Kategorilerin ve ürünlerin birbirleriyle alakalı olduğu OOP'ye dayalı bir yapı kurmamızdı istenen. O sıralar henüz interface'i öğrendiğim için her yerde interface kullandığımı hatırlıyorum. Ek olarak da sadece inheritance vardı. Ve sonrasında SOLID çalışırken o çalışmada yaptığım bir hata aklıma kazınmıştı: \"Interface Segregation Principle\". Bir interface'i implement eden nesnenin, onun metodlarını kullanması gerektiği ile ilgiliydi. Inheritance içinde dallanıp budaklanmalar olunca bazı nesneler kullanmayacağı metodları implement etmek zorunda kalıyordu. Ve SOLID'de en hızlı anladığımı düşündüğüm kural ISP olmuştu o yüzden.",
        "33": "Interface'in nasıl yanlış kullanıldığını öğrenmiştim. Sonrasında nesneler arası ilişkideki isimlendirmeleri duymuştum: \"Association, aggregation, composition, dependency\" gibi. \"part-whole\" kavramı geçiyordu ama hiç anlamıyor ve üstünü örtüyordum. Ve farklı kavramlarla anlatılan yerlerden öğrendiğimi düşünüyordum. Ki gerçekten öğrendiğimi hissetmiştim. Sonrasında tasarım desenlerini çalıştım. 1 haftada tasarım desenlerini öğrenmek, 1 günde regex'i öğrenmek gibiydi. Okuyunca, örneklerine bakınca anladığımı düşünüyordum fakat pratikte karşılaşıp özümsemediğim için unuttuğumu hissediyordum. Ama regex gibi değil yakın gelecekte en azından birkaç tanesini iyi şekilde kavramış olmam gerekiyor. ",
        "34": "1 hafta önce acı çekmiştim. Rapor, planlama gibi konular zorlamıştı. Acı çekmek lazımdı.",
        "35": "Dün kurduğum yapıda (kayıt ve giriş) çokça yerde aggregation ilişkisi vardı. Bu kadar da olmamalı diyerek yanlış olduğunu düşünmüştüm.",
        "36": "Bugün ise kullanıcı bilgilerini görmek ve güncellemek üzerine olan yapıda abstract class, interface, aggregation, association, composition ilişkilerini kurdum. Bunları kurmak zorunda olduğum içn değil, ihtiyaçlar o yöne ittiği için kurmuştum. Belki tamamen yanlış da olabilir mantığım fakat biraz daha anladığımı düşünüyorum. Her gün farklı açılardan bakarak biraz daha iyileştiğini hissedebiliyorum nesneler arası ilişkiye bakış açımın."
    },
    "part11": {
        "1": "101. Gün",
        "2": "Composition ve dependency kavramlarının ayrımını örneklendirmek istedim ve bir tane ürettim. İnsan, dağ, Dünya. İnsan ve dağı Dünya içerir. Burada bir sahiplik ve \"part-whole\" ilişkisi bulunur. Dünya varolmak için dağa ya da insana bağımlı değildir. Yani burada bir \"dependency\" dünya için yoktur. Burada en genel manada \"association\" bulunur. Association için ayırt edici bir örnek olarak Ay'ı verebiliriz. Dünya bulundurduğu okyanus nesnesinde gelgitleri sağlamak için Ay uydusunu kullanabilir. Burada sahiplikten öte \"kullanmak\" vurgulanır. Bu da bir accosication'dır. İnsan dünyanın bir parçasıdır fakat insan dünya nesnesi dışında da var olabilir (Uygun şartlar oluştuğunda farklı gezegenlerde, uydularda yaşamını sürdürebilir). Dağ ise dünya dışına çıkamaz. Dünya her ikisine sahip olsa da böyle bir fark bulunmaktadır Dünya-insan ve Dünya-dağ arasında. Dünya-insan ilişkisi üst kümesi asscociation olan bir aggregation ilişkisidir. Dünya-dağ ilişkisi ise üst kümesi association olan bir composition ilişkisidir. Bu düşünce sınırlarını genişletirsek örnek verimsiz olabileceği için bu dar çerçeveden bakarak konsepti kavrayabiliriz. ",
        "3": "Inheritance ise anlaşılması daha basittir: İnsan, Dünya değildir. Onun özelliklerini almamalıdır (Hepimiz topraktan geldik, toprağa gideceğiz gibi düşüncelere girilmemeli tabii ki). İnsan bir primat, bir hayvan, bir canlı, somut bir varlıktır. Hepsinden insana ait ortak özellik ve yordamlar inherit edilebilir. Inheritance'ın sorunu çelik gibi olmasıdır. Kolay biçimde esnemez, döverek şekil vermek zordur. Bu yüzden GoF kitabında \"prefer composition over inheritance\" der. Her gördüğün yerde composition ilişkisi kur demek değildir bu. Composition'ı tercih et der çünkü dependency injection/setter kullanarak nesnenin davranışını değiştirmek daha kolaydır. Inheritance ta ise birden fazla tipten nesne türetmek mümkün değildir (En azından çoğu yazılım dilinde) ve coupled(bağlı)'dır. Bu yüzden interface ve abstract class kullanımı önem kazanır. Birbirinin tamamlayıcısı olan SOLID prensiplerine ise bu yazıda girersem konu daha da uzayacaktır. Inheritance çelik gibi demiştik, composition ise bakır gibidir. Dövüp işlemek, şekil vermek, modifiye etmek daha kolaydır. Inheritance'ı da bakır gibi kullanabilmek için SOLID prensiplerini elzem bir şekilde bilmek ve sınıfların tasarım aşamasında bu prensiplere dikkat etmek gereklidir. Kısaca SOLID'in OCP, Liskov, ISP prensiplerinde sağlanan polimorfizm bu esneklikte en önemli konudur.",
        "4": "En iyi öğrendiğim konular bu söylediklerimdi. Umarım yanlış öğrenmemişimdir. Tek bir cümle ile tüm yapıyı en iyi şekilde anlatmanın bu konuda olabileceğini henüz sanmıyorum. ",
        "5": "Bugün yaptıklarımı düşündüm. Sitedeki nesneleri, ilişkilerini, yapılarını düşünmek en çok yaptığım şeydi. Bugün ürünler ve kategoriler üzerine çalışıp sınıf diyagramlarını çıkarırım diye düşünmüştüm. O kadar çok birbirine bağlı kısım vardı ki hangi birine odaklanmalıyım bazen şaşırdım ve bazı yerleri farklı bir senaryoyu düşünürken inceleyip burada kullanılan nesnelerle bağlayabilirim dedim. Inheritance bulunan yerlerde Liskov'u düşündüm mü örneğin? Hayır düşünmedim. Yaptığım şey yanlış, bunun farkındayım ve kendimi kınıyorum. Ama humiliation'dan zevk almadığım için bu kınamayı kısa sürdürüp \"ona da odaklanacaksın\" diyorum kendime.",
        "6": "2 ay sonrasında üretken olabilecek miyim? \"Only God knows\" demek en doğrusu olsa da yapabileceğimi düşünüyorum. 4 ayda katettiğimiz yola bakıyorum ve farklı insan hikayelerine de göz atıyorum bu konuya başlangıçta insanların gelişim süreçleri hakkında. 4 aylık süre içinde hangi konumdayım tam bilmesem de yeterince emek verdiğimi biliyorum. Ve sizin de oldukça fazla yardım ettiğinizi. 4 ayda neler olmadı ki. Rüyalarıma defalarca girdiğini hatırlıyorum kodlama, proje süreci, başaramamak, başarmak, her alarm sesi duyulunca rüyada \"evet burayı tamamladım, şimdi  şu kısmı tamamlayayım\"lı yazılım süreci yönetimi gibi konuların. Sonunda da altın bileziği elime takmış olurum umarım.",
        "7": "102. Gün",
        "8": "Bugün de aynı konular üzerine devam ettim. Dün ürün ve kategori üzerine düşünüp bir şeyler yapmaya çalışmıştım ama tamamlanmamıştı. Bugün eksik olan bazı kısımlarına eklemeler yapıp sonrasında ürünü sepete ekleme, satın alma kısımlarına baktım. Henüz tamamlanmadı. Son 3 gündür beynimin içi öyle dolu ki, kış aylarında evin içinde çok yavaş hareket eden “soğukkanlı” bir böceğin durgunluğu beynimde yaşanan şeymiş gibi hissediyorum. Yine de bir şekilde ilerleme oluyor tabii ki. En azından systemin üzerine düşünüp daha yakından tanıyorum düşününce. ",
        "9": "103. Gün",
        "10": "Gün boyu ödeme sistemi üzerinde durdum. Başlangıçta ödeme yöntemleri ile kurulan ilişkiyi düşündüm. Sonrasında Iyzico’dan alınan ve Iyzico’ya verilen parametreleri onların sitesinden okudum. Bu parametrelerin Gpay, Paytr, Papara’da da olduğunu varsaydım. Ya da en azından çok benzerlerinin olması gerektiğini düşündüm. Ödeme sistemini dizayn ederken birbiri ile çok ilişkili yapılar vardı. Arayüz-abstract class kullanımı zorunluydu. Ama nerelerde ne kadar sayıda ilişki olduğunu çözemiyordum. Sonrasında ödeme konusunda daha önce insanlar hangi tasarım desenlerini kullanmışlar ona baktım. Genelde factory method, strategy ve facade pattern’ler ile karşılaştım. Özellikle simple factory ve strategy pattern’in beraber kullanılması ile ilgili benzer birçok örnek vardı hem authentication hem de checkout konusunda. Sonrasında günün çoğunluğunu tekrar bu tasarım desenlerini anlamak, kendi sistemim üzerine nasıl oturtabileceğim üzerine teorik olarak tasarlamakla geçti. Strategy pattern’e bakakerken open-closed principle direkt gözüme çarpmıştı. Sanki tüm amacı onu sağlamakmış gibi geldi. Factory ile aslında çok farkını bulamadım. Her ne kadar stack overflow’da çokça farklarından bahsetmiş olsalar da ben henüz kavrayamadım. En net gördüğüm düşünce, ödeme metotların ortak bir yapısı olması gerektiğiydi ve hardcoded bir yapı ile hepsini kullanmak yerine OCP’ye uyarak, sisteme yeni bir ödeme metodu eklediğimizde ya da sildiğimizde sistemdeki eski kısımlarda güncelleme yapmamak gerektiği üzerineydi. Sadece bir simple factory tasarım deseni yeterli olur diye düşündüm ve bunu uygulamaya başladım. Henüz bitmedi. En son kanıya varma sebebim  Factory-Strategy desenlerinin farkını anlayamadığım için olabilir. Yapı olarak çokça benzeseler de kullanılma sebepleri farklıymış anladığım kadarıyla. Tasarım desenleri  karşıma problemler çıktıkça  kullanabileceğim ve aklımda yer edecek konular sanırım. Onu da çözeceğim.",
        "11": "Neredeyse her yeni gün çok fazla şey yapmak istiyorum: algoritmalar kitabını tamamen her noktasına kadar anlamak, kendim örnekleri tekrarlamak, sonrasında kodlayıp mükemmel bir frontend ile kullanıcı etkileşimli algoritma kütüphanesi yaratmak, yapay zeka çalışmak (web alanında ne yapılabilir farklı olarak) ve kendimce ufak projeler çıkarmak, javascript’I hatim etmek (plain-normal-, node, hatta react öğrenmek). Genel olarak huzurluyum çünkü sevdiğim ve tatmin olduğum bir konu hepsi. Elbette bu uç örnekler işten öte hobi olarak sonra yapılabilecek şeyler. Fakat hobi olarak yapılabilecek şeyler olması işin en güzel yanı.",
        "12": "Enflasyondan etkilenmemek ya da para birimlerinin volatilitesinin olmadığı bir sistem üzerine hâlâ daha iyi bir araştırma yapamadım ve üstünde duramadım. Ama o da hep aklımın bir köşesinde. ",
        "13": "104. Gün",
        "14": "SOLID'i tam olarak kullanmalıyım derken kullanıcı ile bilgileri içeren her kısmı farklı class'lar oluşturarak yapmıştım. User class'ından gereken kısımları çeker ve işlemleri o şekilde tamamlarım diye düşünmüştüm. Bunu da DI kullanarak yapabilirdim. Yanlış düşünmüşüm. SOLID'deki single responsibility'yi biraz daha büyük ölçekten sisteme bakarak düşünmem gerekiyormuş belki de. Kendime kırıldım. Fatih Terim'in takıma strateji verirken sürekli gazlama metodunu kullandığı gibi kendimi gazlamış olabilirim. Düşe kalka yürümeyi öğreneceğim. İlk yürümeyi öğrenen çocuğun ebeveyninden destek almadan bir şeyler yapma çabası gibi oldu sanki bu hafta. Kendi ayaklarım üzerinde durabilmek dileğiyle yakın zamanda (yazılım açısından).",
        "15": "105. Gün",
        "16": "Bugün ortaya karışık ilerledim. Daha önce üstüne okumalar yaptığım seo üzerine ilk defa somut olarak nasıl çalışıldığını gördüm. Daha doğrusu SEO'dan öte bugün Google Analytics ne işe yarar, kullanıcı istatistiklerinin neler olduğu (demografi verileri, ilgi alanları, oturum süreleri, etkinlikleri(örneğin satın alma), kullanılan tarayıcı bilgileri, erişim yapılan ülke bilgisi, siteye giren kullanıcının siteden hemen çıkma oranı,  gibi), kullanıcı trafiği ile ilgili verileri, siteye erişimde kullanılan yolları (edinme diye geçiyordu: paid search örneğin), site reklamının hangi yollarla verildiğini ve analytics'de bu reklamlarla gelen kullanıcıların hangi türü reklamdan geldiğini görmek gibi konuları öğrendim. Etkinlik oluşturmadan bahsetmiştim. Daha çok retargeting ve remarketing'de işe yarayan, kullanıcı verisinin gerçek zamanlı incelenebildiği bir konseptmiş kendisi. Criteo kullanımını gördüm ayrıca. Google ads yerine kullanılabildiğini (mesela firefox'ta da reklam verilebiliyor) öğrendim. ",
        "17": "Site haritasının önemini, dizine eklemenin (indeksleme) ne işe yaradığını anladım. Soft 404 hatasının ve noindex tag'inin kullanılmasının SEO'nun kabusu olduğunu öğrendim. ",
        "18": "Bugün asıl öğrendiğim konu şu oldu: bir şeyi söyleyeceğim demişsem, not almışsam, onu unutmamalıyım. Böyle bir lüksüm yok. Bakınız: Fransızca.",
        "19": "Bir yerde hata olduğunda en basit raporlama şeklinin hata ve hatanın olduğu yeri başlık olarak belirttikten sonra açıklaması ve ekran görüntüsünün ilgili kişiye gönderilmesi olduğunu gördüm. ",
        "20": "Sonrasında bol bol Google'ın kendi dokümanlarından SEO hakkında okumalar yaptım. Öncesinde de biraz daha sınıf diyagramlarına baktım. Eksikler bolca bulunsa da temel iskeletin bir parçası oluştu diye düşünüyorum ve kodlarken yapının sağlam temellere oturacağını düşünüyorum.",
        "21": "106. Gün",
        "22": "Bugün hem SEO kısmına hem de var olan görevimize devam ettim. SEO konusunda o kadar çok bilgi var ki yine de hazmederek öğrenmeye çalışıyorum. Başucu kaynağım google developers dokümanları. İki gündür iş bitiminde onlara bakıyorum. Bugün çalışmalarımızdan aklımda en çok kalan, siteye verilen linkler ve sitede var olan linkler üzerine çalışmalar oldu. Örneğin donanım haber footer'ına backlink vermenin sağladığı katkıyı gördüm. Donanım haber bu backlink'e sahipti ve nofollow tag'i bulunmuyordu örneğin. nofollow tag'i bulunmazsa site itibarının (reputation) google gözünde düşme ihtimali var. Spam bir lir siteye link gidebilir, trafik hacmimizi daraltabilir gibi zararlı yanları bulunmaktadır. Donanım haber neden nofollow tag'ı kullanmamış peki? Google'a bu linkin sponsorlu olduğunu söylüyor. Sponsorlu link olduğunu gören Google \"aa tamam o zaman sorun yok\" diyor. nofollow'a benzer olarak noreferar ve noopener tag'leri de bulunmakta. Özetle benim bunları sitemdeki linklerde kullanmam gerekiyor SEO için. ",
        "23": "Bugün ayrıca Semrush, Ahrefs, Serp gibi gibi uygulama ve konulara baktım. Biraz aşina oldum. Semrush'ın sayfalar için öneri fikirlerini görünce biraz da algoritmasına hayran kaldım. Sayfalandırmalar (pagination) hakkında bir hata gösteriyordu ( hepsi aynı sayfa başlığını gösteriyordu ve sorun buradan kaynaklanıyordu). Akşam bunun üstüne biraz araştırma yaptım birkaç faydalı çözüm yöntemi farklı kaynaklarda sunulmuş: \"Use Rel='next' and Rel='Prev' for Paginated Page Series\", \"Use the Canonical Tag Rel='Canonical'\", \"Remove Content from the Google Index\", ve daha fazlası. Ama hangisi daha etkili olabilir onu henüz bilmiyorum.",
        "24": "SEO üzerine okuma yaparken Google'ın fotoğraflar için birkaç önerisine denk geldim şu an kullandığım/ız'dan farklı olarak: Örneğin <pictures> tag'i ile resimleri sunmanın responsive'lik açısından daha fayalı olduğunu belirtmiş. Bir de SVG formatlı fotoğrafları da oldukça fazla methetmiş diğer raster graphic'li formatalara (jpg, png gibi). Anladığım kadarıyla SVG formatlı resimler daha az boyuta sahip olduğu için HTTP request'lerini azaltmak için faydalıymış. Data URI'ı da oldukça övmüş fakat dezavantajlarının çokluğunu görünce onu çok araştırmadım. Ek olarak, örneğin <img srcset> tag'i ile resim eklenmek istenirse bunun her tarayıcıda algılanamayabileceğini belirtip \"img src\" olarak da yedek bir url vermeyi tavsiye etmiş. Bana çok saçma geldi. Her tarayıcı desteklemiyorsa ve tavsiye edilen kullanım yönteminin büyük artıları yoksa neden tercih etmeliyim? Bence tercih etmemeliyim.",
        "25": "107. Gün",
        "26": "Öncelikle veritabanı ile ilgili işlerin ardından kullanacağım sorgular için hem bir veritabanı bağlantısı hem de sorgular için genel bir çalışma yapmam gerektiğini anladım. ",
        "27": "Planım şuydu: Önce bir singleton class oluşturacaktım veritabanı bağlantısı için. Ama bu bağlantı sadece mysql'e değil, aynı zamanda PostgreSQL'e de yapılabilecek şekilde flex bir yapıda olmalıydı. Bunun için singleton sınıfımdaki contructor'in içinde bir yapı kurdum. Mysql server'a mysqli ve pdo ile bağlanma seçeneği ve bir de PostgreSQL server bağlantısını ortak bir yapı ile kurmaya çalıştım. Bağlantılar ile ilgili logic'i ortak arayüze sınıflara aktardım. Veritabanı bağlantısının amacı ona bilgiler vermek ve bilgiler almak olduğu için bu iletişim içeriğini ve methodlarını içeren bir Query sınıfı oluşturdum. En son hâlinde _<<$query = new Query($mysqli); $query->insert([\"table\" => \"Directors\", \"keys\" => [\"Name\", \"Surname\", \"Age\"], \"values\" => [\"Stanley\", \"Kubrick\", \"66\"]]);>>_ diyerek sistemdeki herhangi bir yerde bu tür sorguları basit şekilde yapabilecek. Eğer başarabilirsem. ",
        "28": "Şu aşamada yazmaya öyle odaklandım ki, henüz gerçek veritabanı bağlantısı kurmadım ve kodda ne kadar hata var henüz bilmiyorum. Mantığını doğru kurabilirsem yarın o hataları da düzeltebileceğime inanıyorum.",
        "29": "Hem mysqli hem de pdo için ortak bir yapı kurmaya çalışıyorum özetle. Biraz gereksiz zahmet gibi görünebilir. Hatalarda fazla zamanımı alacak olursa future development olarak bir tanesi sonraya bırakılabilir.",
        "30": "Bugün özellikle prepared statement'ı mysqli bağlantısı ile oluştururken zorlandım ve büyük ihtimal zor çözeceğim. Çünkü query builder çalışırken de en büyük sorunu hep orada yaşıyordum.",
        "31": "108. Gün",
        "32": "Veritabanı sorgu sınıfı için gerekli metotları bugün tamamlamam gerekiyordu. Dün insert kısmını, bugün de kalan kısmı bitirilip kullanabilecek formatlara uygun yeterli seviyede sorgular yapabilmeme izin vermeliydi.",
        "33": "İki gün içinde yapılanlar ve yarın yapılması beklenen şu şekilde özetlenebilir:",
        "34": "Singleton bir veritabanı bağlantısının oluşturulacağı ve bu bağlantıyı elde edeceğim bir sınıf oluşturuldu.",
        "35": "Bu sınıf bağlantıyı oluştururken bağlantı metoduna göre farklı sınıfları çağırabilirdi (başta composition olarak düşünmüştüm aradaki bağlantıyı fakat, ikinci oluşturulan sınıf(örneğin MYSQLI sınıfı) Query sınıfı için de kullanılıyordu. Bu yüzden farklı iki sınıfın kullanıldığı tek bir sınıf olduğu için aradaki ilişki aggregation yani pass by reference'tı.",
        "36": "MYSQL ya da POSTGRESQL sınıfı ortak bir yüze sahip olması gerekir. Gelecek kullanımlarda client'a kolaylık sağlar. ",
        "37": "Normalde hem mysqli hem de pdo için CRUD metotlarını yazacaktım fakat prepared statement'lar biraz fazla zamanımı aldığı için sadece PDO bu örnekte tercih edildi.",
        "38": "Şu an sorgular sınırlı koşullar altında çalışmaktadır. Bu koşulların bu proje için şu aşamada yeterli olduğunu düşünülüyor.",
        "39": "Sorun özellikle şurada olabilir: Örneğin \"WithMySQL\" sınıfında hem mysql yöntemleriyle bağlantı veritabanı oluşturuluyor hem de crud işlemleri sağlanıyor. Farklı sınıflara ayırma imkanı vardı. Hatta daha şık olurdu. Bu durumun bilincinde olarak yazıldı.",
        "40": "Yarın büyük ihtimalle daha önce tasarlayıp kullanıcıdan veri alışverişinde bulunduğumuz eski bir projenin frontend'inden yararlanıp kullanıcı kaydı ve giriş aşamaları bu dizayn ile sağlanabilir. Ya da sadece PHP kısmına devam edilebilir.",
        "41": "109. Gün",
        "42": "Bugünün sorunu şuydu: Nedeni olduğum hataların bazılarını hata beklentisi olmadan yapıyorum. Bazı hataları ise bilerek oluşturuyorum, ya da sistem doğru çalıştığı için o hata geliyor. Bazı yerlerde hatayı isteyip istemediğimi çözemediğim oldu. Günün en büyük problemi hatalarla mücadeleydi.",
        "43": "Bugün yapılan: Veritabanı ve sorgu sınıfları kullanıcıyı kaydetmek, aktivasyon linki göndermek, dönen linke göre kullanıcıyı aktif edip kullanılan aktivasyon kodunu \"kullanılmış olarak\" etiketlemek için oluşturulan kayıt olma ile ilgili sınıflarda kullanıldı.",
        "44": "Bir konu var aklıma takılan: uzun süre kullanılmamış aktivasyon linklerini geçersiz kılmak (kod state'ini değiştirerek örneğin) için ne yapılabilir? Mysql'de bir olay (event) yaratıp, gerekli sql sorgusunu oluşturdum fakat veritabanında böyle bir işlem için yetkim olmadığını gördüm. Bu problemi henüz düzeltemedim. Ayrıca locale'den email gönderemeyeceğimi düşünerek (onun da bir yolu vardır tabii ki), o kısmın gerçekleştirildiğini varsayarak işlemler yaptım. Açıkçası kayıt aşaması tamamlandı gibi görünüyor sunucu taraflı olarak. Yarın giriş kısmını tamamlayacağım. Sonrasında kayıt ve girişin prototip üretimini (frontend ile) tamamlayıp diğer aşamalara geçeceğim.",
        "45": "110. Gün",
        "46": "110 gün içindeki en verimsiz gündü öğle yemeği saatine kadar. Mide problemi odaklanmayı kötü etkiledi. Bugün çok bir şey yapamadım o yüzden. Dün yapılan çalışmadaki son fatal error'u çözdüm. Sonrasında kayıt işlemini kullanıcı facebook ve twitch ile de gerçekleştirebildiği için örnek olarak bir fonksiyon ile api ye sağlanan ve alınan parametreleri input/output olarak ekleyeceğim. Bu kısmı da tamamlayınca kayıt bitmiş oluyor."
    },
    "part12": {
        "1": "111. Gün",
        "2": "Bugün sisteme giriş yapma ve şifremi unuttum kısımları tamamlandı. Şifresini unutan kullanıcıya, tıpkı aktivasyon kodunda olduğu gibi rastgele ve geçici bir kod oluşturularak istediği yöntem ile (email veya sms) gönderilir. Bu kodun bağlı olduğu link ile sisteme gelen kullanıcı, şifresini değiştirme işlemlerine yönlendirilir fakat henüz o aşamaya gelmedim (Kullanıcının kendi bilgileri üzerine yapabileceği işlemler kısmında burası da ele alınacak. Büyük ihtimalle gelen linkten get metodu kullanılarak ve belki regex yardımıyla varolan kod alınıp doğruluğu sorgulanıp sonrasında gerekli işlemler yapılabilir). Sadece rastgele kod oluşturma, gönderme, veritabanına kaydetme, gibi işlemler bugün şifremi unuttum kısmında tamamlandı. ",
        "3": "Sonrasında giriş ve kayıt kısımlarının front end kısmını yapılmasına hazırlanırken, hep duyulan MVC'nin ne olduğunu tekrar merak edilip ona benzer şekilde bir sistem oluşturulabilir mi diye düşünüldü. Kopyala yapıştır olan ve mantığı henüz idrak edilmeyen kodlarla yapılabilir gibi geldi. Açıkçası denendi ama kısa süre içerisinde yapılamadı (pek de kısa değil aslında) çünkü çok parçalı bir yapısı vardı ve şu an temel sorun bu olmadığı için sonrasında vazgeçildi (Vazgeçilse de en temel bazda öğrenilen ya da akılda kodlanan kısımlar da oldu: Controller=> Get ve post metodları ile model'i ilgilendiren konulara girmek isteyen kullanıcı eylemlerini içeriyor. Model=> Veritabanı ilişkileri, sistemin ana mantığını bulunduğu kısım, aslında şu an asıl ilgilendiğimiz kısım. View=> Html ve ilgili kullanıcıya gösterilen frontend kısmını temsil eden bölüm). Temel sorun websitemizin sistemini elden geldiğince çözmek, varlıklar (software entities) arası ilişki ve bağlantıları kurmak üzerine. ",
        "4": "Yarın veritabanı ile ilgili sınıfların düzenlemesi yapılacak. Problemli kısımlar düzeltilecek. Tamamlandıktan sonra giriş ve kayıta son verilecek (get ve post ile kullanıcıdan bilgileri alıp, session ile kullanıcı oturumunu tutup, eski bir görevde kullanılan basit bir frontend kullanılacak düzenlenerek). Yarın biter diye tahmin edilmektedir. Biterse eğer, kullanıcının kendi bilgilerini güncellemesi, görmesi gibi konuların yer aldığı sınıf diyagramının iskeleti (wireframe) çıkarılmaya başlanacaktır.  ",
        "5": "112. Gün",
        "6": "Bugün kodlamaya devam ederim diye düşünmüştüm. Fakat sınıfın nesne olması durumunu aklım almadı. En son izah edilen şekilde açıkçası anladığımı düşünmüştüm (o aydınlanma, beyinde kıvılcım çakma hissi olmuştu) fakat, sonrasında derinlere daldıkça işin içinden çıkamadım. \"Yine de öğrendiklerimi, gördüklerimi ve notlarımı yazarsam en azından benim için de referans niteliği taşıyan bir doküman oluşur\" diyerek sözü uzatmadan ana konulara gelelim: Sınıf nedir? Nesne nedir? Referans nedir?",
        "7": "Bir ev metaforu üzerinden gidelim:",
        "8": "Bir sinif, ev icin bir tasarımdır (blueprint). Bu tasarimi kullanarak birçok ev inşa edilebilir.",
        "9": "Insa edilen (instantiate) her ev bir nesnedir, instance olarak da bilinir.",
        "10": "Her ev bir adrese sahiptir. Eger birisine evin nerede oldugunu soylemek istersen, üzerinde adresin yazili oldugu bir karti ona verirsin. Bu kart o nesnenin referansıdır.",
        "11": "Eger evi ziyaret etmek istersen, kartın üzerinde yazılı olan adrese bakarsin. Bu da dereferencing'tir.",
        "12": "Not : Bir adres, nesnenin hafızada yasadigi yerdir. Referans ise adresi işaret eden (points to this address) bir değişkendir",
        "13": "Bu kod parçacığında neler olduğuna satır satır bakalım:",
        "14": "\"new EvSinifi()\" der ki, EvSinifi tasarımını kullanarak, evin isaret edildigi bir referans return edilir. Bu referansi $evim degiskenine kopyalayabilirsin. Bir müteahhite ev yapmasini soylersin. Yapar. Sana evin adresini söyler. Sen de onu not edersin.",
        "15": "Bu adresi bir metoda (caller) verirsin.",
        "16": "Burada \"EvSinifi $digerEvim\" referansina sahibiz. Burada pass-by-value vardir. caller'in icindeki $digerEvim, $evim referansının kopyasıdır. caller'a evin adresinin oldugu kendi kartinizi verdiniz. caller bu kart ile ne yapar? Yeni ev inşa edilmesini ister ve senin verdiğin karta yeni evin adresini yazar. Unutmamali ki, caller simdi ilk eve (1. asamada insa edilen) ulasamaz. Ama o ev, onun sahip olduğu adres kartina baska bir ev yazildi diye degismez, yok olmaz.",
        "17": "Özetle:",
        "18": "Müteahhitten ev inşa edilmesini iste. Etsin. Bize adres versin. Bu adresi $evim degiskenine kaydedelim (bir karta yazalim)",
        "19": "caller'i cagiriyoruz. Bunu yapmadan once $evim'de yazan adresi caller'a verdiğimiz yeni bir karta kopyaliyoruz. caller bu karta $digerEvim diyor.",
        "20": "caller müteahhitten yeni bir ev ister. Insa eder, yeni evin adresini verir. caller bu adresi verdiğimiz karta kopyalar.",
        "21": "Ilk asamaya doneriz. Orjinal, degismemis karta bakariz. Kartimizda yazan eve gideriz ve orada bir seyler yapariz.",
        "22": "Farkli bir bakis acisi ve farkli bir örnek:",
        "23": "Bir televizyon (nesne) ve uzaktan kumandayi (referans) hayal edelim. Uzaktan kumanda ile televizyona bagliyiz. Eger sesi kismak, kanal değiştirmek istersek once referansi manipüle ederiz. O da nesneyi modifiye eder. Odanin icinde dolasirken hala nesneyi kontrol edersin referansin ile. Referansi kendinle beraber laip gezersin, ama televizyonu degil. Ayrica, referans televizyonsuz da kendi basina kalabilir. Bir referansin var diye bagli oldugu bir nesne vardir anlamina gelmez.",
        "24": "Java'dan ornek verelim:",
        "25": "Burada nesne değil sadece bir referans yaratiliyor. Eğer \"s\" e bu noktada bir mesaj göndermek istersen, hata alirsin cunku \"s\" hicbir seye bagli degildir (ortada televizyon yoktur). Daha güvenli bir pratik, bir referansi yarattığında onu her zaman başlat (initializing):",
        "26": "Ancak bu özel bir Java yontemidir. Normalde nesnelerin baslamasi icin daha genel bir tip kullanilir. Bir referans yarattiginda, yeni bir nesneyi ona bağlaman gerekir. Genelde \"new\" operatörü ile yapilir.  Burada \"bu nesnelerden yeni birini bana yap\" dersin:",
        "27": "Yukarıdaki  örnekler aslında tamamen Java dilinde nesne ve sınıf arasındaki ilişki üzerine kuruludur. Şimdi ise PHP’de durumun nasıl olduğuna bakalım: Esas kaynak olarak PHP Manual’ına bakınca da nesne ve sınıfın yine Java’ya benzer şekilde bir ayrıma sahip olduğunu görülmektedir.",
        "28": "Peki bu ayrım her dilde var mı? İşte burası karışık çünkü her dil farklı bir konsepte sahip anladığım kadarı ile. Objective-C’de her sınıfın bir nesne olduğunu okudum. Her sınıf bir nesne imiş. Ama bu sınıflarda bir nesne olduğu için farklı bir class’tan türemek zorunda ve bu class’a da metaclass adı verilmiş. Bir nesnenin sıradan instance ifadesi oluşu gibi, metaclass’ta bir sınıf nesnesinin ifadesiymiş (Hiç bilmediğim, ama bilenleri referans alarak söylediğim için bol miktarda -miş’li zamana yer verdim).",
        "29": "Smalltalk’ta ise sınıfların, sayıların, stringlerin, hatta programın kendisi dahi nesneymiş. ",
        "30": "Kafam biraz karıştı açıkçası ama raylar yerine oturacak diye tahmin ediyorum.",
        "31": "113. Gün",
        "32": "Pass by reference ve pass by value konusuna bir gün verildi. Konu net bir şekilde anlaşıldı. Hakkında çokça soru ve cevap bulunmasına rağmen, en net cevap en sade cevaptaymış. O cevabı derinlemesine inceleyince en sonunda karşılaşılan ise yine aynı cevapmış. “Derman arardım derdime, derdim bana derman imiş; insan-ı kâmil olmaya, lazım olan irfan imiş”  der gibi oldu.",
        "33": "burada a değişkeni b değişkenine eşit değildir. b değişkeninin bulundurduğu değeri bulundurur. Pointer konusuna bakılınca bu konu daha iyi anlaşılmaktadır. a ve b değişkenleri, farklı adreslerdedir. Aralarındaki tek bağlantı, be değişkeninin sahip olduğu değeri a değişkeni kendisine kopyalamıştır.",
        "34": "burada ise, a ve b aynı şey olarak düşünülebilir.  Bir insana Tayyip ya da Recep diye seslenmek gibidir. Aynı kişiye seslenilir. Derinlere girdikçe işler karışabiliyor hala daha ama en genel manada düşününce payy by value ve pass by reference konusu net olarak anlaşıldı.",
        "35": "Bugün anlaşıldığında gönüllere su serpen konu ise, nesnelerin kendisinin new ile yaratılması sonucu nesne değişkenine atanmaması, değişkene sadece nesnenin konumunu bulacak olan identifier’ın atanması durumu oldu. Karışıklığa en çok sebep olan konulardan biriydi benim için.",
        "36": "Bugün en çok da C++ kodlarını inceledim bu konularla ilgili (işaretçi, referans, dinamik bellek ataması). ",
        "37": "Eklemeden edemeyeceğim: Şu site benim için günün en çok ufkumu genişleten bilgileri verdi (elbette sizin bildiğiniz konular fakat benim için böyle bir etkisi oldu).",
        "38": "Son iki gün teoriye odaklanıldı gündemde olmasa da. Yarın tekrar gündeme geri dönülecek. Görevde kalınan yerden devam edilecek.",
        "39": "114. Gün",
        "40": "Bugün ilk iş veritabanı bağlantısı ve sorular ile ilgili sınıf düzenlemesi yapıldı. Sorgu metotları farklı bir sınıf kullanarak çağrılacak sadece. O hızlıca düzeltilebilir.",
        "41": "Sonrasında kayıt ve giriş için yazılan kodları front end ile birleştirildi. Giriş kısmında biraz eksikler kaldı fakat bitmek üzere.",
        "42": "Yarın eksikleri hızlıca tamamladıktan sonra kullanıcı bilgilerini görme ve güncelleme konularında oluşturulmuş sınıf diyagramı koda dökme kısmına geçilecek.",
        "43": "Bugün yapılanlar dışında yapılmayan ama merak edilenler vardı:",
        "44": "Hesap aktivasyonu için gerekli kodu email ile gönderdiğimi varsayıp (ilgili fonksiyon çıktısında return olarak “gönderdiğini” belirten bir varsayım), o varsayımla  işlemlere devam ediyordum. mail() fonksiyonunu denemek istedim. Denedim (gerekli php.ini ve ilgili bir dosyada gerekli konfigürasyonları sağlayarak). Fakat mail SMTP sunucu hatası ile birçok defa karşılaşıp çözüm bulamadım. Hata ise büyük ihtimalle  TLS-SSL port’undan kaynaklanıyor. Fakat çözemediğim için  ve aynı zamanda mail göndermek için daha modern yöntemler tercih edildiği için uğraşmayı bıraktım. Farklı bir yöntem ise denemedim.",
        "45": "Günün ikinci problem ise client ip’sini nasıl almam gerektiği ile ilgiliydi. Evet, $_SERVER['REMOTE_ADDR'] kullanarak bulabileceğimi görmüştüm. Ki sanırım en iyi yol da bu. Fakat,",
        "46": "şu yorumu okuyunca bir güvenlik zafiyeti bulunuyor mu diye biraz fazla sorguladım.",
        "47": "115. Gün",
        "48": "Daha önce yaptığımız çalışmalar o konularda çok daha hızlı sonuca ulaşmamı sağlıyor. Bu da oldukça pozitif bir şey diye düşünüyorum. Şu an giriş , kayıt, veritabanı konuları tamamen bitti gibi görünüyor. Ip adresi koruması kısmını kodladım fakat yarın kullanıcı tercihleri kısmını yapacağım için oradan da etkilenecek (kullanıcı koruma istediği durumda gelecek parametreyi alıp geçici koyduğum parametre yerine koyacağım aslında) o yüzden o kısmın tamamlanması için küçük bir nüans kaldı diyebilirim.",
        "49": "Ne yaptığımı, ne yapmam gerektiğini bildiğimi düşünüyorum. Sınıflar arasındaki ilişkileri de bir nebze kavradığımı ve onlarla kukla sanatçısı gibi oynayabildiğimi düşünüyorum (en azından benim seviyeme göre).  Tasarım desenlerinde bildiklerimi değil, ihtiyaç doğrultusunda probleme en iyi yaklaşımla çözümü getirebileni seçmem gerektiğini düşünüp kullanmaya çalışıyorum. Açım, daha iyisini yapmaya, daha temizini yazmaya, kavramları daha iyi oturtmaya, sistemi tek başıma anlayabileceğim seviyeye gelmeye. İyi ki öyle. Yol çok uzun ama seyran eylemeye devam. ",
        "50": "116. Gün",
        "51": "Bugün çok kayda değer bir kod yazılmadı. Daha çok neleri nasıl yapabileceğim üzerine düşünüp kurgulamaya çalıştığım bir gün oldu. Gün sonlarına doğru verim hissetmediğim için çalışılan konuyu değiştirip algoritma kitabına son 1 saat baktım. Genel olarak sakin bir gündü. Farklı bir sınıf diyagrama baktığım için ve onun da koda dökmek için çok da doğru oluşturulmadığı fark edildiği için biraz verimsiz geçti sadece. Ama toparlayacağım.",
        "52": "117. Gün",
        "53": "Kullanıcının bilgilerini güncelleme kısmına bugün bakıldı. Biraz karıştı. Şu yüzden: user sınıfının daha daha çok yönlendireceği ve detaylı mantığı içermeyeceği düşünülmüştü. Fakat bufün _set() ve _get() magic metotları user sınıfında yapılması düşünülmeyen işlemlere girildi. O yüzden çok da karıştırmanda işin içinden nasıl çıkılabilir ve iyi bir dizayn nasıl yapılabilir bugün bu düşünüldü, oluşturulmaya çalışıldı. Kayı giriş kısmı buraya göre çok daha sistemli bi şekilde yapılmıştı. Bugün biraz çarpık kentleşmeye sebep olunacakmış gibi hissedildi. Ya gecekondular yıkılacak, ya da yapılmasına izin verilmeyecek. Yarın genel yapı daha da ortaya çıkar diye düşünülmektedir.",
        "54": "118. Gün",
        "55": "118 gün içindeki en ilginci bugündü. Öncelikle kullanıcı bilgileri güncelleme ile ilgili oluşturduğum sınıf diyagramı çok geçerli değilmiş bugün çalıştığım sırada daha çok farkına vardım. Kafamda oluşturduğum konseptin dışına çıkıyorum bu da beni zorluyor. Günün çoğunluğunda bu sorunları aşmaya çalıştım fakat çalışmamı verimsiz hissedip aynı yerde bocaladığım için ilgili konularda okumalar yaptım sonrasında biraz. Yarın dinç bir şekilde ilerlemeye çalışacağım.",
        "56": "Bugün neden en ilginç gündü peki? Evet profesyonel hayatta böyle şeylere takılmamam düşünmemem lazım belki ama birazcık gün sonunda takılmıştı kafam. Ben ağlayan kişiyi masum sanıyordum. Son bir saat kafam o konuya geliyordu kendimi uzaklaştırsam da. Üzülmüştüm. Oysa sonra kendisi, asıl çıkarılma sebebini söyleyince yine kendi saflığıma güldüm. Biraz da olsa akıllı sanırdım kendimi fakat “hani marjinal bizdik” vakası oluşmadı değil sonunda. Gidenler gerçekten kendileri etmişler ve bulmuşlar. Ben yine işime gücüme bakıp kendimi geliştirmek için çabalayacağım.",
        "57": "119. Gün",
        "58": "Bugün sizin yazdığınız kodu canlı olarak izlemek, kod yazımına tanık olmak, anlamak ile geçti günün çoğunluğu. Analdığımı da düşünüyorum. İş çıkışında Php’ deki strict type konusu konuşulmuştu. Benim de aklıma şuradaki yazı gelmişti o anda ama tam ifade edememiştim:",
        "59": "Burada anlatmak istediğine tekrar baktım. Tren analojisi vardı cevaplarda. Bugünkü konu o yüzden çok alakası olmamakla birlikte branch prediction konusunu aklıma getirmişti. Çok bilmediğim için detaylara girmeyeceğim fakat daha sonrasında araştırıp öğreneceğim çünkü merak ettim.",
        "60": "Günün anlam ve önemine binaen bir Niçe sözü:",
        "61": "“Ne çok gülmüşümdür keskin pençeleri olmadığı için kendini iyi zanneden zayıflara.”",
        "62": "120. Gün",
        "63": "Bugün namespace kullanımı, sınıfların ayrı dosyada yazılması ve o şekilde erişilmeleri, autoloader’ın kullanımı, directory yapısının nasıl olması gerektiği, PHP’de framework yazan insanların oluşturduğu bazı standartların varlığı gibi konular gündemimdeydi. ",
        "64": "Öncelikle namespace’in eksikliğinden kaynaklanan sorunları daha önce de defalarca yaşadığım için (aynı class isimlerinin çakışması ve programın istenmeyen sonuçlar ortaya çıkarması) kullanımına daha önce bakmıştım ve neden kullanıldığını biliyordum. O yüzden o konuda bir hiçbir sıkıntı yoktu. Bugün ilk kez karşılaştığım şey ise autoloader’ın kendisiydi. Autoloader’ın ne olduğunu, nasıl çalıştığını öğrendim. Sonrasında dosyaların dizin yapısının nasıl olması gerektiğini anlamam gerekliydi. Bu konuda tek bir doğru yoktu internette. Herkes farklı yaklaşımlarda bulunmuştu directory structure için. Tek bir formül yoktu fakat genelde tercih edilen bazı çözümler bulunmaktaydı: Bu konuda ana kaynağım bu yazıydı:",
        "65": "Dosyaları-sınıfları arketipine göre ayırabilirim. (davranış gibi de düşünülebilir mesela controller olarak davranan dosyalar) Ya da bu dosyaları kendi özelliğine göre (feature denilmiş, mesela product ile ilgili concrete sınıfları içeren dosyaları tek bir yerde toplamak gibi) ayırabilirdim. Yazar feature’a göre göre dizin gruplamanın faydalarından bahsetmiş bolca. Örneğin bir developer dizine baktığı zaman uygulamanın ne yaptığı hakkında kısa zamanda fikir edinebilceğini belirtmiş. Çok daha derli toplu kod oluşturma söz konusu aslında. Bizim yazdığımız (daha doğrusu sizin yazdığınız) koddaki ana detaylarında biri bu yazıda da vardı: “Genel amaçlı kodu ve domain kodunu birbirinden ayır”. Core ve class’ları ayırmamızdan bahsedilmişti. Dünyanın çekirdeğinden bize lavlar gelebilirdi. Ama biz çekirdeğe inemezdik. Güneş bizi ısıtırdı, bize can verirdi. Ama biz güneşe bir şey katmadık. Güneşin bize ihtiyacı olmadı (who knows?).  Aynı şekilde core klasöründe bulunan dosyaların domain class’larının bulunduğu classes klasörüne bağımlılığı yok. Ama tam tersi bir bağımlılık söz konusu.",
        "66": "Günün dışında bir şeyden bahsedecek olursam, dün siteye kendi bilgisayarımdan girip bakınca birkaç problem farketmiştim, siz elbette biliyorsunuzdur fakat ben yeni gördüm: bilgisayarın ekran boyutu daha küçük olduğu için karoseldeki fotoğrafların boyutlandırmasında bir hata vardı. Hatann olduğu kısımlarda calc() ile yapılan işlem iptal edilince düzelme sağlanıyordu. Ama sadece o ekran boyutları için geçerliydi. Bugün merak edip firefox’u indirdim bilgisayarıma. Ana sayfada bu sefer farklı bir şeyle daha karşılaştım: Karoselin üzerindeki kategorilerin bulunduğu kutuların (div) boyutları farklıydı bir kısmında (flex ile ilgili fakat chrome ve firefox’ta neden bir farklılık söz konusu henüz bilmiyorum)."
    },
    "part13": {
        "1": "121. Gün",
        "2": "Sabah takvime bakınca çok şaşırdım. Çünkü bugünün Çarşamba olduğunu sanıyordum. Bu hafta nasıl geçti hiç anlamadım. Yapmak istediklerimi zamanında yapamadım. Bugün kendi koduma bakınca solid’deki OCP (open-closed principle)’nin cinayetinden sorumluymuşum gibi hissettim. Çünkü hem open for extension hem open for modification oldu özellikle bugün yazdığım koda bakılırsa.  Daha önce yaptığım hataların farkına varıp sonra yapmamaya çalışıyorum. Yeniliyorum. Sonra tekrar deniyorum. ",
        "3": "Bugün genel olarak aynı yerlerde çokça takılı kaldım. Bu da kendi hatalarımdan kaynaklanıyordu. Akşam hatalı yerleri düzelttim. Yarın daha hızlı olacağım. ",
        "4": "122. Gün",
        "5": "Günün başında yine PHP kısmındaki eksiklerimi düzeltiyordum. Sonrasında güvenlik ayarlarını tamamlayacaktım. Ama frontend kısmına yöneldiğim için orası kaldı. Giriş kısmının çok çok benzerini yaptığımı düşünüyorum. Ama pixel perfect olmadığını söylemeliyim.",
        "6": "Bugünlük bu kadardı.",
        "7": "123. Gün",
        "8": "Bugün yaptıklarıma bakıyorum. Aslında az gibi görünüyor fakat ben tatmin oldum açıkçası. Özellikle Javascript ile frontend’de mühalelerde bulunmak mükemmel keyifli ve öğretici. Bugün en çok o yüzden mutluydum. Bilmediğim ya da kullanamadığım şeyler olsa da bir şekilde (sizin de yardımınızla) kullanabilmek çok güzel bir duygu. ",
        "9": "Yarın sabah ilk iş IP ile ilgili kısımları tamamlamak planımda. Veritabanı tablosunu düzeltme, IP koruması özelliğini ekleme ve ona göre giriş sağlama, frontent’de kayıtlı ip’leri gösterme (yine javascript devreye girecek basitçe).",
        "10": "İş dışında ise  konuşacak olursam (hobi niyetine konularda), daha önce çokça kez agar.io oynamıştım. Agar.io chat’inde istemediğim kişileri muteleme, bot mesaj gibi konuları javascript ile yapmak istiyorum boş zamanımda (çok zor olduğunu sanmıyorum). Yine aynı oyunda bot yapabilir miyim diye düşünüyorum. Örnekleri github’ta var ama biraz karışık geldi şu aşamada. Ama en çok yapmak istediğim de o. (Evet biraz gereksiz görünebilir bu düşünceler ama ilgimi çekiyor).",
        "11": "Diğer konu ise hobi değil aslında. Yıllardır dizi-filmleri türkçe altyazılı izlerdim. Artık ingilizce altyazılı olarak izlemeye başladım. Anlamadığım yerler fazla olsa da anladığım yerler de az değil. 22 bölüm person of interest bu şekilde bitti. Dile maruz kalıp gelişim sağlanır diye umuyorum. ",
        "12": "Ek olarak sizin gönderdiğiniz “fast inverse square root” konusuna da baktım. Açıkçası hexadecimal şekilde verilen magic number ile 32 bit işlemcilerde yapılan bit hesaplamasını anlamadım. Byte shifting’ten bahsedilmiş ama orada tıkandım (asıl önemli olan yer de o gibi, newton-raphson metodunu kavradıktan sonra). Yarın yine bakacağım çünkü ufkumun açılmasından çok soru işaretleri bıraktı.",
        "13": "124. Gün",
        "14": "Günün çoğunluğu veritabanına json verisi ekleme, güncelleme, okuma konusu ile geçti. Kayıtlı ip ekleme ve silme işlemi henüz yapılmadı ama altyapısı kısmen kuruldu. Yarın ilk iş kalınan yerden devam edilecek. Günün en zorlayıcı yanı sql sorgusu için prepared statement hazırlama konusu idi. Daha önce veritabanı işlemleri için kurulan sisteme entegre edilmeye çalışıldı ilk önce fakat başarılı olunmadığı için sonrasında bu problem için geçici çözüm oluşturuldu. Genel bir çözüm olmadı, sadece güncel ihtiyaçların karşılanması için kuruldu şu aşamada. Ama daha iyi hale getirilmek istenirse genel çözüm zaman alacağı için o kısım future development olarak kalacak.",
        "15": "125. Gün",
        "16": "Dile kolay 125 gün olmuş günlük olarak rapor tutmaya başlayalı. Toplamda 5 ay oldu neredeyse.  Bu kısa farkındalıktan sonra  bugüne gelelim:",
        "17": "Veritabanından bilgileri çekme konusu, güncelleme konusu için json_set(), json_delete(), json_array_insert() gibi mysql fonksiyonları kullanılmaya çalışılmıştı. Fakat verimli sonuç alınmadığı için eski yöntemler (sizin de bahsettiğiniz select ile veriyi çekip decode etmek ve işlemek sonrasında encode edip tekrar yazmak gibi)  kullanıldı. Okuma, silme işlemleri yapıldı. Geriye sadece olan ip’lerden birini güncelleme ve yeni ip ekleme kısmı kaldı. Aslında hepsi de aynı şey düşününce (update işlemi), sadece ayrı bölümlere ayrıldı. ",
        "18": "Frontend kısmında bugün javascript’e zaman ayrıldı tekrar. Aslında daha basitçe yapılabilir fakat biraz da challenge olması için yapılmaya çalışıldı.",
        "19": "126. Gün",
        "20": "Bugün yapmak istediğim şeyleri tamamladım. Çok daha kısa zamanda biteceğini umduğum şeyler ekstra zaman aldı. Zaman yönetimi konusunu pratikle daha da iyileştireceğimi düşünüyorum. Javascript ya da PHP farketmeksizin kurgular oluşturup yaratıcı eylemlerde bulunmak çok güzel bir his oluşturuyor (Özellikle JS'in bir albenisi var. Sözdizimi daha tatlı ama teknik anlamda profesyonel yorumlarım henüz yok). Aynı şekilde bir problem çözmek için de farklı yaklaşımlar bulmaya çalışmak, farklı yaklaşımları anlayıp kavramaya çalışmak da çok güzel bir hissiyata neden oluyor.",
        "21": "Genel olarak şu aşamada karşılaştığım problemlerin çözümsüzlüğü bulunmuyor. Karşılaşılan problemler elbette çözülüyor fakat en büyük arzum “bad code”a sebep olmadan, çok şık ve zarif çözümler oluşturabilmek. Henüz o seviyede değilim. Bunun farkındayım. İyi bir yazar, sanatçı gibi olmak istiyorum. Sesim güzel mi, kalemim mürekkebini ilhamla mı dolduruyor, kıvrak bir bedene mi sahibim, ya da zeki ve dahice fikirlerim mi var hiçbir fikrim yok. Sadece yaptığım işten bir sanat dalı ile uğraşırmışçasına, her sabah ilk kez seyircinin karşısına çıkacak ve karanlığın içinden perdeyi aralayıp seyirciyi ve sahneyi izleyen bir tiyatro oyuncusu gibi, dünya rekorunu kıracağı gün Usain Bolt’un adanmışlığını kendimde bulmaya çalışıyorum. Ve sadece istemek değil, birçok gün aynı heyecanı taşıyorum, yaşıyorum, bir sorunu çözdüğümde sessizce kendi içimde havalara uçuyorum. Böyle konuşuyorum ama bu bahsettiklerim \"n'olur beni atmayın, ben böyle iyiyim, şöyle tırı vırıyım\" seviyesindeki ucuz ve basit gayeler ile yazıya dökülen düşünceler değil, içten gelen seslerin yankısı sadece. Elbette  biraz fantastic örneklerdi ama yine de yazmak istedim. ",
        "22": "127. Gün",
        "23": "Zamanın yavaşlaması gerekli, çok hızlı hareket etmekte.",
        "24": "Bugün ajax nedir ve nasıl kullanılır bu konuya baktım genel olarak. Ne olduğunu daha önce araştırıp görmüştüm fakat kullanmamıştım. Açıkçası kullanmanın da bir zorluğu pek yok hatta (.png uzantılı dosyayı bilgisayara yükleyemeyip bilgisayardan çekemesem de) kullanması daha güzel bir yöntem. Tam olarak tabii ki öğrenmedim ve kullanmadım fakat çok zaman alacak bir konu gibi durmuyor. Biraz daha matematiksel bir denklem kullanmak gibi geldi Ajax konusu. Nesne-ler hazır, property’ler hazır. Sadece denklemi doğru şekilde oluşturmak ve sonuçları bulmak için hesaplamanın yapılması gerekiyor. Elbette bu analoji birçok şey için de geçerli fakat Ajax’ın yapısı gereği bu formülize halini kullanabilmek yeterliymiş gibi geldi.",
        "25": "128. Gün",
        "26": "Dün XMLHttpRequest nesnesini kullanarak get ya da post metodu ile veri alışverişinin nasıl sağlandığını öğrenmiştim. Bugün de yine aynı sisteme dayalı fakat daha kolaylaştırılmış fetch api ile bu işlemlerin nasıl yapıldığını öğrendim, kendi kodumda da deneyip biraz pratik yapmaya çalıştım. ",
        "27": "XMLHttpRequest and the Fetch API same origin policy’yi takip etmekteymiş. Yani, diğer kaynaklardan gelen cevapta doğru cors header’ı yoksa sadece aynı kaynağa request gönderebiliyoruz. Kaynaktan kasıt ne peki? Protocol, host, ve port’u (eğer belirtilmişse) aynı olması gerekli. ",
        "28": "Genel olarak ajax-fetch api ile veri alışverişi konusunda bolca okumalar yapıp pratikte de yazmaya çalıştım. Farklı kullanım şekilleri olsa da genelde aynı kapıya çıkıyorlardı. ",
        "29": "Günün sözü:",
        "30": "God helps those who help themselves.",
        "31": "129. Gün",
        "32": "Bugün React Native’e giriş yapıldı. Çok basit şekilde component’ler oluşturulup görseller yaratıldı. Genel olarak konseptin anlaşılmaya çalışıldığı bir gün oldu. Yarın daha fazla ilerleme kaydedileceğini düşünüyorum.",
        "33": "Akşam yardım ettiğiniz için ayrıca çok teşekkür ederim.",
        "34": "130. Gün",
        "35": "Bugün moralim bozuldu takılı kaldığım yerlerden dolayı. Sonlara doğru artık  yılanın zehri vücudunun her yerine yayılmış ve geçici felç geçiren bir hayvan gibi bilgisayarın başında kaldım. O an uğraştığım ya da uğraştığımı sandığım problemlere dar bir bakış açısıyla bakıp çözümü akıllıca düşünüp bulmak yerine her tuşa basarak sorunu kaldırmaya çalışıyordum. Çünkü sinir etmişti çözememek. Sonlara doğru kendi düşüncelerim beni yemeye başlamıştı: “Yapamıyorsun işte, senden yazılımcı ya da bi şey  olmaz oğlum, zorlama, pes et”. İçimdeki Tyler Durden beni aşağılamakta, kendi kendimi dövmemi, kendime zarar vermemi istemekteydi. Kabusvari düşüncelerin aklıma gelmesini engellemeye çalışırken baktığım ve anlamaya çalıştığım konulara odaklanamıyordum. Sanki dünyanın sonuydu. Kendimle sanal bir yüzleşmeydi sanki (neyin yüzleşmesiyse artık).",
        "36": "Daha geniş açıdan düşündüğümde ise bazı zamanlar problemler yaşayabilirim. Her zaman istediğim şeyleri başaramayabilirim. Böyle bir durumla karşılaştığımda üzülebilirim. Çünkü meme isteyince ve annesi vermeyince bebek ağlar. Annesi hala vermiyorsa daha da ağlar. Ama meme istemeyi bırakmaz. O yüzden ben de meme istemeye devam etmeliyim (Benim istemem ne alaka öyle değil mi, bu nasıl bi mantık Buğra?). Bir kere ağlayıp memeye küsmek gibi bir durum söz konusu olamaz. Daha çok ağlayıp, çırpınıp, yırtınıp o memeyi almalıyım. Er ya da geç alacağım."
    },
    "part14": {
        "1": "131. Gün",
        "2": "Dün çalışırken akılda kalan muğlaklıklar bugün biraz da olsa giderildi. Dün yaşanılan problem: Farklı teknolojiler (birçok terminal komutu, strapi, postman, react native-{component,context, …diğer konular}-, asenkron fonksiyonu doğru kullanmaya çalışmak, iç içe component kullanmak ile ilgili sözdizimini doğru oluşturmak) ile birdenbire karşılaşılması ve hangi birinin anlaşılacağı ve ortada ne döndüğünü kendi kendine açıklayamayan bir insanın yaşadığı fatal error.",
        "3": "Bugüne gelelim. Düne göre kıyaslanamayacak kadar iyi geçti. Çünkü bilmediğim konularda bir şeyler yapmaya çalışmaktan çok onları anlamaya, konsepti kafamda oturtmaya çalıştım. Sırayla gidelim:",
        "4": "İlk önce Context’in ne olduğuna sil baştan tekrar baktım. Ağaç içerisinde bir prop’un kökten en uçtaki dala ulaşabilmesi için normalde gövdedeki her kısımdan ve budaklanmadan geçmesi gerekli. Fakat bu datanın(prop) hepsine uğrama zorunluluğu karmaşıklığı oldukça arttırabilir. Context burada bize provider’a erişen consumer component’lerin erişebildiği global bir veri (state) sağlar.",
        "5": "Component kısaca bir Javascript fonksiyonu gibi, prop ise input. State prop’a benzese de private ve component tarafından control ediliyor. State güncellendiğinde re-rendering gerçekleşir. Component’ler React’ın bize verdiği bir armağan gibi. Kodların tekrar kullanılabilirliğini sağlayan yapıtaşları. Bir button componenti yazdığımızı düşünelim. Her buton kullanılan sayfada tekrar tekrar button için kod yazıp tekrara düşmek yerine aynı component’i kullanabiliriz. Aynı component’in farklı varyasyonlarını da yaratabiliriz. Aynı button componentinin farklı varyasyonlarını kullanarak tutarlı bir tasarım elde ederiz (Her sayfada ilgisiz ve örtüşmeyen butonlar kirli ve tutarsız bir görünüm sağlayacaktır. Uygulamanın hafızalarda kalan kendine özgü tasarımı bu olmamalıdır).",
        "6": "Sonrasında tavsiyeniz ile tıpkı bir web sitesi projesinin mimarisini oluşturmak gibi, react projesinin de nasıl bir mimariye, klasör dizinine, design pattern’e sahip olması gerektiği üzerine okumalar yapıldı. Web projesi mimarisinde olduğu gibi burada da tek bir doğru veya yanlış olmadığı gibi herkesin best practice’i kendi yaklaşımıydı. Özellikle iki dizaynın sıkça bahsedildiği görüldü:",
        "7": "Componentlerin atomik yapı (atom-molecule-organism-template-page) ile oluşturulduğu bir proje mimarisi vardı. Burada atomlar küçük gruplara bölünemeyen en küçük yapı taşı componentlerdi. Moleküller atomlardan oluşan ve tek bir şey yapan bir gruptu. Form alanı gibi düşünülebilir. Organizma ise moleküllerden oluşan ve app’in daha kompleks  parçasını oluşturan bir yapıydı.  Template ise adından da anlaşılacağı gibi bir sayfanın layout’ı, template’i idi (Örneklendirme: Nesnenin template’i class. Sayfa ise template’in instance’ı). Diğer sıkça karşılaşılan dizayn ise Container/Component konsepti idi. Mantığı anlaşıldığı kadarı ile componentleri elden geldiğince stateless yaparak onları “dump” olarak görmekti. Container ise hem bir controller hem de sayfanın kendisi olarak davranıyordu. Bu konunun çok fazla dezavantajı ile geçmişte karşılaşılmış ve şimdi de bunun için optimize çözümler getirilmiş (design pattern’lardan command pattern’i uygulamak, hook’ların yardımı ile geliştirme yapmak,, vs.) fakat farklı farklı uygulamaları olduğu için ve saat de geç olduğu için sonra değinmeyi düşünüyorum. Ama atomik dizaynın anlatıldığı referans kaynaklarda container/component  konseptinin ölçeklenebilir olmadığı, ne iş yaptığının belli olmadığı (sayfa mı yoksa controller gibi hareket eden stateful bir component mı) gibi konulara değinilip bunu kullanmaya gerek yok denilmiş. Gri taraftan bakınca ikisinin de oldukça fazla kullananı var ve bizim işimize en çok hangisi yararsa ve gelecekte daha az soruna yol açacak hangisi ise ona göre bir dizayn oluşturmak faydalı olacaktır. Seçenekler ise sadece ikisi değil bambaşka bir yapıda olabilir. ",
        "8": "Bu detaylı isimlendirmelere girmeyen ve React’ı oldukça güzel anlatan bir kaynak açıkçası daha çok dikkatimi çekti:",
        "9": "React proje mimarisi",
        "10": "Açıkçası klasörlendirme yöntemini kişisel olarak beğendim ve web’te genel olarak tavsiye edilen şekle benzediğini farkettim. Tabii container/component konseptine daha yakındı. Bu konu üzerine çokça fikir var ve benim fikrim web’teki konseptin benzerini burada oluşturmak. Ki yukarıdaki linkte de bir benzerinin olduğu kanısındayım.",
        "11": "Farklı bir konuya girilecek olursa, hook’un varlık sebebini biraz daha iyi anladım. Component’ler resusability’yi arttırıyor fakat farklı component’lerin kullandığı bir yapı olduğunu düşünelim. İşte burada biz özel bir hook’u kendimiz oluşturabiliyoruz.",
        "12": "SRP’nin react native’ e çevrilmiş hâli:",
        "13": "“Bir component ya da bir hook; tek bir işi yapmalı, o işi çok iyi yapmalı ve yalnızca o işi yapmalı.”",
        "14": "Yine yukarıdaki linki referans alarak şu cümleyi direkt almaktayım:",
        "15": "“Birbirleriyle direkt olarak haberleşemeyen fakat içerik olarak birbirleriyle bağımlı her bir modül için ayrı birer context yapısı kurmalısınız. Ek olarak; context, içinde tuttuğu herhangi bir state güncellemesinde bağlı olduğu her bir componenti günceller. Context’i dinleyen componentler zaten o context’e ihtiyaç duyuyor olmalı. Eğer çağırdığınız herhangi bir state’i gereksiz görüyorsanız; ya o state’tin context’e işi yok ya da context’i yanlış kurgulamışsınız demektir. ”",
        "16": "Redux ve context api kullanımı arasındaki farklar hakkındaki bir yazı",
        "17": "benim konuyu daha iyi anlamamı sağladı.",
        "18": "Reducer, provider, context, state, useState ve useReducer, dispatch, action gibi kavramları daha iyi kavradım. Henüz useReducer ve useState arasındaki farkı çok bilmesem de eğer birden fazla state’i aynı context’te kullanıyorsam burada useState yerine useReducer’ı kullanmamı react’ın dokümantasyonu tavsiye etmiş. Daha iyi anlamaya çalışacağım.",
        "19": "API’den data alımı,context kullanımı, re-render konusuna yarın sabah tekrar bakmayı düşünüyorum. Hem redux’ı hem react’in yazımında bulunanlardan",
        "20": "birinin yorumunu",
        "21": "görünce, oop çalışırken Alan Key’in düşüncelerini okumak gibi bir hissiyat oluştu.",
        "22": "Konu hakkındaki sis perdesi biraz aralandı gibi hissediyorum. Tabii ki daha çok çok fazla öğreneceğim bilgiler, yapacağım hatalar, sevineceğim gelişmeler olacaktır. Tek bildiğim düne göre ilerleme oldu.",
        "23": "132. Gün",
        "24": "Günün başlarında yine genel konsept üzerine okumalar yaptım. Dediğiniz gibi teorik bilgileri ne kadar çok edinmeye çalışsam-edinsem de pratiğe dökmedikçe çok bir anlamı olmuyor. Bocalamalar yaşanıyor. Başkalarının problemlerini ve geliştirilen çözümleri okumak lebette faydalı fakat kendim bir probleme sahip olmadan o problemi anlamam da kolay olmayabilir (empati yapmak gibi düşünülebilir: “hmm evet bu sorunla ben de karşılaştım, ve çözümler bu şekildeydi-şekildeymiş”). ",
        "25": "Sonrasında dediğiniz üzere bir resme tıklayınca onunla ilgili bir sayfaya gitmesini sağladım. Fakat bunu yapmak biraz uzun sürdü. Uzun sürme sebepleri: Navigasyonu nasıl kullanacağımı hiç bilmiyordum. O kütüphaneyi indirdim. Dokümantasyonunu işime yarayacak kadarı ile okudum. Benzer kod yapıları kullanarak kendi problemimi çözmeye çalıştım. Zamanımı alan problemlerden biri: scrollView ile sayfadaki tüm kaynaklar direkt yüklendiği için onu kullanmaktan kaçınıp Flatlist’i (web’teki lazy initialization’ı default olarak yaptığı için) kendime şiyar edinmiştim. Fakat nereden kaynaklandığını çözemediğim bir sorundan dolayı scroll’u oluşturamadım. Buna tekrar bakacağım. Sonrasında ise navigasyon sırasında parametre aktarımında hata ile karşılaşıyordum. Object destructuring’I iyi bilmediğim için ve copy-paste code’u yanlış kullandığım için böyle bir sorun ile karşılaşmışım. Sizin de yardımınızla onu düzelttim. Şu an kod görünürde normal şekilde çalışmakta. Ama komponentler herhangi bir state kullanmamakta (sadece navigasyon ile alakalı kısımda kullanılmakta fakat o kütüphanenin kendi nesnesinden gelen bir özellik). State tutulmadığı için doğal olarak context’e de ihtiyaç duyulmadı. Temel işlemleri yaptıktan sonra geliştirmeleri de yapabileceğimi düşünüyorum. Özellikle Javascript’e daha çok hakim ve debug kabiliyetlerine daha çok sahip olunabilir. Olunacaktır.",
        "26": "133. Gün",
        "27": "Bugün öğrendiklerimi, yapmayı düşündüm çoğu şeyi toplayıp yapmayı düşünmüştüm. Fakat birbirine çokça bağlı component bulunduğu için kod iyice karışmıştı. İşin içinden çıkılabilirdi tabii ki ama gecekondu çıkar gibi olmuştu yapı. Sonrasında Bir siteden sayfayı scroll ettikçe sonsuza dek fotoğrafların bir api aracılığıyla çekilip gösterildiği bir örnek  gördüm. Sadece onu anlamaya çalıştım. Aynı klasör yapıları, aynı dependency’ler ile her şeyi birebir aynıydı. Hem context, hemp api’den veri çekme, hem bol bol callbackler, hem de basit görünen güzel bir mantık ile yazıldığını düşündüğüm için anlamak için çabaladım. Açıkçası o kodda yapılanları genel manada anladım fakat anlaşılmayan yerler de kaldı. Yarın sabah o örnekteki anlaşılmayan kısımlara (özellikle useCallback ve useEffect tam oturmamış, onu kavrayacağım) bakılacak. React Native’de sadece Css Javascript tarafı var olduğu için sadece fronent olduğunu düşünürdüm fakat controller kısmını da içeriyor anladığım kadarıyla. Navigasyon, veri iletimi (state management), biçim(style) kısımları en genel uğraşılan alanlar anladığım kadarıyla. Genel manada düşününce ne var ki bunda yaparım diyorum fakat işler o kadar olmayabiliyormuş. Egoma yenik düşmeyip işe hep ilk başladığım gibi acemiliğin getirdiği çocuksu merak ve tutkuyla bakmaya devam etmeliyim. Edeceğim (Lafla peynir gemisi elbette yürümez, icraatte de elimden geleni yapmaya çalışıyorum).",
        "28": "134. Gün",
        "29": "Günün benim anlam ve önemi Stackover’da ilk  kez bir soruya",
        "30": "cevap",
        "31": "yazmam. Yine o birçok yerde sorulan ama doğru düzgün cevaplanmayan basit sorulardandı aslında (2015-16 civarı cevabı github'ta verilmiş gerçi, o da eklendi). Hiç hakim olmadığım ve yeni başladığım bir konuda yazmak elbette doğru olmayabilir fakat karşılaşılan sorunun sebebini biraz da olsa anladığımı düşündüğüm için yazmak istedim. Yanlışsa da silerim ya da güncellerim tabii ki utanılacak bir şey yok diye düşünüyorum. ",
        "32": "Onun dışında render konusunda verdiğiniz bilgiler için teşekkür ederim. useEffect’in kullanımı siz anlattıktan sonra tam olarak kavradım.",
        "33": "Farklı olarak ne yaptım derseniz, Google’a “react native examples” yazıp, karşıma çıkan ufak örnekleri ben de onlara bakarak ya direkt copy paste olarak alıp yorumladım ya da kendim yazmaya çalıştım. Bugünlük bu kadardı. ",
        "34": "135. Gün",
        "35": "1 haftadır React’a baksam da bugün kullandığınız yapı ile ilk kez karşılaştım. Bir komponentin çocuklarına bazı özellikleri geçirmek için her çocuğuna tek tek o özelliği ‘bahşetmek’ gerekiyormuş anladığım kadarı ile. Çok güzel bir yapı gibi görünmüyor ama çözümü de o yapı sağlıyor. Farklı bir bakış açısıymış. Yaptığımız şeylerin sihir olduğunu düşünmüyorum ama bazen büyüleyici geliyor. Bunun yanlış olduğunu düşünmüyorum. Onun dışında komponentleri oluşturmak, kullanmak zevkli fakat aralarındaki ilişkileri kurmak, asenkron yapıları (olduğunda) kullanmak beni zorlayabiliyor. Daha da zorlarsa sevineceğim çünkü henüz yeni başladık.",
        "36": "136. Gün",
        "37": "Bugün bir yerde sıkıştım. Günün sonuna doğru istenen çözüm için yapılması gerekeni buldum:",
        "38": "Bu ikisi birbirinden farklıydı. Ben altta bulunan kütüphaneyi kullanıyordum. İkisi arasında iki fark vardı genel olarak: Birinci Kütüphane çok daha fazla özelleştirilmeye müsaitti. İkincisi ise özelleştirilmeye çok açık değildi fakat performans açısından diğerine kıyasla daha hızlıydı. Birincide verilen görevdeki navigasyon şekli direkt olarak sağlanıyordu (denediğim örnekte işe yaradı). İkincisinde ise navigasyon state’inde her yeni gelen state’i overwrite etmekteydi. Bu yüzden asla aradaki screen’lere ulaşamıyordum. Tüm gün bunu gidermenin yolunu aradım. Türlü denemeler yaptım ama bulamadım. Açıkçası bottom tab  kütüphanesi içinde yer alan dispatch metodu ile istenilen şey yapılabilir mi diye düşündüm, uğraştım fakat sonuca ulaşamadım. Yarın sabah kaldığım yerden devam edip o sorunu çözmeye çalışacağım.",
        "39": "137. Gün",
        "40": "Bu sabah sizin yaptıklarınızı dikkatle izledim çünkü babamın aşçılıktan öğrenip bana sıkça söylediği “elin değil gözün hırsız olsun” düsturu ile davrandım. Sonrasında drawer navigasyonunu yapmaya çalıştığımda ise yine version hatasından dolayı bir kütüphane ile ilgili hata ile karşılaştım. Sorunu Google’ladığımda farklı çözüm yöntemleri buldum. Dosyalardaki bazı kodlarda değişiklikler yaparak ve ilgili kütüphaneyi kaldırıp farklı bir sürümünü ekleyerek çözüme ulaşabildim. Başta daha da bozarım düşüncesi ile elim titrese de sonrasında “korkanın çocuğu olmaz” düsturu ile elimi korkak alıştırmadan ve dikkatle çözüme ulaştım. Sonrasında sayfaları dosya ve klasör yapısına dönüştürme problem vardı. Kendi oluşturduğum proje ölçeğinde bir yapı kurmaya çalıştım. Web’te bu konu üzerinde araştırma yaptığımda arketipe göre değil özelliğe (group by feature, or group by archetype) göre sınıflandırma yaparak bir dosya-klasör düzeni kurmamız genelde öğütleniyordu. Mobil tarafında da aynı ilkeyi düşünsem de örneklerde en sık screen-component yapısını gördüğümden dolayı on duruma yakınsayan bir çözüm oldu. Son verilen görevde yarın kaldığım yerden devam edeceğim. ",
        "41": "138. Gün",
        "42": "Bugün bir konuda zorlandım. Epey fazla zamanımı aldı çözebilmek. Sorun asenkron bir fonksiyonu kullanamama özrümden kaynaklanıyordu. Sorunun kaynağını biliyordum. Senkron bir reducer fonksiyonu içerisinde asenkron olarak çalışıp sunucudan cevap alan bir fonksiyonun cevabını senkron bir yapı içerisinde kullanmaya çalışıyordum. Siz bana güzelce açıklayıp daha önce aynı konudaki hatalı kodumu düzeltmiştiniz. Bugün çözüme ulaşmakta zorlanmamın sebebi, çözüme giden yolu etraflıca düşünüp sistemlice kurgulamamamdan kaynaklanıyordu. Reducer’ın asenkron yapılması ya da reducer içinde asenkron fonksiyon nasıl kullanılıra dalmıştım. Oysa ki reducer’ı tetikleyen dispatch fonksiyonunu, kullandığım asenkron fonksiyona callback olarak verseydim sorun düzelecekti. Ki çok geç de olsa bu çözüme ulaşabildim. Ulaşınca da çok mutlu oldum tabii ki. Asenkron yapı kullanmak hala zorlasa da kendim bir çözüm üretebiliyorum sizlerin de yardımıyla.",
        "43": "Sonuç olarak kullanıcı girdisine göre login state’ine global olarak tüm sayfalardan ulaşılabiliyor ve değişebiliyor. Yarın kullanıcı çıkışını yapabilirim. Kullanıcı giriş ve çıkış yaptığında state’e göre komponentlerin veya sayfaların gösterilmesinde bi değişiklik yapabilirim. Bence gayet bu işi çözeceğim gibi görünüyor.",
        "44": "139. Gün",
        "45": "Bugün biraz iyileştirmeler yaptım yazdığım kodlarda. Öncelikle sunucu iletişimi ile ilgili kısmı ayrı bir sınıfa koydum. Bu sayede direkt oradan api iletişimi için ihtiyaçlarımı temin edebilirdim. Bir fonksiyon komponente koymuştum başta fakat nesne oluşturup http metotlarını nesneye eklenebilecek post, get gibi fonksiyonlar ile çağrılabilirdim. Bu yüzden sınıfa döndürdüm fonksiyon komponenti. Kullanışlı olur diye düşündüm. ",
        "46": "Ayrıca kullanıcı token’I oluşturma konusunu front end tarafında yapmıştım fakat sonrasında sunucu tarafında tamamladım. Önce kullanıcının telefonundan elde edilen unique id yi aldım. Sonrasında da unique id nasıl oluşturulur araştırması yaparken karşılaştığım",
        "47": "şu cevaptaki",
        "48": "örneklerden birini kullandım. Algoritması nasıl işliyor merak etsem de yarın iş sonrası bakmayı düşünüyorum. Çünkü nasıl olur da unique bir id oluşturulabiliyor sonlu sayıda uzunluğu bulunan bir string ifade ile henüz anlamadım. Özetle kullanıcının telefonunda alınan unique id ve kendi oluşturduğum unique bir değeri birleştirerek kendimce bir token oluşturdum. Sonrasında kullanıcı sunucu ile iletişime geçtiğinde header'da bu token’I göndererek kendi varlığını ispatlayabilir. Kullanıcı uygulamayı silse dahi onun telefonundan gelen unique id bizde kalabileceği için, bilgileri tekrar kullanılabilir, hatırlanabilir. ",
        "49": "Sonrasında geçen hafta okumalar ve araştırma yaparken karşılaştığım konuya pratikte şahit oldum: state’te nesne olduğunda ve nesnenin içinde bir elementin değerini değiştirdiğimde değişiklik algılanmıyordu. Dolayısıyla da yeniden render yapılmamaktaydı. Sizin de dediğiniz şekilde çözüme ulaştım. Şu an aklımda kalan şekilde anladığım şuydu: biz nesneyi güncellemiyoruz. Yeni bir nesne oluşturuyoruz.",
        "50": "Sonrasında  hala ona mı bakıyorsun deme ihtimalinizi düşünsem de yine de call by value-reference konusuna çok az baktım. Bu sefer farklı bir şeyler karşılaştım. Ne pass-by-value, ne de pass-by-reference olduğunu öğrendim object konusunun. Açıkçası php, javascript ve birçok modern dil default olarak pass by value’yu kullansa da object konusunda",
        "51": "diye bir evaluation strategy siydi. ",
        "52": "Anladığım kadarı ile nesneler ne klonlanıyor ne de kopyalanıyor. Nesneler, paylaşılıyor. Evet, paylaşılmasından söz edilmiş. Örnekle gidelim ",
        "53": "ilk cevaptan",
        "54": "alınmıştır",
        "55": "Bildiğimiz tek şey, default olarak her şeyin pass-by-value olarak geçtiği. “num” değişkeni bilindiği gibi kopyalanarak (value’su alınarak) geçtiği için değişmemiştir. Fonksiyon içinde işlem yapılan kendisi değil artık. Obj1 nesnesinin geçişini vikipedi’de açıklanan şekilde okuyalım . obj1 bir kutu. Ben kutunun içeriğini değiştirebilirim. Ama kutu yine aynı kutudur. Benim okuduğum gördüğüm bildiğim her şey sadece kutunun kendisi. İçeriğinde bugün ayakkabı olur yarın kablo-bozuk elektronik aletler olur bu beni ilgilendirmez. Dolayısıyla ben kutunun içeriğini değiştirebilirim. Başkası da kutunun içeriğini değiştirebilir. Dolayısıyla kutu aslında paylaşılan bir şeydir. Dolayısıyla en basit manada eski yöntemle düşününce pass by reference(call by sharing, alias(takma ad), vs.) gibi görünür her şey. Oysa değildir. Neden değildir bu kısma gelelim:  eğer pass by reference olsaydı obj2 de değişmeliydi. Fakat bir değişim olmadı. Neden? Biz kutuyu fonksiyon ile paylaştık. Al bu kutu ile istediğini yapabilirsin. Peki o ne yaptı? Verdiğimiz kutuyu hiç kullanmadı!. Onun yerine farklı bir nesne oluşturup, bizim kutumuza referans olan değişkene, _“Sen artık bu yeni nesneye referans ol, bize gelen kutuyu bırak”_ dedi. Dolayısıyla obj2’de hiçbir değişim olmadı. Bu kutu örneğini açıkçası sevdim. Her ne kadar konu anlaşılsa da bazen karışıklıklar olabiliyor. Biraz daha iyi anlaşılmasını ve örneklendirilmesini sağlıyor.",
        "56": "Hala daha javascript’in nasıl çalıştığını tam bildiğimi söyleyemem. Ama mümkün zamanlarda daha iyi şekilde anlamaya, öğrenmeye çalışacağım. Her şeyin nesne olduğunu ya da nesne gibi davrandığını biliyorum. Yukarıdaki örneği düşününce, 10 neden değişmedi? 10 bir kutuydu. On ile çarptığımızda (assignment yaptığımızda), eşitlediğimiz değer kendisi değildi. O farklı bir kutuydu. 100’dü o. Belki bu düşüncem hiç doğru değildir (primitive değerleri de obje olarak görme-javascript'te). Direkt pass-by-value diyerek geçebilirim fakat etraflıca düşünmek ve farklı bakış açıları yakalayabilmek ya da yakalamaya çalışmak keyifli ve tatmin edici.",
        "57": "Onun dışında gün sonuna doğru mobil sitedeki problemlere, olsa güzel olur diyebileceğim farklılıklara baktım. Biraz da farklı e ticaret sitelerinin uygulamalarına baktım. Navigasyonlarına, yönlendirmelerine, dizaynlarına göz gezdirdim. Bence yapacak çok şey var. Bence bu harika. Bence ben de çokça katkı sağlayabilirim.",
        "58": "140. Gün",
        "59": "Bugün sadece mobil uygulamadaki hatalar, problemli yerler incelendi. Aslında mobil uygulama tamamen incelendi.  Birbirini tekrar eden, estetik açıdan çirkin göründüğü düşünülen yerler de rapora eklendi. Uygulamayı direkt fatal error’a sokan kısımlardan da bahsedildi. Bence yapacak çok şey var. \"Krizi fırsata çevirme\" deyişi gibi kendime yapabileceğim birçok şey bulabiliyorum. Umarım yapacağım. Yaptığım iş zorunluluk gibi gelmiyor. Gelse büyük ihtimal yapmıyor olurdum. Zorunluluk gibi gelmemesinde sadece işin kendisi değil, işin yapıldığı ortam da çok etkili. Çok şükür ortam bana köstek olan değil beni teşvik eden kıymetli bir ortam. Yapılacak, öğrenilecek o kadar çok şey var ki çalıştığımız konularda… İyi bir yazılımcı olabilirsem, tek yapacağım şey yazılım olmayacak diye düşünüyorum (45 yaşında bir teknede yaşayıp balıkçılık da yapılabilir, direkt akla \"CEO olacağım, şirket sahibi olacağım, Newton, Einstein, Galileo gibi tarihe geçeceğim, dünyayı kurtaracağım (neyden?),\"  gibi fikirler gelmemeli tabii ki). Ama yazılımcı olmak bana büyük bir katkı sağlayacaktır diye düşünüyorum.",
        "60": "Bu arada belirtmek istedim; one drive’daki “günlük” klasörleri, size gönderdiğim raporlardan oluşuyordu.  Hatta “xxx” diye bir klasör vardı ki orda da javascript dosyaları vardı (clickbait dosya ismi koymak güzel geliyor nedense :)). Yine teknik olmaktan öte bir rapor oldu. Ama bugün gönderdiğim pdf’te biraz daha teknik olmaya çalıştığım için bu durumun sorun olacağını sanmıyorum."
    },
    "part15": {
        "1": "141. Gün",
        "2": "Öncelikle ustama karşı bugün bir yanlışım olduysa özür dilerim. Çok bilmiş gibi görünüyorsam bazı konularda, o benim gafletimdir. Çok az şey bildiğimin farkındayım. Sadece bazen kesin bir dille konuşma yanılgısına kapılabiliyorum. ",
        "3": "Bugün başlangıçta bir görev olmadığı için kendimce react-native ile ilgili iki konuya baktım: internet bağlantısı kontrolü nasıl yapılır ve klavye nasıl saklanır farklı bir yere tıklayınca. Onların yollarını okudum. Sonrasında aklıma bir şey gelmeyince dün gördüğüm bir makaleyi (yazılım dizaynı ve programlama üzerineydi genel olarak) okudum. Ama bitiremedim. Bitirince burada özet geçeceğim diye umuyorum. Sonrasında mobil uygulamanın kaynak kodlarını siz verdiniz. Sizlerin yazdığı konu, uygulamanın arka tarafta nasıl çalıştığını, bağlantıları ve ilişkileri kavramaya çalıştım. Yüzeysel olarak bir şeyler anladığımı düşünüyorum. Ternary operator’ları, clean code’u görünce etkilendiğimi söylemeliyim.",
        "4": "O boldan boldan bulduğum problemlerden (bana göre bir kısmı) 3 tanesine baktım bugün. İki tanesi (1-İlanlarımdaki duruma tıklayınca uygulamadan çıkması, 2-Input kısmında kırmızı renkli uyarı ile input value’sunun üst üste gelmesi ) tamamlandı. İkinciyi size söylemedim açıkçası. “Bunu yapmaya gerek bile yok” diyebilirsiniz diye. Üçüncüde ise yarıda kaldım. Ödeme yöntemlerinde tüm ödeme yöntemlerine basıldığında hepsinin detaylarının görünmesi. Her birine basıldığında açılması ile ilgili bir state verilmiş. Fakat parent elementlerine bu state’i (useState kullanılmış, useContext’te olabilir tabii ki. Ama etkilenen elementler kardeşler olduğu için useState daha mantıklı olabilir tabii) verirsem ortak state sayesinde birinin hareketi diğerlerini etkileyebilir.",
        "5": "Bugün de böyleydi.",
        "6": "Bu videodaki",
        "7": "seviyeden,",
        "8": "buradaki",
        "9": "yazılımcının (Lemi Orhan Ergin) anlattığı kartalların seviyesine çıkmak umudu ile çalışılan bir başka gündü.",
        "10": "142. Gün",
        "11": "Bugün arama sonuçlarının gösterimindeki problemi buldum. Siz düzelttiniz (En azından sorunun nasıl çözüldüğünü anladım). Sonrasında kayıt sayfasında göz gezdirdim. Bir eksiklik vardı. Görünümlerde düzeltme-ler gerekliydi. İstediğim şeyin benzerini yakaladım fakat henüz bitmedi. Açıkçası sizin dediğiniz gibi olmadı. O yüzden yarın sabah tekrar bakacağım.",
        "12": "143. Gün",
        "13": "Bugün başlangıçta form işlemi üzerine dün gideremediğim problemli kısmı düzeltmeye çalıştım fakat hala yapamadım. Sonrasında kategori sayfasında iken farklı bir kategori sayfasına ulaşmak istenilmesi durumunda sayfanın güncellenmemesi durumu bulunuyordu. Navigasyon farklı sayfaya gidilmediğini söyleyerek navigasyon sağlamıyordu doğal olarak. En son oluşturulan çözüm navigasyon kütüphanesi ile sağlanıyordu. Yeni gidilecek sayfayı navigasyon stack’ine push ediyordu verdiğimiz parametre ile. Önceki çözümümüz ise yeni problemlere yol açıyordu fakat bence çok güzeldi. Sorunun nereden kaynaklandığını bulamamıştım evet ama yakınlarında dolanıyordum. Bu da bir şey diyemem çünkü benim sorunu çözmem gerekiyordu. Yeni problemlerle karşılaştıkça daha verimli olmaya ve uygun çözümler üretmeye çalışacağım.",
        "14": "144. Gün",
        "15": "Bugün yardım bileti detayı sayfasındaki hatalı yerleri düzeltmeye çalıştım. Açıkçası günün sonunda düzeldi de. Ama tek başına yapmadım. Daha hızlı sürede ulaşılabilecek bir çözümdü. Fakat beklediğimden çok fazla zaman aldı. ",
        "16": "Onun dışında javascript ile uğraşırken stackover’da bir soruyu görüp onu da cevapladım ama oldukça basitti (çok temel dizi işlemleri üzerineydi). Öğrenimime yardımcı olan mecralara, insanlara katkıda bulunmak bence çok güzel.",
        "17": "\"Sende bir yumurta var, bende bir yumurta var. Ben yumurtamı sana verdim, sen yumurtanı bana verdin. Sende bir yumurta var, bende bir yumurta var. Ama, sende bir bilgi var, bende bir bilgi var. Ben bilgimi sana verdim, sen bilgini bana verdin. Bende iki bilgi var, sende iki bilgi var.\"",
        "18": "hikayesinde olduğu gibi, bilgiyi paylaşınca benden bilgi eksilmiyor, aksine daha çok bilgiye erişilebiliyor. ",
        "19": "145. Gün",
        "20": "Bugün de basit bir problem vardı. Onu farkettim. Sonrasında api’den cevap dönmediği anlaşıldı ve backend tarafından sorun giderildi. Bu hafta içinde düzeltilen problemler size teslim edildi. Genel olarak boş zamanlarda react üzerine bilmediğim şeyleri öğrenmeye çalıştım. ",
        "21": "146. Gün",
        "22": "Bugün kendimi çok geliştirebileceğim bir aktivite yapamadım. Tekrar react navigasyona, temel javascript ile ilgili bir probleme, mobil uygulamamıza baktım, göz gezdirdim. 5 günde 7-8 yer fixlendi fakat çoğunluğunu yine siz yapmış oldunuz. ",
        "23": "5 gündür olan şey: ilgimin ve hep yapmaktan zevk aldığım şeylerden aldığım zevkin azalması, dikkatimi yapmam gereken şeylere tam verememem, sürekli oluşan yetersizlik hissiyatı tarzı şeyler. Başta sadece benden kaynaklandığını düşünüyordum bu durumun ama şu an öyle düşünmüyorum. Başta, yeni konularda çalıştığım için böyle olduğunu kendime telkin ediyordum fakat bu değildi cevap. Şimdiye dek yaptığım neredeyse her şey zaten yepyeniydi ve yerine göre zorluydu benim için. Balık gibiyim sanırım. Denizde bir balığı eliniz ile tutma olasılığınız çok düşüktür. Çünkü balık elden kayar. Daha sıkı kavrarsanız tutabileceğinizi düşünürsünüz ama yine de kayar. Balık basitçe akvaryumda durabilir, denizde de, okyanusta da. Temel ihtiyaçlarına (su, besin, oksijen) sahip olması yeterlidir. Temel görevini yerine getirir: İnsanlara yem olmak, ekosistemde belli bir yer kaplayıp doğanın dengesinde bir rol edinmek, yüzmek gibi.  Son olarak, 335 yıl önce “Doğa Felsefesinin Matematiksel İlkeleri”nde bu durumu Newton belirtmiş: Etki-tepki.",
        "24": "147. Gün",
        "25": "Bugün güzeldi. Yaptığım işe oldukça iyi odaklanabildim ve verim alabildim. Ne yaptım? Giriş yaparken Android uygulamada bir uyarı çıkmaktaydı. Ve uyarıdaki durumun memory leak’e sebep olabileceğini, use effect’i düzgün kullanmam gerektiğini söylüyordu. Şimdilik orası yarıda kaldı.",
        "26": "Sonrasında akşam 17.30’a kadar Single sign-on nedir onu araştırdım. İlk önce en bilinen teknoloji firmalarının sitelerinde yazılanlardan başladım. Sonrasında da gittikçe spesifikleşti ve karşılaştığım birçok kaynağı taradım. Özetleyelim. Adı üzerine “tek bir oturum ile birden fazla uygulamaya erişim” üzerineydi tüm konu. SSO’nun avantajları olduğu gibi dezavantajları da elbette bulunmaktaydı fakat avantajları ağır basmaktaydı kişisel görüş olarak. SSO için kullanılabilecek birden fazla protokol vardı ve bunlar da öğrenildi. Nasıl çalıştığı üzerine de okumalar yapılıp not edildi. Genel manada anladığımı düşünüyorum. Protokoller arası farkları öğrendim örneğin. Authenticaton ve authorization arasındaki farkı kendi açımdan tazeledim. Kullanılan kütüphaneleri araştırdım. PHP ve node.js için çok farklı seçenekler vardı. En çok kullanılanları rapora ekledim.  Farklı servisler (Authelia, Apereo/cas, Keycloak) ve Java için de kullanılan bir kütüphane vardı ve çokça bahsedilmişti fakat onu rapora dahil etmedim.",
        "27": "Günün kapanışına doğru karşılaşılan güzel bir terim: “Rational ignorance”. Sizin de sıkça tekrarladığınız, gereksiz bilginin hafızada yer almamasına dair düşünce üzerine bir terimdi. Tanımı ise hem kendisi kadar güzel, hem de içerik bakımından ingilizce pratik yaptıracak kadar dolu:",
        "28": "“Rational ignorance is refraining from acquiring knowledge when the supposed cost of educating oneself on an issue exceeds the expected potential benefit that the knowledge would provide.”",
        "29": "148. Gün",
        "30": "Bugün genel olarak MVC’nin ne olduğuna baktım. Nasıl oluşturulduğuna bakmıştım fakat tek başıma yapmam zordu. Çünkü ihtiyaçların neden kaynaklandığını ve hangi sorunlara çözüm olarak ne yapmam gerektiğini hala anlamıyordum. ",
        "31": "Sizin de yardımınızla sıfırdan bir mimarinin temellerini tasarlamanın (en azından başlangıçtaki temel safhaların) nasıl olduğunu gördüm. Daha detaylı bir raporu konuyu daha iyi kavradığımda yazacağım. ",
        "32": "149. Gün",
        "33": "Açıkçası bugün kod yazmadığım için üzüldüm fakat siz yazarken de neredeyse her kod parçasının neden yazıldığını anladığımı düşünüyorum. Son birkaç kısım birazcık karışsa da tekrar bakınca anlayabileceğimi düşünüyorum. Bugün de MVC’ye uygun olarak bir yazılım mimarisinin nasıl oluşturulduğuna tanık olup, her bir kısmı en iyi şekilde idrak etmeye çalıştım. Boş kaldığım zamanlarda Laravel ya da Sympony’nin kodlarını ve dokümantasyonlarını inceledim. ",
        "34": "Çok iyi bir şekilde bu yapıyı öğreneceğime, hatta yakın zamanda basit seviyede de olsa bir benzerini oluşturabilecek seviyeye gelebileceğime inanıyorum. Bugünkü en büyük kazanımlarımdan biri de bu inançtı.",
        "35": "150. Gün",
        "36": "Bugün ilk önce dün yazdığımız koda baktım. Anlamadığım yerler varsa anlamaya çalıştım. Genel olarak neyin ne için çalıştığını anladığımı düşünüyorum. O açıdan bir problem yaşadığımı sanmıyorum. ",
        "37": "Sonrasında cache’in ne olduğunu araştırdım. Siz zaten kısaca anlatmıştınız, ve bende sadece web caching’in ne işe yaradığını biraz biliyordum. Fakat bugün farklı bir cache’I de gördüm. CPU ile ana bellek arasında da bir önbellek kullanımı varmış. O konuya bakarken biraz eksen kayması yaşanıp farklı konulara girdim. Sonrasında tekrar çıkıp MVC’ye geri döndüm. Tekrar kendi kodumuz ile Laravel’in dokümantasyonunu inceledim.",
        "38": "6 ayda ne kadar ilerledin diye sorarsanız, sizi daha iyi anlayabildiğimi düşünecek kadar ilerlediğimi düşünüyorum. Yakın zamana dek sizin kısaca oluşturduğunuz bir kodu okumakta bile aşırı zorlanıyordum. En azından sizin konuştuğunuz yabancı dilin gramerini, stilinizi biraz da olsa çözdüm diye düşünüyorum. Sizin söylediğiniz kelimeleri tekrar edip, anlamlarını kavrayarak, kendim de cümleler kurmaya çalışıyorum. Çalışacağım. Başaracağım da. John Von Neumann, Harold Finch, Spiderman, The Chosen One olunabilir mi şu an herhangi bir fikrim olmasa da en azından kendim olup güzel ve zekice işler yapmaya çalışacağım.",
        "39": "Bugün aklıma uçuk bir fikir takıldı: Eğer veri ya da bilgi, maddeye (hacim ve kütlesi bulunan) ihtiyaç duymadan iletilebiliyorsa, var olabiliyorsa, maddesiz bir şekilde depolanabilir miydi? Kendi kendine var olabilir miydi? İmkansızdır belki ama düşünmek, başarısız da olsa yeni fikirlere ve hayallere sahip olmak gerçekten insanı huzurlu yapıyor genel olarak."
    },
    "part16": {
        "1": "151. Gün",
        "2": "Bugün programlama hakkındaki en büyük sevincimi kendi içimde yaşadım: Yazılan kodun kendinin farkında olabildiğini gördüm, gösterdiniz. Sanki yapılabilecek ve öğrenilebilecek o kadar çok şey varmış gibi hissediyorum ki, düşünmesi bile oldukça fazla haz veriyor.",
        "3": "Onun dışında bugün yine Laravel dokümantasyonuna baktım genel olarak. Cross site request forguery’nin nasıl engellenebileceğini ve mvc’deki yerini gördüm. View kısmına bakarken Blade template engine ile karşılaşınca ofEngine’I hatırladım ve daha çok dikkatimi verdim.  Laravel’deki Blade ile ilgili kod biraz fazla karışık geldiği için çok dikkatli inceleyemedim ama en temel seviyede template engine’in ne iş yaptığını ve nasıl çalıştığını anladığımı düşünüyorum.",
        "4": "Ek olarak, dilden bağımsız şekilde yazılan kodları okuyabilmenin verdiği haz da bambaşka. Elbette çok iyi değilim fakat kendimce kara cahil olmadığımı görerek öz-tatmin de olabiliyor.",
        "5": "152. Gün",
        "6": "Bugün ufkumu çok açan yeni bir şey öğrendiğimi söyleyemem. Mental açıdan oldukça sakin geçti. Blade’in snytax’ına tekrar baktım. Template inheritance’ın olduğunu okumuştum ama pratikte ne olduğuna bugün bakabildim. Blade’in, Laravel’in, MVC’nin alternatifleri ile de oldukça sık karşılaştım konuyu araştırırken. Bir yanım tekerleği yeniden icat etmemelisin darken, diğer yanım da işin mantığını öğrenmek için, kendini ispat etmek için yapmalısın diyor. Ama gerçek şu: var olan herhangi bir mvc framework’ü nü tank olarak düşünelim. Benim tanka ihtiyacım varsa direkt onu kullanabilirim. Ama eğer ben uçak yada Ferrari’ye ihtiyaç duyuyorsam onları kullanmalıyım, yok ise ben oluşturmalıyım.",
        "7": "Ayrıca gün boyu aklımın bir köşesinde öz farkındalığı olan program aklımdaydı. İyi ki gösterdiniz. Yarın büyük ihtimalle çalışacağım. Merak ettiğim konular ve yapmak istediklerim (side project olarak ya da kendime katmam gerekenler olarak) oldukça fazlalaştı. Algoritmalar kitabını bitirmem, özümsemem, hatim etmem gerekiyor. Öz farkındalığı olan bir programın yapabileceğini düşünmek, bunun üzerine nasıl bir proje geliştirilebilirdi diye düşünmeye zaman ayırmak istiyorum. Yazılım ve donanımın birleştiği yerde olanlara hiç hakim olmadığım için o kısmı da net bir şekilde öğrenmek istiyorum. Bir de David Malan'ın CS50 kursunu çok duymuştum ama hiç başlamamıştım. Ona da zaman ayırmak istiyorum. Bunların ötesinde, kendi işimde elimden gelenin en iyisini yapmak için kendi konularımı (web, hatta mobil özelinde) pekiştirmem, öğrenmem, taze tutmam gerekiyor. Yapacak çok fazla şey var. Bu yüzden mutluyum.",
        "8": "153. Gün",
        "9": "Bugün ustalara saygı kuşağı gibiydi gözümde. Önce Martin Fowler’a saygım daha da arttı çünkü yazılım mimarisi konusunda hangi konuya baktıysam hep temellerinde onun yazıları karşıma çıktı. Bugün kendimce yeni bir şey bulmuşum sanmış olsam da (NFC ile telefonumdan kredi kartıma erişim) çoktan bunun üzerine çalışıldığını öğrendim. Sizin de yıllar yıllar önce bunu yapmış olmanız epey etkiledi.",
        "10": "Bugün çalıştığım konu ise ORM idi. İki mimari ORM’de kullanılıyordu. Active record ve data mapper mimarileri. Unutmadan söylemek gerekir ki ORM aslında iki kısımdan oluşuyordu. SQL sorgularının soyutlandığı “data abstraction layer” ve active record ya da data mapper’dan oluşan “data access layer”.  İkisinin de avantajları dezavantajları olmakla beraber hangisinin kullanılacağı duruma göre değişmekte olduğunu öğrendim. Bir konuya benzettim aslında. Satrançta en zayıf taş hangisidir? İki seçenek var aslında: ",
        "11": "Her zaman kaçmak zorunda olan Şah,",
        "12": "Zayıf olanın herhangi bir taş değil, taşın konumu olduğu düşüncesi cevap olarak verilebilir sanırım.",
        "13": "Bizim konumuzda da hangi mimari iyidir, en iyi ORM kütüphanesi hangisidir, en iyi orm tekniği hangisidir gibi sorular örnekteki ikinci seçeneğe oldukça benzemektedir. It depends.",
        "14": "Eve gelince de biraz google hizmetlerini karıştırırken google finance ile karşılaştım. Tıpkı diğer finans uygulamaları gibi hatta çok daha yetersizdi. Yine bu düşündüğüm şeyi belki binlerce-yüz binlerce kişi düşünmüştür ama aklıma şu geldi: Para birimleri, borsadaki değerli kağıtlar üzerine oldukça fazla grafik var. Bu grafiklerin tahmin edilebilirliği oldukça düşük aslında. Eğer yüksek olsaydı herkes zengin olurdu (ki herkesin zengin olması imkansız). Eğer bir varlığın değerindeki volatiliteyi öngörebilecek bir program olsaydı diye düşündüm. Buna göre borsada oynayabilecek akıllı bir bot olsaydı mesela. Ama bu botun akıllı olabilmesi için borsada kazanan bir insanın düşünce yapısına (sıkça kullandığı sezgisel algoritmalara) sahip olması gerekirdi. Haberleri takip edip analiz etmek ya da grafiklerin eğer bir anlamı varsa onları okuyup tahminde bulunmak üzerine bir kabiliyeti olmalıydı sanırım. Hatta zeki olan botumuz manipülasyon yapabilir miydi? Sonuçta tüm ekonomik sistem, hatta insan ilişkileri güvenmek ve inanmak üzerineydi. Bir insanın yapabildiğini zeki bir bot yapabilir gibi geldi. Üzerine tekrar düşüneceğimi düşünüyorum.",
        "15": "154. Gün",
        "16": "Bugün node.js’de bir ORM aracını (TypeORM) kullanarak veritabanı ile bağlantı kurup sorgular yaptım. Alıştıktan sonra ORM kullanmak aslında işleri çok daha kolaylaştırıyor gibi geldi kişisel olarak. Ben eğer daha bireysel ya da küçük çaplı bir uygulama yapıyor olsam ORM kullanmalıyım diye önyargı ile hemen bir ORM kütüphanesi aramazdım. Ya ORM kütüphanesi ya da işime yarayacak bir query builder kullanarak işlemlerimi yapardım. Ama geniş çaplı bir uygulama için gerekli olduğunu düşünüyorum. Böyle düşünmemdeki sebeplerden biri, ORM’nin de tıpkı MVC’nin varolma sebebi gibi separation of concerns’e dayalı olması. Şu an bulunan projede ihtiyaçlarımı SQL sorgularını yazarak karşılayabilirim fakat gelecekte onlarca yazılımcı proje üzerinde çalışırken ORM’nin getirdiği soyutlama ve tek işe sahip ol prensibi onlara ve proje yöneticisine (kim ilgiliyse) kolaylık sağlayacaktır. ORM’de anladığım kadarı ile tek sorun proje geliştikçe performans sorunlarına yol açabilmesi. Çoğu popular ORM bunun için kendi çözüm yollarını geliştirdiklerini belirtmişler. Ama bu konuya çok vakıf değilim henüz. ",
        "17": "155. Gün",
        "18": "Bugün yine TypeORM’yi biraz inceleyip sonrasında Sequlize’ın syntax’ına ve nasıl kullanıldığına baktım. Birbirlerine oldukça çok benzediklerini gördüm. Elbette farklılıkları boldu. En basitinden Birinde esas karakter Typescript iken diğerinde Javascript. Ya da birinde Active Record ve Data Mapper Pattern opsiyonları bulunurken diğerinde sadece Active record bulunmakta. Nesneler (veri modelleri-veritabanı tabloları) arası ilişkileri içeren kullanım durumları birbirlerine oldukça benzemekteydi. ",
        "19": "Sonrasında group by, having, subquery, join gibi sql’deki anahtar kelimelerin kullanıldığı sorguların nasıl yazıldığına TypeORM’de bakıp kendi durumuma uyarlamaya çalıştım. Başlangıç durumunda olduğum için biraz uzun sürdü. Biraz pratik yapsam oldukça oturur diye düşünüyorum çünkü mantığını anlamak da bir problem görünmüyor. ",
        "20": "Bugünlük bu kadardı.",
        "21": "156. Gün",
        "22": "Günün en önemli kazanımları SQL’de bilmediğim, ya da bakmış olsam da anlamadığım konuları kavramaktı.",
        "23": "İlk başta TypeORM ile devam edecektim. Dün oluşturduğum proje gayet normal şekilde çalışsa da, typescript’in kendisi, kavramların gittikçe karmaşıklaşıp dokümantasyona çok bağımlı kalmam (aslında bu sorun değildi, sorun dokümantasyonda aradığımı bulmamın kolay olmamasıydı), ORM’nin kendisinin çok fazla seçenek vermesi fakat bir süre sonra bu seçeneklerin kullanımının biraz daha ortaya karışık ilerleme ihtimali (benim acemiliğimden büyük ihtimalle) ile beraber TypeORM’den vazgeçtim. Çünkü ORM işimi kolaylaştırmaktan öte yeni bird il öğrenir gibi vaktimi oldukça çok almasıydı.",
        "24": "Sequalize’ı hemen kullanmaya başladım. Çok daha basit bir kullanımı vardı ve karmaşık bir söz dizimi yoktu (en azından kullandığım ve gördüğüm kadarı ile). Özellikle Javascript olması, yardımcı mesajların oldukça detaylı olması ve işlemleri hızlandırmaya olanak tanıması, sağladığı fonksiyonların ve seçeneklerin kullanışlılığı çok faydalıydı. Bugün de o ORM’yi kullandım.",
        "25": "157. Gün",
        "26": "Verilen görevi yerine getirebileceğimi düşünüyorum. Web-socket kavramına ilk kez detaylı bakınca başta anlamakta zorlandım. Açıkçası üstünkörü bakıp copy paste alırsam elbette bir şeyler yapılabilir fakat iyice sindirerek kavramaya çalışıyorum. Sanırım o yüzden biraz yavaş oluyorum. Ama bence iyi gidiyorum yine de.",
        "27": "Sadece stateless bir protokole (HTTP) bu kadar alışmışken ve tüm işlemler o mantıkla ilerlediği için socket konseptini oturtmak biraz zaman aldı. Hala tam oturmadı fakat gün sonuna doğru nasıl işlediğini biraz kavradım en azından.",
        "28": "158. Gün",
        "29": "Haftanın en sakin geçen günüydü mental anlamda. Bu, en boş geçen gün anlamında değildi. Bilakis düne göre daha çok şey öğrendiğimi hissettim kendi emeğim ve sizin kaldıraç etkiniz ile elbette.  Bilgi dolu bir rapor olmadığının  farkında olarak bunun rahatsızlığını hissetmekteyim. Fakat yine de bu içeriksiz raporu göndereceğim. Alınan notları not ederek raporu süsleyebilirim. Bu kötü bir şey değil eğer o süsler bana bir şey katmışsa. Yine de bugünlük böyle bir rapor oldu. Tekrarlanacağını düşünmüyorum. Saygı ve sevgilerimle.",
        "30": "159. Gün",
        "31": "Yarın yanlış yapmaktan korkmadan ve çekinmeden fikirleri uygulamaya koymaya çalışacağım. Bugün birçok örnek, uygulama, kavram ile karşılaşınca “en doğrusu, en iyisi”ni öğrenip uygulamak gibi bir fikre ister istemez sahiptim. Elbette bir örnek uygulamayı bilgisayarda çalıştırabileceğimi düşünüyorum fakat aradığım şey sanırım mükemmel olan şey. Yapmaya çalıştığım şey de mükemmel olan. Kendi seviyemden çok daha fazla şey bekliyorum. Bu beklentiden dolayı da yapmam gerekeni, problemin çözümünde en temel mantıktan başlayıp fikri geliştirerek büyütmeyi biraz erteliyorum. Başka insanların büyümüş fikirlerine bakıp kendi fikirlerimi de öyle büyütmek ya da ilham almak istiyorum galiba. Ya da korkuyorum yanlış yapmaktan ve doğrusunu da yapmıyorum bu yüzden. Oysa yanlış yapmaktan korkmam baştan yanlış bir düşünce. Bu düşüncelere girmeden devam etmeliyim. Finans örneğinizdeki sınırlı kaynak ile sınırsız ihtiyacı karşılama sanatı aklıma geldi şimdi. Gerçekten güzel bir tanımdı.",
        "32": "160. Gün",
        "33": "Bugün zorlandığım kısım node.js’e ve kullandığım kütüphanelere, hatta kullandığım teknolojiye hâlâ hakim olmamamdı. Evet basitçe bir sunucuya istek gönderen kişiyi farklı bir server’a yönlendirebiliyorum. Gerekli birkaç parametreyi de gönderebiliyorum o yönlendirmeyi yaparken. Fakat bu  parametreleri  yetkilendirme-doğrulama sunucusuna göndermek ve kullanıcıyı o sunucu ile iletişime geçmesi için yönlendirirken bu parametreleri henüz gizleyemiyorum. Ve bugün de asıl takıldığım nokta bu oldu. Elbette çok kolay bir şekilde aşılıyordur belki fakat ben henüz bu sorunuma çözüm bulamadım. Belki şimdilik bir sorun da değildir.",
        "34": "Yarın bu gibi konulara çok takılmadan en ilkel şekilde çalışan bir single sign on yapıyı kurmaya çalışacağım. Elbette geliştirmeler yapmak çokça gerekecek fakat onları sonrasında yapabileceğimi düşünüyorum. Yarın kendimde gördüğüm en büyük sorumluluk o primitif sso yapıyı kurabilmek.",
        "35": "İşteki konulardan bağımsız olarak bugün Person of Interest’in finalindeki bir cümleyi buraya yazmak istedim: ",
        "36": "“Everyone dies alone. But if you mean something to someone—if you help someone, or love someone, if even a single person remembers you—then maybe you never really die at all.”",
        "37": "Dün konuştuklarımız ve bugün de dizinin finalinde “iyi” olmaya dair söylenenleri dinleyince içimi huzur kapladı. İşe başlamadan önce, hatta birkaç yıldır oldukça nihilist ve rasyonel bir düşüncelere genel olarak sahip olduğumu düşünüyordum. Hala daha öyle tabii ki. Ama bir zararı vardı ki, amaçsız kalmıştım. 18 yaş ve öncesi hayal kurma yeteneğimi kaybetmiş gibiydim. Bu 6.5 aylık süreçte evet yazılım hakkında birçok şey öğrendim ne kadar öğrenilebilirse. Ama en çok öğrendiğim şey tekrar hayal kurabilmek oldu. Eylemsizlik ve apolitiklik ile o hayallerin arkasından gidilemez tabii ki. Gerçi sürükleyici herhangi bir hayalde henüz yok fakat kurabildsiğimi tekrar doyurucu şekilde hissetmek çok güzel. Bunun için de çok teşekkür ederim. Şu an teşekkür etmekten öte bir katkım olmuyor maalesef. Hatta hala daha kendimi parazit gibi hissediyorum fakat umarım bu durum istenilen hale gelecek. Hala daha makine ile konuşurken onu dinlemiyorum. Ve bildiklerimi, gördüklerimi ona uygulamaya çalışıp istediğim sonuçları bana vermesini istiyorum. Bu çok yanlış ama düzeltmek için de çabalıyorum."
    },
    "part17": {
        "1": "161. Gün",
        "2": "Single sign on konusunda izlemem gereken adımları daha çok öğrendim. Detaylı şekilde her kısmını düşünmüş olmasam da basitçe bir otorizasyon ve doğrulamanın nasıl yapılması gerektiği üzerine bir şemayı takip edip kodlamaya çalışıyorum. Bugün yaşadığım problem günün sonunda da çözemedim açıkçası. Bir sunucu diğer sunucuya post metodu ile istek gönderip cevabı da almak istediğinde (axios kullanarak), cevabını normal ve sıradan değişkenleri alırken problem çıkmadan alabiliyor fakat session bilgisini alamıyor. Oysa ki session bilgisi o sunucudaki kalan diğer her yerden ulaşılabiliyor. Hatta get metodu ile o sunucudan veri alırken de session verisine basitçe erişiliyor. Yarın sabah tekrar odaklanarak problemin ana kaynağını bulup çözmeye çalışacağım ya da alternatif olarak get metodu ile çözümleyeceğim. Ek olarak, geçişleri express’in sağladığı redirect metodundan client side’da normal şekilde farklı bir url’ye aktarımı sağladım. Her kullandığım yerde. Ona rağmen devam etmekte.",
        "3": "162. Gün",
        "4": "Dün karşılaştığım problemi sizin ifadenizle hackish bi şekilde gidermiştim. Fakat sonrasında yine aynı problemle karşılaşınca sorunun tam olarak neden kaynaklandığını anlamaya çalıştım. Aynı domain adresinden gelen post isteği üzerinde işlem yaparken session’a veri ekleyebiliyordum. Aynı domain adresinden gelen get isteğinde de problem yoktu. Fakat farklı bir domain’den gelen get ya da post isteği ile işlemler yapabilsem de session’a veri kaydedemiyordum. Eğer işlemler yapmama izin veriyorsa CORS’a izin veriyor diye düşündüm. Ama eğer session’a veri ekleyemiyorsam CSRF’e karşı önlem olduğu için istediğim sonucu elde edemediğimi düşündüm. Bu yüzden yarın sabah ona bakacağım.",
        "5": "Neredeyim? ",
        "6": "If(kullanıcı is not authenticated) Domain A-> Domain B;  //Henüz bu kısımdaki işlemler kodlanmadı",
        "7": "//Domain B, Domain A’dan gelen parametreleri de kullanarak önce kullanıcıdan giriş bilgilerini alıp teyit eder. Eğer doğru ise Domain A’ya otorizasyon kodu gönderir. Domain A ise karşılığında cliend id, client secret bilgileri ile auth code’u geri gönderir. Burada Domain B gerekli token’ları oluşturur. Neden direkt gerekli token’ları (id token, access token, refresh token gibi) göndermedi? Çünkü kullancının iznine bağlı olarak authorization yapılacak bir kısım varsa, kullancının sitenin istediği scope’ları bilmesi sağlanır. Bunun şu anki sistemde olması gerekmiyor ama gördüğüm örneklerde var diye bu şekilde ekledim (silinebilir ya da geliştirilebilir). Sonrasında, Domain A id token’ı kullanıcı bilgilerini görmek için kullanır(id token eğer Domain A authorization için scope’ta bunu belirttiyse gönderilir (openid’de kullanılan şekli ile)). Access token sadece authorization bulunan alanlara erişebilmek için kullanılır (Örneğin farklı kaynak sunuculardan veri almak istediğimizde yetkilerimizn ne olduğunu o kaynaklara erişmek istediğimizde görebiliriz. Orjinalde access token’ı Domain A okuyup anlamamalı. Bunu sağlamak için hs256 gibi simetrik bir algoritma kullanmak yerine rs256 gibi asimetrik bir algoritma tercih edilebilir. Edilmeyedebilir aslında, tercih meselesi anladığım kadarı ile.). Bugün son olarak token’ları oluşturdum JWT token olarak ve client secret ile hem Domain A hem de Domain B’de okunabilmekte. Sorun Domain B’den Domain A’ya token’ları post ile gönderdiğimde session’ına yazamamam. Tahmin ettiğim üzere CSRF ile ilgili bir sorun olduğu için Bu akşam bu konu üzerine biraz okuma yaptım.",
        "8": "Buradaki middleware",
        "9": "ile sorunu çözebilecek miyim bilmiyorum fakat yarın ilk bu duruma bakacağım.",
        "10": "Bu yazıdaki",
        "11": "tavsiyelere ve dikkat edilmesi gereken uyarılara da dikkat etmeye çalışacağım. En azından aklımda yer edinmesi gerekliymiş gibi geldi.",
        "12": "Sonrasında yapmam gerekenler: Şu durumdaki sorun benim hep session’I tercih etmiş olmayı istemem. Aslında cookie’de tutmam gerekliydi bazı bilgileri (kullanıcının giriş yapmış olup olmadığı ile ilgili bilgi gibi) çünkü kullanıcı tarayıcı kapatınca tamamen session’ın silinmesi söz konusu. Anladığım kadarı ile bir parametreyi değiştirerek bunu engellemek de mümkünmüş fakat şu an net hatırlayamadım. Gerekirse çereze de ilgili verileri kaydederim ya da session ayarlarını değiştirebilirim.",
        "13": "Genel olarak sonrasında yapmam gerekenler: Kullanıcı farklı bir domain adresine girince (benim ilgilendiğim,sahip olduğum domain üzerinde), öncelikle çerez’e ya da session’a bakılır. Eğer gerekli kullanıcı bilgisi yoksa Domain B’ye yani auth server’a sorar kullanıcı giriş yapmış mı diye. Eğer yapmadıysa o şekilde işlemlerine kaldığı yerden devam eder. Kullanıcıyı rahatsız etmez. (Kullanıcı farklı bir domainim’de giriş yapmışsa auth server’da kullanıcı bilgisi session’ında ya da çerezinde yer alacaktı. Dolayısıyla şu anki sitede de giriş sağlanacaktı ve gerekli bilgiler bu domain adresine verilecekti).",
        "14": "Kısacası yapmam gereken kısımlar hâlâ var SSO konusunda. Ama sorunlara, yapmam gerekenlere daha iyi hakimim diyebilirim. Sadece takıldığım konularda kullandığım araçları daha verimli şekilde kullanmalıyım diye düşünüyorum.",
        "15": "163. Gün",
        "16": "Bugün üzerine çalıştığım kurguyu tamamlayamadım. Ya benim kurgumda bir problem var ya da teknik problemlerini aşamıyorum her gördüğüm kaynaktaki olası çözümleri denesem de. Bence kurgumda bir hata olduğu için istediğim sonucu elde edemiyorum. Tekrar deneyeceğim. Açıkçası istediklerimi yapamayınca üzülsem de ağlasam da denemeye, öğrenmeye, ders çıkarmaya devam edeceğim.",
        "17": "164. Gün",
        "18": "Bu hafta istediğim yere gelemedim. Ama bu görevimde başarısız olacağım anlamına gelmiyor. Bilakis yapacağım. Yarın da o yüzden çalışacağım diye düşünüyorum çünkü yapmak istiyorum. Sizin bana gösterdiğiniz kodları kendim de yazdım. Sorunsuz şekilde çalışıyor o kısım. Yarın kendi kurgumu onun üstüne güzel bir şekilde yazıp, yapbozun bir parçasını ekler gibi eklemek istiyorum. 95$ ödenir fakat gerçekten hakkınızı nasıl öderim şu an hiç bilmiyorum. Şirkette işe başlamadan önce bir arkadaşımla konuşuyordum. Kendisi de PHP, wordpress, vs. ile ilgilenen, hatta OOP, MVC, vs. denince aşırı zor şeylermiş (Yunan tanrıları tarafından alınan kararlar sonucu oluşan mistik ve ilahi şeylermiş) gibi anlatırdı fakat kendisi de neredeyse hiç bilmiyordu. Bugün onunla konuşunca o zamanlar benden biraz daha konu ile ilgili bir insan ile şu anki hâlim arasındaki farkı öyle iyi anlıyorum ki. Her zaman kendimi yeriyorum, hiçbir şey bilmediğimi düşünüyorum ne kadar çok şey ile uğraşsam da. Fakat konu ile alakalı olmayan ya da olan biri ile konuşunca aradaki farkı çok iyi hissediyorum. Sadece sizinle konuşurken zorlanıyorum. İyi ki de zorlanıyorum. Dün akşam Linkedln’de bir gönderi görmüştüm. GPA’in, tecrüben, vs. (elbette gerekliler bazı kriterler için) unutulur fakat insanlarla bağın, ilişkin, yaklaşımın kalır ve hatırlanır tarzı bir yazıydı. Sanırım sadece iş hayatında değil hayatın kendisinde de daha iyi dikkat etmeye çalışacağım buna. İnsana değer vermeyi, dinlemeyi, anlamayı, sevmeyi, merhameti ve tevazuyu daha da ilerletmek istiyorum. Böyle “boş”ta yapabiliyorum çünkü sizinle olan bağımdan dolayı kendimi bir derece rahat hissediyorum.",
        "19": "165. Gün",
        "20": "İlerliyorum.  Kullanıcı SSO sunucu kullanılarak gayet normal bir şekilde giriş yapabiliyordu. SSO’dan sadece gerekli kullanıcı bilgileri, ilgili client sunucu(lara) veriliyor. SSO sunucusu ile iletişimlerde sadece bir kez idToken oluşturulup clientSecret paylaşılıyor. Onun dışında güvenlik tehdidi olabilecek bir kullanıcı bilgisi direkt olarak sunucular arasında paylaşılmıyor. Güvenlik sorunları sonrasında düzeltilebilir. Daha büyük bir problemim var. Asıl SSO’nun çalışma mekanizmasında bir problem bu fakat çözeceğim. Farklı bir siteden giriş yapınca, o site SSO’ya yönlendirilip SSO’da o kullanıcı daha giriş yapmış mı diye kontrol edilir. Ben burda hep SSO’nun çerezinde idtoken’I tutarak ilk kontrolü buradan yaparım diye düşündüm. Çünkü eğer SSO’nun çerezinde idToken veya herhangi benzeri bir tanımlayıcı veri yoksa, kullanıcının giriş yapmış olduğunu nasıl anlayabilirdim? SSO’nun kullandığı veritabanında bu oturum açıp açmama bilgisini tutarak olabilirdi. Ben hem SSO çerezinde hem de veritabanında tutmayı makul gördüm. Kullanıcının tarayıcısında giriş yapıp yapmadığı bilgisini tutmak daha sağlıklı olur diye düşündüm. Fakat bunu manipüle edebilecek kötü niyetlere karşı da veritabanında bu bilgiyi tutarak karşılaştırma yapabilirdim. Belki karmaşık ve yanlış düşünüyor olabilirim. Sadece Ip adresine bakılarak da yapılabilir. Ya da sadece çerez veya veritabanındaki bilgiye bakılarak da yapılabilir. En büyük sorun şu an farklı client sunuculardan oturumu control etmek ve ona göre o sunucuların da client tarafında çerezlerini kaydetmek. Bugünün en tatlı yanı client secret hep değişen şekilde kaydetmem oldu. Her yeni oturum açlımında client secret değişmekte ve güvenliğe de faydalı  olmakta (Id token’I açmanın tek yolu kendisini bilmek. Tüm sitelerde de tek bir idtoken ve tek bir client secret olduğu için bence çok ufak ve güzel bir ayrıntı.)",
        "21": "Bugün başlangıçta sistemli olarak düşüncelerimi koda yansıtsam da sonra ipin ucu kaçıp domuz düğümüne dönmüş gibi oldu.",
        "22": "Yarın ne yapacağım?",
        "23": "SSO’nun çerezinde idToken’I tutmak ne kadar doğru onu düşünüyorum. Hiç çerezinde idtoken eklenmeyen bir site giriş yapılıp yapılmadığını anlamak için SSO’ya gider. SSO ise kendi çerezinde idToken olup olmadığına bakar ve database yada sürekli verinin tutulduğu herhangi bir yerden idToken’I control edip sonrasında idToken’I ve client secret’I o sunucuya tedarik eder. En önemli husus, bu durumun taklit edilmesine yönelik iyi bir koruma sağlamaktır (İzin verilen domain’lerden gelip gelmediği kontrol edilir). Başka problemli bir yönü yoktur.",
        "24": "Kısacası yarın asıl SSO kısmını tamamlamayı planıyorum kaba olarak. Başarabilirsem ince işçiliğine gireceğim.",
        "25": "166. Gün",
        "26": "Bir siteden çıkış yapan kullanıcı tekrar giriş yapmak istediğinde tıpkı Google’da olduğu gibi  “selam GayeSu, bu sen misin?” dedikten sonra eğer o kişi olduğunu teyit ederse onun şifresini almak ve doğrulayıp tekrar giriş yapmasını sağlamak istiyorum. Ayrıca o eski giriş yapan kişi değilse de normal kullanıcı ismi ve şifrenin olduğu standart formu vermek istiyorum. Onu yapmaya çalışırken yarım kaldı çalışmam. Tüm sitelerden çıkma özelliğini son olarak eklemeyi düşünüyorum. Böyle bir durumda, o sso’yu kullanan sunuculara bir middleware eklemem gerekecek, hepsinden çıkış yapmış mı kontrolünü sağlamak ve görebilmek için.",
        "27": "Yarın kaldığım yerden devam edeceğim. Daha sistemli gidiyorum. Kod uzamaktan çok evriliyor ve değişiyor şu birkaç günde. Yarın olmasa da sonraki gün SSO genel manada ortaya çıkar diye düşünüyorum. İlk defa Node.js ile bu kadar çok çalıştım, iyi ki çalıştım.",
        "28": "Bugün farklı bir bilgi öğrendim konu ile alakasız olarak. \"res.sendfile()\" diyerek bir dosyayı tarayıcıya sağlarken stream bir veri gönderimi sağlanıyormuş. Bu ne demek? Normalde ben o dosyayı önce \"fs.readfile()\" diyerek sunucu hafızasını tüketiyorum fakat diğer şekilde dosyayı küçük veri paketleri halinde tarayıcıya sağlıyormuşum. Bu da performans açısından çok daha sağlıklı oluyormuş. Veriyi hafızaya kaydet. Tarayıcıya gönder. Garbage collector temizlik işlemini yapsın gibi işlemlerden kurtarıyor bir nevi.",
        "29": "167. Gün",
        "30": "SSO ile ilgili görevin ilk kısmında aklıma gelen olasılıkların hepsini denedim. Sadece güvenlik açıkları kesinlikle var. Farklı büyük bir hata varsa ve ben farketmemişsem eğer mantıksal işleyiş açısından, düzeltebileceğimi düşünüyorum çok zorlanmadan. SSO’da tüm kullanıcı girişi işlemleri SSO sunucusuna dayalı. Bu sunucunun hizmet verdiği client web siteleri için en önemli konu, çerezlerinde tuttukları idToken. Tüm kullanıcı bilgisi şifrelenmiş şekilde idToken içerisinde yer almakta. idToken’I okumanın tek yolu client sunucuların ortak olarak kullandığı veritabanında tutulan client secret isimli veri. Bu veri sabit değil. Her oturum açılışında o kullanıcıya özel olarak 2 ya da 3 tane kriptografik şifreleme işlemi (Önce client id ve auth code bu şekilde oluşturulduktan sonra, o veriler client secret’in oluşturulmasında kullanılıyor. Tahmin etmek çok zordur diye tahmin ediyorum) sonrasında oluşturuluyor. Kullanıcı eğer tek bir client web sitesinden çıkış yaparsa sadece o sitedeki oturumu kapatılıyor. Diğer sitelerde oturum aynı şekilde kalıyor. Eğer kullanıcı hepsinde oturumu kapatmak isterse tüm hepsinde oturum SSO aracılığı ile kapatılıyor (Client sunucular bu durum için küçük bir middleware ile SSO'ya tüm oturumlar kapatılmış mı diye sorguda bulunuyor.). Eğer sadece bir websitesinde oturum açılmışsa, diğer websiteleri de  bu oturuma erişebiliyor. Yani SSO anlamına kavuşuyor. İkinci bir client olmadığı için tam olarak test edemedim fakat şu an istediğim gibi çalışıyor.",
        "31": "SSO sunucusu veritabanında kullanıcı bilgileri ile idToken’I tutmakta iken, client sunucu veritabanında SSO’nun sunduğu veriye dayanarak kendi kullanıcı  tablosunu oluşturuyor. Authentication ile ilgili sadece clientSecret’I her kullanıcı için ayrı olarak tutmakta. Kullanıcı bilgileri hiçbir zaman direkt olarak transfer edilmiyor ve tüm iletişim idtoken üzerinden işliyor olması gerektiği gibi. Client secret’I client sunucu oluşturup sadece ilk oturum açma işleminde SSO’ya aktarıp idToken’ın oluşturulmasını sağlıyor.",
        "32": "Node.js, express, ve genel olarak node.js ortamında çalışmaya bu verdiğiniz proje ile adapte olabildim. Yarın dediğiniz üzere socket konusuna bakacağım. Önce yapmam gerekenleri kendimce listeleyip, nasıl yapabileceğim üzerine ufak çapta eskizler hayal edip hedeflerimi gerçekleştirmeye çalışacağım. O kadar OOP ve tasarım deseni dedikten sonra şu aşamada hiçbirini kullanmamam üzse de, o aşamaya da geleceğimi düşünüyorum. Bir anda (Tanrı 6 günde yaratmış, bilime göre 14 milyar yıl?) insan nesnesini yekpare yaratmaktan ziyade, ona evrilerek ilerleyen bir yapı kurmak sanırım yaptığım ve yapmaya çalıştığım şey. Dolayısıyla arzu edilen desenler de açığa çıkacaktır. OOP ve SOLID’e uygun bir yapı ortaya çıkar diye düşünüyorum ileriki aşamalarda.",
        "33": "168. Gün",
        "34": "Bugün idToken mantığını çerezden session’a taşıdım. Taşırken kodun birçok kısmında değişiklikler yapıp ekstra iyileştirmeler de yaptım. Tüm gün bunlarla geçti açıkçası. Şu an yine istediğim gibi çalışmakta. Bugün yaptığım değişikliğin sebebi, bazı verileri nerede tutmamam gerektiği üzerineydi. Çerezde birtakım hassas veri tutmanın yanlış olduğunu “yaparak” öğrendim ve düzelttim. Bir daha böyle bir hata yapmam diye düşünüyorum.",
        "35": "Yarın artık farklı bir socket.io ile yapacaklarım üzerine yoğunlaşacağımı düşünüyorum.",
        "36": "169. Gün",
        "37": "Socket.io ile ilk karşılaştığım zamanda olduğu gibi örnek kodu kopyalayıp üzerinden gitmeyi düşündüm günün ilk kısmında. Sonrasında kendi sistemimi tasarlayıp ona göre socket’i kullanarak yazmalıyım dedim. SSO yu kullanarak giriş yapan kullanıcıya tıpkı skype/ve diğer benzeri uygulamalardaki gibi bir front end sunulacak. Yarın kabataslak html ve css ile temel bir görünüm vereceğim. Skype’ın bir benzerini html ve css kullanarak en basit düzeyde yazıp sonrasında socket kullanarak veri alışverişini sağlamaya çalışacağım client ve server arasında. Açıkçası bunu sorunsuz şekilde yapabilirsem geriye sadece bu yazılan kodu electron kullanarak implement etmek kalıyor. Bir de text dosyası yerine veritabanı kullanmak kalıyor. Sonraında orm ya da odm de kullanılabilir gerçi. Routing’in çoğunluğunu login kısmı oluşturdu. Uygulama aslında neredeyse single page application gibi olacak düşününce (tam olarak değil tabii ki, authentication’da farklı route’lar da kullandım).",
        "38": "Çok zor bir şey yok gerçekten fakat hala çok yavaşım. Hızlanmaya çalışıyorum. Örneğin bugünün çoğunluğu dosya yapılarını düzeltmekle geçti. Aslında pek bir şey de yapmadım şimdi düşününce fakat yine de zamanımı aldı. Authentication kısmını farklı bir klasöre aldım. Sonrasında socket ile ilgili işlemleri nerede yapacağıma dair ana javascript dosyasında da düzenlemeler yaptım. Bu ayırma sırasında middleware kullanırken biraz sorunlar yaşayıp istediğim hale getirdim. Zamanımı alan bu ufak sorunlardı fakat size de sormak istemedim, kendim çözmek, bulmak, öğrenmek istedim. Zor da olsa ayakta durabilen bir bebeğin ebeveyninin yardımını istemeden kendince yürümeye çalışması ve defalarca kez düşse de normal şekilde yürümeye başlaması gibi sanki. Koşmak dileği ile tabii ki.",
        "39": "Büyük konuşmamalıyım fakat haftaya soket kısmı çok rahat biter diye düşünüyorum. Sonraki hafta da electron’u kullanmayı ve orada bu kod yapısını (Html ve Css ile client’ta yaptıklarımı electron’a) uygularım diye düşünüyorum. Bence güzel ve güneşli günler yakın.",
        "40": "170. Gün",
        "41": "Bugün sadece html/css/javascript ile çalıştım. Çalıştığım kısım henüz bitmedi fakat yarısı tamamlandı. İlk defa css’te değişken kullandım bugün. Kullanmış olmak için kullanmadım. Karanlık/aydınlık teması yapmak istemiştim ve bunun için de css değişkenleri kullanmak oldukça verimliymiş.",
        "42": "Ek olarak, html kullanırken her zaman resmin genelini düşünerek hareket etmeye çalışıyorum. Gelecek verileri ve ilişkilerini bu yazdığım html kodları ile nasıl yansıtabilirim diye düşünerek yazmaya çalışıyorum. En son html/css kullandığım zaman ile şimdi arasındaki farkı hissediyorum."
    },
    "part18": {
        "1": "171. Gün",
        "2": "Bugün front end konusunda en çok kullanmam gereken işlevleri (basit bir mesajlaşma uygulaması üzerine) yazdım. Hala en basit seviyede ama socket.io kullanarak anlık iki yönlü iletişimi sağlamam için gerekli front end kısmını içeriyor. Yarın ve bu haftanın geri kalanında sunucu ve client arasındaki iletişimi kurmaya çalışacağım. Amacım cumartesi  websocket ile ilgili kısmı tamamlayabilmek. Bu akşam çalışıp eksik kalan kısımları tamamlamayı düşünüyordum fakat fırsat olmadı (Aile ve arkadaşlara vakit ayrılan vakit neticesinde). Onun dışında görevi yapabileceğimi düşünüyorum. Bu hafta isterlerimi tamamlayabilirsem çok sevineceğim kendi adıma. Yarın direkt socket.io’daki basit chat uygulaması örneğini kendi yazdığım sisteme uyarlayıp en temelden geliştirmeyi deneyeceğim. Sistemli bir şekilde ilerlediğimi düşünüyorum (Kendi çapımda bir sistemli ilerleyiş tabii ki de). Temel kısımları tamamlayıp eksiklerle karşılaştıkça da sorunları çözeceğimi düşünüyorum.",
        "3": "172. Gün",
        "4": "Front end tarafında en basit bir görünümü elde edebilmek cumartesi ve pazartesi günlerini almıştı. Bugün ise client’ta yazılan mesajı socket.io kullanarak sunucuya gönderme ve sunucunun da karşı bir cevap göndermesi işlendi. Evet basit bir mesajlaşma sağlanıyordu. Fakat bu mesajların text dosyası veya veritabanı gibi kalıcılığı olan bir yerde tutulması gerekliydi. Öğleden sonra tamamen bunun üzerine yoğunlaşıp neler yapabileceğimi düşündüm. İlk olarak, bu uygulamanın tutarlı işlediğini görebilmem için 3 tane kullanıcı olması gerekli. 3 kullanıcı ikili iletişim kurabilirler ya da beraber grup oluşturabilirler. 2 kişinin bir grupta olma ihtimalini açıkçası henüz hesaba katmadım ama bir grup olduğunda doğal olarak bir grup ismi de olacağı için, kişi sayısı yerine grup isminin varlığı ile bir grubun olup olmadığı anlaşılabilir. Bir tane bot kullanıcı olursa, kullanıcılar onunla iletişime geçebilir diye düşündüm. Bu bot’a şimdilik “Assistant” adını verdim. Bot kullanıcı, anketler oluşturup kullanıcılardan bu anketleri doldurmasını isteyebilir örneğin. Ya da kullanıcılar bir problemle karşılaştıklarında direkt ona iletebilir. Hatta kullanıcılar söylemeye çekindikleri ama dile getirmek istedikleri bir konuyu Assistant’a anonim olarak iletseydi nasıl olurdu diye de düşündüm. ",
        "5": "Bugünün en çok düşündüren konusu veri yapılarının nasıl olması gerektiği idi. Şu aşamada bir veritabanı kullanmak yerine basitçe json/text dosyalarında veriler tutuluyor. Örneğin kullanıcı tablosu yerine “dbClient.json” dosyası, sohbet verileri tablosu yerine “chat.json”, session için de “session.json” dosyaları kullanılıyor. Bugün kullanıcı verileri ve sohbet verilerinin (sohbete katılan kişiler, sohbet id’si, sohbet içerikleri, sohbet tarihleri gibi) nasıl tutulabileceği üzerine düşünüldü. Bu iki farklı veri yapısının (ya da tablo/dosya) birbirleri ile bağlantısı, kullanıcıların id’si ve bulundukları sohbetlerin id’si üzerine olabilir diye düşünüldü ve bu şekilde oluşturuldu. Şu an var olan kullanıcı id’si ise oturum bilgilerinden elde edildi.",
        "6": "Ek olarak, bugün dinamik olarak mesajlar DOM metotları kullanılarak oluşturuldu. Ama mesajların oluşturulması yukarıda da belirtildiği gibi pek bir anlam ifade etmedi. Çünkü kullanıcı sayfayı yenilediğinde doğal olarak tüm mesajlar siliniyordu.",
        "7": "Yarın üzerine çalışmam gerektiğini düşündüğüm konular: ",
        "8": "Kullanıcının sohbet geçmişi varsa, geçmiş sohbetleri ile ilgili veriler socket.io aracılığı ile client’a aktarılacak. (Burada tüm mesajların aktarılması yerine son mesajın belirli karakter uzunluğundaki kısmı da aktarılabilir. Tıpkı skype’ın son sohbetler kısmında göründüğü gibi. Sonrasında kullanıcı o sohbete tıklarsa eğer tüm mesajlar yüklenebilir ya da yakın tarihteki mesajlar yüklenir ve kullanıcı çok daha eski mesajları görmek isterse, sonrasında veritabanından o mesajlarda çekilebilir. Şimdilik en optimize çözümü düşünmek yerine tüm mesajların veritabanından alındığı durumu yapacağımı düşünüyorum.)",
        "9": "Kullanıcının sohbet geçmişi yoksa, Assistant ile bir sohbet başlatılacak. Önce veritabanına eklenip sonrasında client’a gösterilecek.",
        "10": "Kullanıcının sohbet geçmişi varsa ve bu sohbetlerden herhangi birinde birden fazla katılımcı varsa eğer, bu sohbet grup olarak görülecek ve veriler client’a bu şekilde aktarılacak.",
        "11": "Tüm bunlar gerçekleştirildiğinde ise, büyük ihtimalle front end tarafındaki eksiklikler göze çok çarpacak ve onlar basitçe düzeltilmeye çalışılacak.",
        "12": "Önemli olan diğer bir konu ise henüz çok bilmediğim cache yapısı. Kullanıcının geçmiş mesajları kesinlikle bir veritabanından (ya da herhangi bir persistent storage-şimdi kullanılan text/json dosyası gibi) alınacak. Ama kullanıcının anlık olarak mesajlaşması durumunda bu veriler elbette veritabanına yazılacak fakat client tarafındaki veriler veritabanından alınarak değil, sadece sunucu tarafından işlenerek alınacak. Yeni bir mesaj yazıldığında, sunucu iki işlem yapar diye tahmin ediyorum. Birincisi bu yeni mesajı veritabanına asenkron olarak ekler. İkinci olarak da bu veriyi client’a teslim eder.",
        "13": "Açıkçası yapılacak çok fazla şey var. Problemleri en temel biçimde ele alıp ilerlemeye çalışıyorum. Her problem ve çözüm, yeni bir bakış açısı ve farklı alternatifleri sunuyor. Kullanıcı ya da bir grubun fotoğrafı olması ya da olmaması durumu, grup yöneticisi ve yetkileri, gruptan çıkmak ya da kullanıcıyı kaldırmak gibi çokça fazla konu ilgi bekliyor. Şu an bulunduğum konuma göre bu konular sonraki aşamalarda karşıma çıkacak daha detaylı kısımlar tabii ki. Bu yüzden, daha çok backend tarafını ilgilendiren problemleri  yarın ele alacağım. Tamamlamaya çalışacağım. ",
        "14": "173. Gün",
        "15": "Açıkçası istediğim şekilde ilerlediğimi hissediyorum. Tabii kendi isteklerim ne kadar önemli bilmesem de kendim yaptığım işten biraz da olsa tatmin oluyorum en azından. Bugün statik olarak var olan front end kısmına dinamik olarak verileri text dosyasından alarak eklemeye başladım. Elimden geldikçe değiştirilebilir, uyumlu, Bruce Lee’nin “Su gibi ol dostum, bulunduğun kabın şeklini al vs.” cümlesini özümseyerek, gelecek bir zamanda koda bakan bir kişinin düzeltebileceği bir kod yazmaya çalışıyorum. Hala daha OOP ile ilgili herhangi bir şey yazdığım kodda bulunmuyor aslında. Sadece orada anlatılmak istenenleri biraz da olsa kavradığımı düşündüğüm için aklımda “modüler bir kod yazmalısın Buğra” düşüncesi hakim. Henüz pek olmadı ama yapacağım diye umuyorum.",
        "16": "Biraz önce çok ufak bir şeyle karşılaştım ve onu öğrenmek bile epey keyifliydi. forEach’te döngünün istediğim yerde durmasını sağlamak için neler yapabilirim diye bakıyordum (kodun sonraki kısımlarını etkilemeden). every() fonksiyonu ile basitçe bu dediğimi yapabildiğimi öğrendim.",
        "17": "Bugün sadece text dosyasındaki, sohbet ile ilgili veriyi client’a sunma üzerine çalıştım olması gerektiği gibi. Bir html dosyasından backend ile iletişim kurmak için ajax/fetch gibi teknolojiler kullanmam gerekirdi. Fakat anlık mesajlaşmayı da socket.io ile oluşturduğum için, diğer kısımda da fetch/ajax yerine socket.io’yu tercih ettim. Ne kadar doğru henüz bilmiyorum. Henüz temel kısımları hâlâ bitmedi. Yarın veya en geç cuma gününe kadar grupların ve kişilerin olduğu, anlık mesajların da istenilen şekilde geldiği bir yapıyı kurmaya çalışacağım. Çok eksik var. Yapmam gereken daha çok şey var. İyi ki de var ve öğreniyorum. Çünkü aşırı zevkli (çarpıtılmış bir hedonizm olarak değil tabii ki bu zevk). Fakat zaman da su gibi akmaya devam ediyor.",
        "18": "5 kişinin yaptığı işi yapıyor muyum bilmiyorum ama ben hızlandığımı düşünüyorum eskiye nazaran. Ya da gösterdiklerinizi biraz da olsa pekiştirdim diye düşünüyorum (tamamen değil tabii ki de, en azından yüksek benzin fiyatları dolayısı ile benzini koklayan arabalar gibi kokusunu aldım sanırım birkaç şeyin: iyi bir kodun nasıl yazıldığını, kullanacağım teknolojileri, araçları. Mantıklı biriydim az çok fakat şimdi ufkumun daha da genişlediğini düşünüyorum. Yanlış yaptığım kısımlarda bir şeylerin yolunda gitmediğini hissediyorum birçok zaman. Bazen bilerek yanlış yapmaya da devam ediyorum çünkü iç sesimle yaptığım trade-off’ta yanlış yapıp sonra o kısmı düzeltmek ve farklı kısımları tamamlamak ağır basabiliyor). 5 kişinin yaptığı işi yapamam, çünkü beş kişi içerisinde ben de dahilim. Sıradan bi zekaya sahip ama kendini bu konuda geliştirmek isteyen basit bir insanım sadece. Benden neredeyse her konuda çok iyiler her zaman olacak. Ama ben de elimden geleni yapacağım.",
        "19": "174. Gün",
        "20": "Geçmişte yazılan mesajları, varolan sohbetleri, gerekli kullanıcı bilgilerini (fotoğraf, isim, durumu, vs.) alıp frontend kısmında yazabiliyorum. Anlık olarak yazılan mesajları da istediğim şekilde front end kısmında gösterebiliyorum. Fakat sistemi biraz yanlış kurguladığım için bazı çok ciddi problemlerim var. Nasıl çözeceğimi bildiğimi düşünüyorum. Problemim şu: Geçmiş mesajları rahatlıkla yazdırıyorum. Anlık yazılan mesajları text dosyasına asenkron olarak kaydediyorum ve bu esnada ekrana da yazdırıyorum. Fakat farklı bir sohbete girdiğimde bu anlık mesajlar kayboluyor. Sayfayı yenileyince geri geliyor tabii ki (Text dosyasından alarak gerçekleştiriyor). Kaybolma nedenini biliyorum çünkü kaybolmasını ben istemiştim ve ona göre birkaç satır kod yazmıştım. Çünkü eğer kaybolmazsa bu sefer tüm mesajlaşmalar tüm sohbetlerde karışık olarak bulunuyordu. Bir soruna karşı oluşturduğum bir çözüm, farklı bir yerde sorun yarattı. Bu yüzden mesajları chat id’sinin olduğu ana bir elemanda tutarak ve her yeni mesajı bu chat id’sinin bulunduğu kısma ekleyerek sorunu çözebilirim. Aktif olan sohbetin ilgili elemanı gösterip, diğer sohbetlerle ilgili kısmı saklarım. Her yeni mesajı veritabanına ekleyip, sonrasında oradan çekmemek için girdiğim yol bence yanlış değil ve uygulanabilir. Fakat sorunlarımı düzelteceğim. Bugün yapmak istediklerimi tamamladım fakat sonrasında oluşan sorunları henüz çözmedim.",
        "21": "Yarın yukarıda bahsettiğim çözümü uygulayıp sorunu giderirsem eğer, biraz daha spesifik kısımlara giriş yapacağım. O an sohbette bulunan kişilerden birinin mesaj yazması durumunu göstermeliyim. Mesajları düzenleme, silme gibi yetenekleri kullanıcıya sağlamalıyım. Sonrasında kullanıcının kendi statüsünü (müsait, meşgul, uzakta, offline gibi) değiştirmesini sağlamalıyım. Kullanıcı çıkış yaptığında ya da disconnected olduğunda offline’a geçmesini sağlamalıyım. Kullanıcıya yeni gelen mesajları da bildirimle göstermem gerekli.",
        "22": "Sağlam adımlarla ilerlemeye çalışıyorum. ",
        "23": "175. Gün",
        "24": "Sadece bir kullanıcı SSO da var. Hayali kullanıcılar ve sohbet geçmişleri text dosyasından alınıyor. Olması gerektiği gibi front end kısmında eski ve yeni tüm mesajlar, sohbetler gösteriliyor. Bugün iki önemli problem çözüldü. Sizinde dediğiniz üzere socket’lerin hepsine yayın yapıldığı için farklı sekmelerden (ya da tarayıcıdan) aynı url’e erişince anormal davranışlar sergiliyordu uygulama. Bunu düzelttim. Sonrasında statü değiştirme durumlarını tamamladım (Hala birkaç eksiği var fakat daha önemli eksikleri tamamladıktan sonra geri döneceğim).",
        "25": "Okunmamış mesajların varlığını bildirmek, “is typing” ile sohbet sırasında mesaj yazan kişiyi göstermek, dosya gönderme gibi 3 kısım kaldı. İlk iki kısım için farklı kullanıcılardan mesaj gönderilmesi gerekiyor. Bunun için de SSO kısmına tekrar düzenleme yapmam gerekli çünkü kullanıcıların oturum açıp yazı yazabilmesi için SSO’da kayıtlarının olması gerekli ve SSO’dan client server’a gerekli  kullanıcı verilerini transfer etmem gerekli. Yarın SSO kısmına uygulamadaki hataları gidermek için farklı kullanıcıların olma durumunu ekleyeceğim (olması gerektiği gibi. En başta yapmam gerekliydi fakat problemi değerlendirirken overengineering’e kaçmamalıyım derken fazla yüzeysel düşündüm sanırım). Bu düzenleme biraz zaman alabilir ama yapmak zorundayım. Ben karanlıkta olduğumu düşünmüyorum. Aksine ışığı görebiliyorum. Ulaşacağımı düşünüyorum. Bu hafta socket ile ilgili kısmı tamamlarım diye bekledim kendimden. Oysa ki tamamlayamadım hâlâ ama epey yol katettim. Tüm ana problemler bittikten sonra sesli ve görüntülü aramanın nasıl yapıldığını öğrenip uygulamak istiyorum mümkünse (Birçok uygulamada varsa neden mümkün olmasın tabii).",
        "26": "176. Gün",
        "27": "Bugün geçmişte yazdığım kodlarda düzeltmeler yaptım. Henüz bitmedi ve bu yüzden yarın akşam birkaç saat bakarım diye tahmin ediyorum. Birden fazla kullanıcının authentication bilgilerini SSO’da tutuyorum artık fakat client’ın session kısmında da düzenleme yapmam gerekli. Pazartesi tamamlarım diye tahmin ediyorum. Eğer tamamlarsam önemli bir problem kalmamış olacak diye düşünüyorum şu anlık.",
        "28": "177. Gün",
        "29": "SSO tarafını düzeltmiş olsam da; SSO’yu kullanan backend kısmında, session’ı da birden fazla session’I destekleyecek hâle getirmeliydim. Bugün bu  durumu tamamlamaya çalıştım. Yanlış bir yolu takip ederek doğru bir şekilde çalışma izlenimi veren bir yapı kurdum. Fakat sonrasında bu yapıyı doğru bir şekilde çalışması için düzenlerken istemediğim sonuçları üretir hâle getirdim. Ama yarın tamamlayacağımı düşünüyorum o kısmı da. Eğer yarın tamamlarsam büyük bir iş yükü tamamlanmış olacak. İnanıyorum, olmak üzere.",
        "30": "178. Gün",
        "31": "Dün karşılaştığım ve çözemediğim problemi durgun bir zihinle bu sabah çözdüm. Sorun session’da birden fazla kullanıcının verisini tutmaktı. Şimdiye dek SSO tek kullanıcılı olduğu için client sunucu daki birden fazla kullanıcılı işlemleri statik olarak kendim oluşturup simüle ediyordum. Bu sabah bu problemi çözdüm. Sonrasında statü değiştirmedeki problemli yapıyı, “is typing” li kısmı doğru bir şekilde oluşturdum. Gün sonuna doğru bildirim konusuna baktım. Fakat şimdilik bildirimleri herhangi bir kalıcı dosyada tutmuyorum. Geçiçi olarak sadece online olan kullanıcılar o anda gelen bildirimleri görebiliyorlar. Bu konuya sonra tekrar döneceğim çünkü şimdilik önem sırası başka bir problemde: socket.io kullanarak dosya yüklemekte sıra. Doküman, fotoğraf, video, ve ses dosyalarını sunucuya gönderip kalıcı bir klasörde kaydetmeliyim. Front end kısmında da client’a bu dosyaları elbette sağlamalıyım. Dosya yükleme işlemi için 2 farklı node modülü ile sıkça karşılaştım. Ya kendim tamamen oluşturacağım ya da bu modüllerden birini kullanmayı düşünüyorum. Önce 3. parti herhangi bir modül kullanmadan deneyeceğim.",
        "32": "Tabii eşyanın tabiatı gereği problemler bitmemekte ve bu problemlere her zaman bir çözüm bulunuyor. ",
        "33": "179. Gün",
        "34": "Bugün dosya yükleme konusuna girdim. Başta zor olduğunu sanmıştım fakat araştırınca  kolay olduğunu anladım. Sadece biraz uğraştırıyor. Şimdiye dek gönderilen mesajlar sadece text olarak kullanıcıya gösteriliyordu. Fotoğraf, video, doküman (pdf,doc  uzantılı), ses dosyalarını nasıl göndereceğimi, kaydedeceğimi, kullanıcıya göstereceğimi düşünüp kurgulamamıştım. Bugün o kısma başladım.",
        "35": "Anlık olarak dosyayı sunucuya gönderme ve ilgili sohbete dosyayı iletme işlemi tamamlandı. Sadece farklı dosya türleri için farklı durumları biraz daha düzenlemem gerekiyor. Henüz sohbet geçmişine gönderilen dosya ile ilgili kısmı eklemedim. Yarın bu konulardaki eksiklerimi tamamlayacağım.",
        "36": "Yarın büyük bir kısmını bitiririm diye tahmin ediyorum. Sorun şu: o kadar OOP çalışmama rağmen hala daha o bilgileri hiç kullanmıyorum (Mantıksal olarak modülaritesini yüksek tutmaya çalıştığımı düşünsem de bu çok yetersiz). Sanırım sonrasında kodu düzenleyeceğim. Proje başlangıcında diyagramları çıkarıp ona göre hareket etmeliydim diye düşünüyorum. Olsun, bu da benim için yeni bir deneyim ve kazanım oldu.",
        "37": "180. Gün",
        "38": "Toplam 180 iş gününe ulaşıldı. Toplam 7 ay tamamlandı (7 ay – 53 dakika ). Bugün socket.io ile yaklaşık 10-15 farklı türe (mime types) sahip olabilecek dosya local bir klasöre kaydedilip, kaydederken de aynı zamanda ilgili sohbetteki kişilere dosya iletildi. Uygulama açılırken geçmiş sohbet bilgilerinde de gönderilen dosyalar ile ilgili veriyi de tutmak gerekli elbette. Bu akşam o kısma başlandı. Yarın öğle yemeğine kadar bitirmek hedefleniyor. Aslında mantığı çok basit fakat uygulaması biraz zaman alacak. Hatalı yerler, eksikler hala çok var düşününce. Bildirim kısmı tamamlanmadı, sohbetler statik olarak eklendi (Şu aşamada tüm kullanıcılara eğer sohbetleri yoksa Assistant ile default olarak sohbet açıldı sadece). Yarın, geçmişte yüklenen dosyaları da kullanıcıya göstermek için gerekli çalışma yapılacak. Sonrasında mikrofon kullanılarak ses verisi kaydedip karşıdaki kullanıcıya nasıl gönderilir o konu araştırılacak. Yapılacak. Sonrasında ise canlı olarak sesli ve görüntülü konuşma sisteme eklenmeye çalışılacak. Hayaller Paris gibi dursa da projenin istenen şekilde (özelleştirilmiş Skype gibi) tamamlanacağı tahmin edilmektedir.",
        "39": "Bugün zip,rar,pdf gibi türlere sahip dokümanlar ile ses ve video dosyaları sisteme yüklendi. Yüklenebildi. Client’a da canlı olarak iletildi ve client doküman olarak sunulan dosyaları indirebildi. Fotoğraf, video, ses dosyalarını ise front-end kısmında açıp görüntüleyebildi ve ayrıca indirebildi. Bugün yaşanan bir sorun vardı. Socket.io default olarak maksimum 1Mb veri gönderilmesine izin veriyordu. Fazlasını göndermek istersek bağlantıyı kapatıp tekrar açıyordu hiçbir şey yaşanmamış gibi.",
        "40": "Gönderilecek dosyanın sahip olabileceği maksimum boyutu için bir seçenek socket.io dokümantasyonunda bulundu ve gönderilebilecek dosyanın maksimum boyutu 100 Mb yapıldı şu an için. Bu durum nasıl bir soruna yol açabilir henüz bilinmiyor (bilmiyorum). Veriyi demetler (chunks) şeklinde göndermek düşünüldü başlangıçta fakat  daha zahmetli bir yol gibi göründüğü için bu kısayol tercih edildi.",
        "41": "Bence oluyor. Düzen ile beraber kaos da geliyor gibi hissediyorum. Elimden geldiğince düzene sokacağım."
    },
    "part19": {
        "1": "181. Gün",
        "2": "Bugün dosya yükleme, kullanıcıya dosyayı iletme, backend tarafında uygun olduğunu farzettiğim bir veri yapısını  kullanma kısımları tahmin ettiğimden daha kısa sürede bitti. Kullanıcının, farklı kullanıcıları ve kendi geçmiş sohbet içeriklerini aramasını sağlamalıyım. Bu sayede henüz sohbet başlatmadığı kişileri de ekleyebilir. Konuya direkt olarak girecektim fakat sonrasında anlamsız biçimde algoritmalar kitabında arama ile ilgili algoritmalara bakmak istedim. Bakınca oradaki farklı tipteki sorunlar ve çözümleri sadece okudum. Ve tabii ki üzerlerine düşündüm. Örneğin “Travelling salesman problem” vardı graf algoritmalarına bakarken karşılaştığım. Pazar günü onun üzerine düşünmek, uygulamalarına bakmak istiyorum. Anladığım kadarı ile genel bir çözüm metodu yoktu ve ilgimi çekti. Yarın normal şekilde kaldığım yerden devam edeceğim. Pazartesi gününe kadar farklı kullanıcıları ve mesajları arama, yeni bir kullanıcı ile sohbet başlatma gibi konuları tamamlamaya çalışacağım.",
        "3": "182. Gün",
        "4": "Şimdilik sadece kişileri arama ve sohbet başlatma kısımlarını çalışmaya başladım. Geçmiş sohbetlerdeki mesajları arama ve kullanıcıya göstermeyi şu aşamada yapmayacağım. Çünkü o kısım çok daha farklı bir mantık içeriyor. Sırayla ilerlemeliyim. Bugün doğrusu biraz daha front end tarafı ile oynadım diyebilirim. Ama burda boş vakit geçirmek değil de ne yapacağımı düşünmek üzerineydi biraz.",
        "5": "183. Gün",
        "6": "Bugün bitireceğimi tahmin ettiğim kısmı (kullanıcı ekleme) henüz bitiremedim. Birkaç yerde takılı kaldığım için ilerlemem biraz yavaşlamıştı. Yarın tamamlamaya çalışacağım. Her gün hem front hem back end’e çalışarak ilerliyorum şu aşamalarda. Biri olmadan diğerinin anlamı pek olmuyor.",
        "7": "184. Gün",
        "8": "Bugün kullanıcı ekleme işlemini (arkadaşlık isteği gönderme ve kabul edilip edilmemesi durumlarını) tamamladım. Front end tarafında birtakım problemler kaldı fakat yarın çözmeye çalışacağım. O problemler bittiğinde grup oluşturma durumunu yapmaya başlayacağım.",
        "9": "185. Gün",
        "10": "Bugün grup oluşturma mantığını tamamladım fakat yine client tarafında birkaç problem kaldı. Problemlerin çoğunluğu  frontend kısmında oluşuyor çünkü backend tarafı çok daha sade. Yarın öğlene kadar grup kurma durumu ile ilgili bir problem kalmayacak diye tahmin ediyorum. Sonrasında sizin de dediğiniz üzere herkesin default olarak sohbete katıldığı bir genel oda/grup oluşturacağım. ",
        "11": "186. Gün",
        "12": "Bugün grup oluşturmadaki problemler ve bildirim göstermedeki sorunlar giderildi. Sonrasında kullanıcının fotoğrafı static olarak verildiği için, dinamikleştirmek için kullanıcı tercihleri kısmında “isim, soyisim, profil fotoğrafı, şifre” alanları tanımlandı. Şifre değiştirmek için SSO sunucusu ile tekrar iletişime geçilip kullanıcı oraya yönlendirilecek. Ama diğer işlemler Chat sunucusunda tamamlanacak. Henüz tamamlanmadı. Yarın bitirilmeye çalışılacak.",
        "13": "Bugüne kadar yapılanların en özet hâli:",
        "14": "SSO’da kaydı olan kullanıcı gerekli bilgileri ile giriş yapar. Oturumunu her yerden kapatabilir ya da sadece bulunduğu cihaz-tarayıcı-dan kapatabilir.",
        "15": "Kullanıcı Chat’e girdiğinde otomatik olarak genel chat grubuna girer.",
        "16": "Kullanıcı, diğer kullanıcıları arayabilir (kayıtlı kullanıcıları tarar), istediği kişiye arkadaşlık isteği gönderebilir. Gönderdiği kişi Kabul edince konuşmaya başlayabilirler.",
        "17": "Kullanıcı grup oluşturup, arkadaşlarını ekleyebilir.",
        "18": "Kullanıcı birçok farklı türde dosyayı sohbette gönderebilir. Gönderilenleri indirebilir.",
        "19": "Kullanıcıya arkadaşlık isteği gelirse ve kendisi offline ise, bildirim görünmektedir (online iken de görünür)",
        "20": "Kullanıcı statüsünü (meşgul, uzakta, aktif olarak) değiştirebilir. Offline durumu henüz yazılmadı. Bu durum kullanıcıdan bağımsız olarak, oturumu belli bir süre kapalı ise otomatik olarak verilecek.",
        "21": "Yeni özellikler eklenirken, geçmişten gelen problemler ise çözülmektedir. Çıraklık eseri olarak yapılan bu iş kişinin (Buğra) seviyesini belli etse de (çok amatörce), gelişim bu şekilde sağlanacaktır. Öyle umuyorum.",
        "22": "187. Gün",
        "23": "Bugün dosya alışverişini sizin dediğiniz şekilde -dosya sunucusu biçiminde- yazıp, hem profil fotoğrafları hem de sohbetlerde paylaşılan dosyalar için düzenleyip tamamladım. Gün sonunda bu konudaki isterleri tamamladım. O düzenlemeden sonra fotoğraf güncelleme ve anlık olarak diğer kullanıcılarda gösterilmesi de tamamlandı. Diğer kullanıcı bilgisi güncelleme-değiştirme kısımlarını yarın tamamlamaya çalışacağım.",
        "24": "188. Gün",
        "25": "Bu hafta aklımda olan neredeyse birçok şeyi yaptım. Evet daha rahat bir haftaydı fakat boş ya da verimsiz geçtiğini düşünmüyorum.",
        "26": "Bugün bir kutsal kitabı okur gibi geçti. Programlama üzerine, object-oriented ve javascript üzerine okumalar yaptım. Bugün kullanıcı bilgileri güncelleme kısmını tamamlamayı düşünmüştüm başta fakat hep aynı bilgileri kullanarak ya da ufuk açıcı ve daha heyecan verici bir şey yapmaktan uzak kaldığımı hissettiğim için biraz daha teori kısmına yöneldim. Bir şeyden kaçmak ya da korkmak değil, işin felsefesine (under the hood’una) olan ilgimden dolayı bugünü biraz daha farklı şeyleri öğrenmeye-okumaya ayırdım.",
        "27": "189. Gün",
        "28": "Bugün profil ile ilgili bilgileri güncelleme kısımlarını tamamladım. Sonrasında mesaj editleme, silme, kopyalama gibi mesajlar üzerindeki yapılabilecek işlemleri tamamlamaya çalıştım fakat yarın sabaha kaldı. Tamamlanınca gruplarda kullanıcı silme, admin ekleme ya da kaldırma, grup ismi değiştirme gibi durumları yapmaya çalışacağım. Backend tarafında herhangi bir problem olmuyor fakat zamanın çoğunu frontend tarafı alıyor. Ben de bir an önce bitirmek istesem de sanırım oyalanıyorum. En baştan nesne yönelimli düşünmeliydim fakat sonrasında o hâle getiririm dediğim için biraz karıştı durumlar. Bu proje ile insanlar neden React gibi framework’ler oluşturmuşlar biraz daha iyi anladım aslında. Framework’den çok neden o kadar fazla OOP, MVC, SOLId, v.s birçok doktrin ya da fikir üzerinde çokça durulmuş daha çok anladım. Bugünlük bu kadardı.",
        "29": "190. Gün",
        "30": "Dün eksik kalan kısımlar (mesaj editleme, silme, kopyalama durumlarının bazı kısımları) tamamlandı. Bugün, bir kullanıcı grup ismine tıkladığında olacak durumlar işlenmeye başlandı. Grupta olan kişilerin listesi, admin-ler-i görüntüleme, gruptan ayrılma gibi konulara girildi. Henüz bitmedi. Yine frontend kısmı daha çok zaman aldı. Yarın sizin dediğin konu üzerine okumalar yapılıp, ilgili yazılımlar üzerine rapor oluşturulacak."
    },
    "part20": {
        "1": "191. Gün",
        "2": "192. Gün",
        "3": "193. Gün",
        "4": "Bu günlerin çalışmasını içeren dosyaları maalesef kaybettim :(",
        "5": "194. Gün",
        "6": "Sabah offline olma durumunu tamamladım. Kullanıcı giriş yaptığında “available” durumunda oluyor. Sonrasında, “away, busy, available” seçeneklerinden birini seçebiliyor. Fakat kullanıcı çıkış yaptığında ya da uygulamayı kapattığında direkt offline durumuna getirildi. Sonrasında mesajlar için bildirim kısmı, kısmen tamamlanmıştı. Fakat kurduğum veri yapısı sizin de dediğiniz üzere daha büyük sistemlere ölçeklendirildiğinde çok daha fazla boyut kaplayıp, daha fazla hesaplama süresi gerektirecek. Bu yüzden yarın o kısmı düzeltip eksik kalan kısımları tamamlayacağım. Daha öncesinde normal ve istenen şekilde çalıştığı görülen “tüm oturumları kapat” durumu bugün çalışmadı. O kısmı düzeltmek için de ekstra bir zaman verildi. Düzeltildi.",
        "7": "195. Gün",
        "8": "Bugün mesaj bildirimi kısmını tamamladım. JSON şeklinde verileri tuttuğum için ve kullanıcı id’leri ile ilgili veri yapısını daha önce birçok farklı yerde kullandığım için bildirim kısmını sadece kullanıcı id’si ve ilk okumadığı mesajın tarihi ile ilişkilendirdim. Tüm yapılar JSON dosyası ve formatı üzerinde olduğu için gelecekte ilişkisel olmayan bir veritabanı yönetimi sistemi kullanılırsa bu yapı korunabilir. Ya da değiştirilebilir. Şu aşamada o düşünülmedi. Bugün bildirim kısmı tamamladıktan sonra kodda yapılan değişiklikler sırasında geçmiş yazılan birkaç kısım bozulmuştu fakat sonrasında düzeltildi.",
        "9": "Akşama doğru mesajların yazıldığı input alanının skype’ta ya da farklı mesaj uygulamalarında olduğu gibi mesaj uzadıkça dikey olarak genişleyebilmesi sağlanmak istendi. Fakat bu dinamik yapı input elementi ile yapılamadığı için (aslında javascript aracılığı ile yapılabilir mi hiç düşünmemiştim.) input alanını bir span ile değiştirip, span bir input olarak kullanılacak. O kısım yarım kaldı ama yarın sabah düzeltilecek.",
        "10": "Chat sıralamasının, en son mesaj yazılmış chat’e göre oluşturulması gerekiyor. Yarın o kısmı tamamlamaya çalışacağım. Bir büyük eksik var. Bir arkadaşı sohbetlerden silmek. Bu özellik henüz eklenmemişti. Yarın o da tamamlanacak. Eğer yarın bu özellikler tamamlanırsa, başka temel bir eksik şu aşamada görünmüyor.",
        "11": "Eğer farklı sorunlar bulunuyorsa düzeltebileceğimi düşünüyorum.",
        "12": "196. Gün",
        "13": "Bu sabah ve öğle saatlerinde mesaj yazılan input alanının doğru (istenen) şekilde çalışması sağlandı. Sonrasında yazılan mesajların tarihleri skype ve diğer mesajlaşma uygulamalarında olduğu gibi saat, haftanın günleri, ya da “gün/ay/yıl” formatına çevrildi. Sonrasında da son sohbetlerin sıralamasını tamamlanacaktı. Aklıma gelen ilk mantığı oluşturmak yerine farklı ve algoritmik açıdan nasıl daha optimum bir kod yazabilirim diye düşündüm. Bu biraz zamanımı aldı. Bu kısım tamamlanmadı fakat yarın öğlene kadar tamamlanacak. Sonrasında da arkadaş silme özelliği eklenmiş olacak.",
        "14": "197. Gün",
        "15": "Sabah, sohbetlerin son mesaj tarihine göre sıralanması tamamlandı. Ardından arkadaş silme özelliği eklendi. Gruptan çıkma kısmında da bir takım sorunlar vardı ve düzeltildi. Genel sohbetten çıkma gibi bir durum henüz konulmadı. Uygulama, masaüstü uygulamasına dönüştüğünde bildirimleri sessize alma kısmı da eklenirse çok güzel olacağı tahmin ediliyor.",
        "16": "Şimdiye dek yaşanan ve geçmişten gelen problemler çözüldü. Eğer bir sorunla karşılaşılırsa tekrar düzeltilebilir ama ciddi bir problem bulunmadı.",
        "17": "Akşam saatlerine doğru 3 ya da 4 farklı konu akla geldi:",
        "18": "Peer-to-peer mesaj gönderme işlemi nasıl yapılabilir ve mesajların gizliliği nasıl sağlanabilir? Mümkünse bu durum da eklenecek.",
        "19": "Ses kaydedip gönderme durumu eklenecek. (MediaRecorder api ile)",
        "20": "Canlı bir şekilde videolu ve sesli sohbet eklenecek. ",
        "21": "Ilk 3 madde tamamlandığında bir sohbet uygulamasının en temel işlevleri sağlanmış olacak diye düşünülüyor",
        "22": "Giriş kısmı backend olarak tamamlanmış olsa da frontend’I henüz çok ilkel. Sonrasında front-end’I yazılacak.",
        "23": "Birden fazla kullanıcının aynı anda yaptığı işlemlerde json dosyasından yapacakları işlemlerde problemler olabilir diye düşünülüyor. Bu yüzden bir veritabanı yönetim sistemine geçiş yapılabilir(yapılmalı).",
        "24": "Kodun geliştiriciler için okunabilirliği, düzenlenmesi, güncellenmesi konuları için OOP’ye uygun bir standarda getirilmeli (En baştan yapılması gerekliydi).",
        "25": "198. Gün",
        "26": "Bugün açıkçası biraz daha yapacaklarım üzerine planlamalar ve ilgili konuları araştırmak ile zaman geçti. Neler yapmam gerektiğini düşündüm. Farklı insanların kodlarını ve görüşlerini okudum genel olarak ilgili konular üzerine. Uçtan uca şifrelemeyi eklemeyecek olsam bile nasıl çalıştığını öğrenmek istedim. Öğrendiğimi düşünüyorum.",
        "27": "199. Gün",
        "28": "Bugün WebRTC’ye giriş olarak Google’ın sunduğu dökümanları okumaya başlamıştım. Okuduğum doküman direkt kodlama kısmı ve kodların yorumları ile başladığı için olayın özünü bildiren ve kullandığı teknolojilerin yapısını ve mantığını açıklayan kapsamlı herhangi bir şey okumamıştım. Sonrasında vikipediden ve farklı birkaç kaynaktan daha konuyu araştırdım. Konu hakkında biraz daha fikir edinip (tatilde de fırsat olursa konuyu biraz daha araştırarak) elimi kirletmem gerekli. Perşembe günü sisteme bu durumları da entegre etmeye başlayacağım (deneyeceğim).",
        "29": "200. Gün",
        "30": "Bugün sizin gösterdiğiniz kısımlar üzerinde kodda değişiklikler yaparken birtakım anormallikler gerçekleştiği için yarın dikkatlice düzeltmeler yapacağım. Ondan öncesinde tamamen WebRTC ile canlı (stream peer-to-peer comm.) veri alışverişini öğrenmeye, uygulamaya çalıştım. Önce bulduğum örnekleri birebir kopyalayarak ve kodları okuyarak anlamaya çalıştım fakat biraz zorlandım. Uygulamamı nesne yönelimli hale getirdikten sonra tekrar bu kısma döneceğim."
    },
    "part21": {
        "1": "201. Gün",
        "2": "Bu sabah Javascript’te prototip ve nesne kavramlarına tekrar baktım. İlk moladan sonra, yazdığım kodları nesne yönelimli hâle getirmek için çalışmaya başladım. Çok uzun zaman alacağını düşünmüyorum. Ama temiz ve modüler bir şekilde yazmaya çalışacağım. Parça parça eski kodları değiştirerek restorasyonu tamamlamaya çalışacağım. Bir binanın nasıl inşa edildiğini basitçe bir gecekondu inşa ederek bir nebze öğrendim. Şimdi ise edinilen tecrübe ve yapılacak işin bilgisine ve deneyimine biraz da olsa sahip olarak, temeli sağlam bir bina haline getirilmeye çalışılacak.",
        "3": "202. Gün",
        "4": "Bugün yazılan chat uygulamasının nesne tabanlı hale getirilmesine devam edildi. Ardından bug tracking ve knowledge base üzerine olan uygulamalar araştırıldı, karşılaştırıldı. Biraz sakin bir gündü. Pazartesi daha iyi bir tempoyla devam edilecek.",
        "5": "203. Gün",
        "6": "Bugün de fonksiyonel olarak yazılmış bir kodu nesne tabanlı hale getirmeye çalıştım. Günün son bir saatinde knowledge base hakkında bir yazı okudum. Okurken yine “bunu ben de yaparım ki” fikri cereyan etti fakat cahil cesareti ile bu düşünceyi belirtip sonrasında yapmaya çalışırken afallama ihtimalimi düşünerek söylememeyi yeğledim. Ama gerçekten de yapılabilir eğer şu an sahip olduğum görevleri tamamlayabilirsem.",
        "7": "Aklıma birçok fikir geliyor çalıştığım konu dışında da. Elbette saçma olabilir ama bir tanesi de şu: Görsel teknolojilerin neredeyse hepsinin temeli bir ekran ya da bir düzlem ve ona bakan gözlerin o ışığı elde etmesi üzerine. Göz bebeğinin hareketini takip ederek ışık kaynağının doğrultusunun değiştirilebildiği, minik ve maksimum gücü önceden (geçici ya da sürekli körlüğe sebep olmamalı) belirlenmiş bir projeksiyon cihazı düşündüm. Sonrasında bu düşüncenin gereksiz karmaşa ve zorluk içerdiği fikri aklıma yerleşti. Sonrasında görüş açısını 360 dereceye çıkarabilme fikri geldi kameralar ile. Siz roket projesinden bahsedince de aklıma Arduino ile neler yapabileceğim geldi. Ya da ufak bir rocket simülasyonunun web üzerinde nasıl yazılabileceğini düşündüm. Webgl, three.js, ya da d3. Js gibi teknolojileri kullanarak neler yapabileceğimi hayal etmeye çalıştım böyle bir simülasyonda. Açıkçası yapılabilecek o kadar çok şey var ki… İşteki motivasyon kaynaklarımın önceliklerini tam bilmiyorum ya da kendime bu sıralamayı yaptırmaktan kaçıyorum fakat bunlardan biri de kesinlikle yapılacak-yapılabilecek çok şey olması. İyi ki.",
        "8": "204. Gün",
        "9": "Bugün authentication kısmı olmasa da genel chat mantığının bulunduğu kısım nesne yönelimli hâle getirildi. Yarın amaç authentication ile ilgili kodları da o hâle getirip sonrasında klasörlendirme konusuna başlamak ve bitirmek planlanıyor. Bugün epey düzeltme yapıldı diye düşünüyorum. Yarın authentication kısmı da tamamlandığında çok sorun kalmayacak OOP üzerine diye düşünüyorum. Sorun çıkarsa da zorlanmadan düzeltilir diye düşünüyorum. SSO sunucusunun backend kodlarını da ayrıca nesne yönelimli hale getirmem gerekli elbette. Onu da sonrasında tamamlayacağım. Tüm bunlar bittiğinde ise knowledge base ve bug tracking konularını içeren bir uygulamanın temel özelliklerini çıkarılacak. Bu özelliklere uygun olarak özet niteliğinde bir yazılım gereksinim dokümanı hazırlanabilir, ya da sisteme implemente etmeden önce genel gereksinimler ve bu gereksinimlere uygun kullanım senaryoları ile nesnelerin template’i çıkartılabilir.  Elbette bu konularla (bug tracking ve kb) ilgili bir rapor da yazılacak.",
        "10": "205. Gün",
        "11": "Bugün authentication kısmını nesne yönelimli hale getirmek beklediğimden daha çok zaman aldı. Birçok hata ile karşılaştım ama sonrasında tamamladım. Yarın klasörlendirme kısmını tamamlamaya çalışacağım. Sonrasında vakit kalırsa eğer knowledge base üzerine okuma yapıp fikirlerimi geliştirmeye çalışacağım.",
        "12": "206. Gün",
        "13": "Öncelikle özür dilerim. Hâla daha nesne yapısını bazı noktalarda kullanmadığım için. Uygulayamadığım için değil aslında, sadece nerede uygulamam gerektiğini tecrübesizlikle ya da az bilgisizlikle göremediğim için. Ayrıca, yine çok teşekkür ederim ki vermiş olduğunuz her bilgi için. Çünkü kullandığım tüm yapılarda gösterdiğiniz bilgilere riayet etmeye çalışıyorum ya da öğrenebildiklerimi ve anlayabildiklerimi uygulamaya çalışıyorum.",
        "14": "Bugün uygulamanın kodlarını ayrıştırma işlemlerini yaptım. Henüz bitmedi. Controller kısmında kalmıştım. Söyledikleriniz üzerine yarın yaptıklarımı düzeltmeye çalışacağım.",
        "15": "Aklımda iş sonrasıda hobi olarak yapabileceğim bir plan geldi, ne kadar verimli ve katkı sağlayabilecek bir plan olduğunu henüz bilmesem de. Bir domain adresi almıştım. En temel seviyeden başlamak amacı ile ve hobi niyeti ile bir web sunucusunu kendim oluşturmak istiyorum eski bilgisayarda. Ardından basitçe içerikleri (hello word şeklinde) ilgili domain adresi üzerinden sunduktan sonra cloudflare’i kullanmaya çalışacağım. Sonrasında ise kendi web siteme saldırma yöntemlerini öğrenip ddos ya da diğer yöntemlerle (şu an pek bir fikrim olmasa da) saldırmayı ya da sızmayı, ve bunun üzerine nasıl önlemler alınabileceğini öğrenmeye çalışacağım.",
        "16": "207. Gün",
        "17": "Bugün de backend kısmında düzeltmeler yapıldı. Başlangıçta her şey fonskiyonel şekilde programlanmışken ve global değişkenlerde oldukça çokken şimdi ise class-object yapısına evrim sağlandı. Yarın routing kısmı da tamamlanıp sonrasında son düzenlemeler de tamamlanacak. Haftaya olabildiğince eksikler tamamlanıp, Cumartesi gününe kadar teslim edilmeye hazır hâle getirilmeye çalışılacak. ",
        "18": "208. Gün",
        "19": "Bugün routing kısmını da tamamladım. Beklediğimden biraz daha fazla zaman aldı birkaç hata ile karşılaşmıştım fakat sonrasında düzelttim.",
        "20": "Haftaiçi yapmam gerekenleri belirledim:",
        "21": "Gruptan çıkma durumunda bir anormal durum yaşanıyordu. Onu düzelteceğim.",
        "22": "Uygulama açıldığı anda default olarak son konuşulan sohbet içeriği gösteriliyordu. Onun yerine farklı bir içerik hazırlayıp sunum-başlangıç içeriği olarak sisteme ekleyeceğim.",
        "23": "Kullanıcı girişi ve çıkışı esnasında frontend’te herhangi bir tasarım yok. Soft geçişleri olan bir UI’ a sahip olmasına çalışacağım.",
        "24": "Dosyaların da silinebilmesi durumunu ekleyeceğim.",
        "25": "Bunları maksimum 3 günde tamamlamalıyım. Perşembe ve cuma günleri ise tamamen uygulamanın teslime hazır hâle gelmesini sağlamaya çalışacağım.",
        "26": "209. Gün",
        "27": "Bugün uygulama içerisinde gönderilen dosyaların silinmesi ve kaydedilmesi işlemleri sisteme eklendi. Henüz tamamlanmadı ama yarın ilk molaya kadar eksik kalan kısımların tamamlanacağı düşünülüyor.",
        "28": "Daha öncesinde ise  mesajlara sağ tıklandığında seçeneklerin bulunduğu pozisyon daha da optimize edilmeye çalışıldı. Tıklanan mesaj üzerinde (tam olarak tıklandığı nokta üzerinde) seçenekler menüsü ortaya çıkarıldı. ",
        "29": "Yarın authentication sırasındaki geçişler frontend tarafında tamamlanacak. Eğer vakit kalırsa tespit edilen bir ya da iki tane anormallik giderilmeye çalışılacak.",
        "30": "210. Gün",
        "31": "Bu sabah ilk iş dünden kalan yarım kısmı(sohbet içinde gönderilen dosyaların silinmesi gibi işlevlerin bulunduğu kısım) tamamlamaktı. Tamamlandı. Sonrasında farklı route’lar arasındaki geçişleri oldukça soft hâle getirmeye çalıştım. Bence getirebildim (en basit şekilde fade-in fade-out’lar kullanarak). Cache ve web worker kullanılarak da yapıldığını gördüm fakat o karmaşıklığa şu an için gerek yoktu.",
        "32": "Ek olarak network’e bakarak hatalı bir durum var mı diye talep edilen verileri kontrol ederken favicon.ico dosyasını tarayıcının talep ettiğini görüp, ne olduğunu araştırıp, onu da sisteme dahil ettim. Şu an normal olarak çalışmakta. Fakat  tarayıcı favicon.ico dosyasını bazen talep edip bazen de etmiyor ve sanırım bunu önbelleğine bakarak yapıyor. Ya da farklı bir mekanizma var ve henüz onu anlamadım.",
        "33": "Dün ve bugün güzeldi. Yarın daha da güzel olacak diye umuyorum. Bugün yeni şeyler yazdım. Yarın daha önce yazdığım kodlardaki hataları fix’lemeye çalışacağım."
    },
    "part22": {
        "1": "211. Gün",
        "2": "Bugün ilk iş olarak sizin de daha önce değinmiş olduğunuz landing page durumunu istenen duruma getirdim. Bu durumu tamamlarken oluşan iki küçük hatalı kısmı düzelttim. Sonrasında ise kişinin bir sohbeti silip tekrar aynı kişi ile sohbet oluşturması sırasında oluşan bir hatayı giderdim. Cuma günü ise gruptan çıkma sırasında oluşan hatalı bir kısmı da giderebilirsem cumartesi günü sunuma hazır ve yeterli seviyede olacağını düşünüyorum.",
        "3": "212. Gün",
        "4": "Bugün teslimden önce son düzenlemeleri yapmak istedim. Bulduğum hataları düzelttim. Birincisi gruptan çıkma ve gruba ekleme kısmı front tarafında sorunluydu. Tamamlandı. İkinci olarak ise yüklenen dosyalar kısıtlanmıştı. Bu kısıt kaldırıldı. Mime type’lar backend tarafında control edilip kullanıcıya iletildi. Buradaki sorun da ortadan kalktı. Mime type’I ne ise o dosya uzantısı ile beraber dosya sunulmakta.",
        "5": "213. Gün",
        "6": "Bugün electron’un dokümanına bakarken hem node.js hem de google chrome ile ilgili iki ayrı linki sayfalarında gördüm.",
        "7": "Bu linkteki",
        "8": "karikatür sadece chrome’u anlatıyordu. Okudum. Bundan önce ise son kez daha kodu düzenleyip size gönderdim. ",
        "9": "Sonrasında ise tekrar node.js dokümantasyonuna göz gezdirirken bir haberle karşılaştım doküman içindeki linklerden birinde.",
        "10": "2016 da bir Türk’ün dünya çapında web geliştirmeyi kısa bir süreliğine aksatması üzerine",
        "11": ". Daha doğrusu npm’in buna sebep olması dolayısı ile. ",
        "12": "Sadece 11 satır ve içeriği basit olan bir kodun npm’den kaldırılması ile react ve babel kullanan geliştiricilerin birçoğu sorunlar yaşamış ve bunu görünce çok şaşırdım.",
        "13": "Evet bugün sakin bir gündü. Chrome geliştiricilerinin karikatür halinde fikirlerinin ve yaptıklarının özetini okumak çok keyif Verdi açıkçası. Yıllardır bir web tarayıcısı kullanmıştım fakat şimdiye dek bilinçli bi şekilde üzerine bu kadar düşünmemiştim nasıl çalıştığı üzerine. Her ayrı bir sekmenin ayrı bir process olarak düşünülmesi, sandboxing ile zararlı yazılımları engelleme fikri, asenkron yapının nasıl bir ihtiyaçtan kaynaklanıp yazıldığını (evet bunları zaten ya biliyordum ya da farkındalığına varmadan öğrenmiştim aslında). V8 js motorunun yazılma sebebi ve iyi bir garbage collector’un yoksunluğu ile ilgili kısım da oldukça keyifli bir okuma sunmuştu. Atatürk yaşasaydı bence okunmasını genel manada önerebilirdi.",
        "14": "Aylar önce hatta şimdi bile (çok sık olmasa da artık) size anlamak için aşırı çaba sarfediyordum. Anlattıklarınızı kavramayı, öğrenmeyi, kullanabilmeyi, o dili Türkçe’ye çevirmeden konuşabilmeyi öğrenmeye çalışıyordum. Bence ilerledim ama bir junior’ın junior’ı olarak daha çok yolum var.",
        "15": "214. Gün",
        "16": "Bugün tamamen electron dokümanına bakarak uygulama örneklerini kendim de yapmaya çalıştım. Tarayıcılarda olduğu gibi Electron’da da farklı api’ler bulunuyor. Örneğin clipboard api’si için çok benzer şekilde electron’da da ayrı bir api olarak sunuluyor. Uyumsuzlukların olacağı kısımlar tahmin edilebilir ve electron’a da çok zorlanmadan geçirilebilir diye düşünüyorum. Yarın eğer farklı bir görev verilmezse electron’a geçişe başlayacağım.",
        "17": "Bugün ayrıca yazılan kodlar ile ilgili sizin söylediklerinizi de not aldım. İlgili kısımları değiştireceğim ve hafızama sebeplerini kazıdım.",
        "18": "215. Gün",
        "19": "Bugün uygulamayı direkt electron’a geçirdim aslında. Eskiden çalışan her yer normal olarak hâlâ çalışıyordu. Inter Process Communication kısmı benim anladığım kadarı ile şu (tekrar yazıyorum çünkü ileriki zamanlarda bu notlara bakabilirim): Chrome veya herhangi bir tarayıcı çalışırken kullanıcı birden fazla sekme açabilir. En ilkel tarayıcılar tek bir sekme olarak düşünülmüş anladığım kadarı ile. Birden fazla sekme olma durumunda her sekmenin javascript işlemlerini, bellek işlemlerini ayırma gereği duyulmuş. Çünkü bir sekmede eğer bir site patlarsa diğer tüm sekmeler etkileniyormuş ve bu yüzden tarayıcı çöküyormuş (Çok uzak bir zamanda olduğu için zor hatırlıyorum ama evet böyle bir şey vardı). Her sekmeye ayrı bir process denilmiş ve tüm bu küçük process’ler main bir process ile yönetilmiş. Bu yöntem diğer tüm tarayıcılarda da sonrasında benimsenmiş. Electron’da buradaki mantığı uygulayarak main process ve rendering process olarak ikiye ayırmış. İki ayrı context olarak da düşünülebilir gibi geldi. ",
        "20": "Henüz session/cookie kısmına çok detaylı bakamadım. Orada bir sorun olup olmadığına yarın bakacağım.",
        "21": "Şimdi bu satırları yazarken aklıma günlük yazılan raporlarla ilgili bir template oluşturma fikri geldi ama benim zihnimdeki template çok sade olduğu için ve yazarken de uğraştırmadığı için vazgeçtim.",
        "22": "216. Gün",
        "23": "Bugün öncelikle Electron uygulamasının üst barında yer alan uygulama ikonu ve ismi kısımlarını güncelledim. Üst barın rengini değiştirmekte problem yaşadığım için üst barı tamamen gizleyip rendering process kısmında tekrar yazdım istediğim şekilde. Yazarken  minimizing, maximizing, unmaximizing, closing işlevlerini de bu kısma ekledim. Normalde gelen bildirimler sadece uygulama içerisinde görünüyor. Fakat uygulamayı kullanan kişinin sayfası minimize edilmişse masaüstü bildirimi gelmesini sağlamalıyım. Yarın bu kısmı ekleyeceğim. Tabii ki electron’un sağladığı api ile bunu yapacağım. Bugün ayrıca sayfa boyutlandırma kısmını da electron kullanılması durumuna göre düzenledim. Genel olarak electron’a özel rendering işlemlerini ayrı bir dosya olarak ilgili dosyalara vereceğim sadece. Yarın o kısmı da tamamlayacağım.",
        "24": "217. Gün",
        "25": "Input alanı içeren bir bildirim kutusunu windows os’ta göstermeye çalışmak, pire için yorgan yakmak gibi geldi.  İlgili modülü kullanabilmek için birçok ayrı yazılımı da eklemek gerekiyor. Neden electron.js’in içine eklenmemiş ya da neden daha kolay kullanıma hazır hale getirilmemiş anlamadım ama bu biraz daha aşırı detay bir kısım olarak kalmış gibi geldi.",
        "26": "Bu akşam ofiste tekrar deneyeceğim. Ama büyük ihtimalle yarın hiç bu kadar ayrıntıya girmeden normal bir bildirim gösterteceğim aksi gerekmediği sürece. Sonrasında uygulamayı paketleyip kullanıma hazır hale getirmeye çalışacağım. Uygulamanın sonrasındaki sürümlerinde eklenebilir diye düşünüyorum.",
        "27": "Tekrar bu projeyi verdiğiniz için çok teşekkür ederim. İş başa düşünce o kadar çok şey öğrendim ve yaptım ki (bence). İyi geceler.",
        "28": "218. Gün",
        "29": "Geç saate kalan bir rapor oldu öncelikle özür dilerim. Yine de yazmak istedim.",
        "30": "Bugün bildirim kısmını electron’un verdiği özellikler dahilinde tamamladım. Sonrasında yeni bildirim geldiğinde ve uygulama ilk açıldığı sırada görev çubuğundaki simgede flash tarzı bir görüntü yarattım. Sonrasında electron builder kütüphanesi ile uygulamayı paketledim. Çalıştı. Fakat bir problem vardı. Çerez verileri uygulama kapandığında kayboluyordu. Electron’da çalışırken de kayboluyordu fakat build edilince düzelir diye düşünmüştüm. Düzelmedi. Sonrasında araştırdım nasıl yapabilirim diye. Henüz bu sorunu çözemedim. Fakat tıpkı bildirimlerde olduğu gibi, session konusunda da electron’un sağladığı bir native api’yi kullanabilirim. Kullanmadan da yapılabilirdi diye düşünüyorum fakat denesem de yapamadım. Yarın ilk iş farklı bir çözüm yolu denenecek.",
        "31": "219. Gün",
        "32": "Bu sabah aklımda olan düşünceyi netleştirdikten sonra ufak bir google araması ile sorunumu çözdüm. Basitçe, halihazırda çerez bilgileri electron uygulamasına geliyordu. Fakat kalıcı olarak bir yerde bu verileri tutmuyordu (modern tarayıcıların yaptığı gibi). Çerezlerdeki değişimler için “changed” event’i dinlendi. Çerezlerde değişim olduğunda Electron’un kendi belirlediği default bir lokasyona oturum bilgileri kaydedildi. Sonrasında da uygulama paketlenip kullanıma hazır hâle getirildi. Şu aşamada uygulama beni tatmin ediyor. Fakat daha da geliştirilmesi gerekli (Webrtc, notification kısmının düzeltilmesi, front-end iyileştirmeleri, ve tabii ki  ölçeklendirilebilir bir uygulama olması için chat verilerinin backend’den çekilmesi işleminin optimize edilmesi gibi).",
        "33": "Sonrasında daha önce okumaya başladığım fonksiyonel programlama ile ilgili kitabı okumaya devam ettim. Yeni ufuklar keşfetmek, bakış açımı genişletmek ve kendimi daha güçlü hissetmek için sanırım. Şimdi baktığım kısımlar tamamen matematik, mantık, temel Haskell veri yapıları üzerineydi. Hobi olarak ve boş zamanlarda okuyup bitirmek istiyorum sadece.",
        "34": "220. Gün",
        "35": "Bugün sadece PHP dokümanını okudum. Başlangıçta hızlıca bir tekrar yapıp siz görev verdiğinizde hazır olmak istemiştim. Unuttuğum şeyler varsa pekiştireyim dedim. Ama her baktığım konuda bakar bakmaz hafızam hemen canlandı gibi hissettim. Biraz fazla gaza gelip, ben neden kendi dilimi geliştirmiyorum ki aslında çok da zor değiller gibi bir fikre kapıldım (Yine cahil cesareti olabilir). Sizin “algoritmayı yazıp, programlama dilinde çıktısını sağlama” fikrinizin tüm dillere uygulanma ihtimalini düşündüm. Güzel olurdu (Tabii böyle bir şey open source ve herkesin geliştirmesine açık olursa anlamlı ve gelişmiş olurdu). Bugün kısaca PHP bilgimi tazelemekle geçti."
    },
    "part23": {
        "1": "221. Gün",
        "2": "Bugün php dokümanını okumayı bitirdim (dizi metotları gibi kısımları atlayarak). Sonrasında çeşitli yazılım bilgilerini okudum, araştırdım. Sonrasında sizin gönderdiğiniz dosyaları incelemeye başladım ama mental anlamda çok yorulduğumu hissedip sonrasında biraz daha farklı konulara baktım. Bugünlük bu kadardı.",
        "3": "222. Gün",
        "4": "Bugün Lumen dokümanını ve dolayısı ile de Laravel’i biraz okudum. 9 aydır framework ve benzeri yapıları hiç kullanmadığım (ya da çok çok az) için sanırım bu kullanıma hazır template’leri sevemedim (Sanırım ilk defa karşılaştığım için bir tepki oluştu, vücudun bazı uyaranlara karşı alerji oluşturması gibi). Sevemesem bile bu verilen bir görev olduğu için ve kabul edildiği için tabii ki de öğrenecektim/çalışacaktım. ",
        "5": "Son betimlemeyi de yapmak isterim ki içimde kalmasın. Framework bir inanç/kültür gibi. Aynı framework’ü kullanan geliştiriciler ortak bir paydada bulunup birbirleri ile anlaşıyorlar ve hoşgörü içinde yaşayıp gelecek kuşaklarda aynı inancı ve kültürü devam ettirerek mutlu mesut yaşıyorlar. Bu inanç/kültür’ün  bulunduğu dil, geliştiricilerin konuşma dilleri. Kimi geliştiriciler inanç/dil milliyetçiliği yapabiliyor. Kimileri “make peace don’t war” diyerek multicultural olarak her dil ve inançtan polen alıp bal yapıyor. Laravel, Yahudilik gibi. Eski bir inanç ve o da başka inançlardan türemiş. Ve başka inançlara da kapı açmış. Çok güçlü bir yapısı var ki kendisi ve türetildiği inançlar çok sağlam takipçilere ulaşmış. Kullandığı dil artık pek yaygın değil. Ve başka diller oldukça revaçta. Bu da o dilin ölmesine sebep olmasa da popülerliğini azaltıp community’sini gitgide azaltıyor. ",
        "6": "Bugün ne yaptım? Lumen’in dokümanlarına bakarken sıkıldım ve pratiğe başlamak için sizin gönderdiğiniz dosyayı çalıştırmak istedim. Çalıştıramadım. Veritabanı ile ilgili bir hata alıyordum. Sonra basit bir pratik olması için Lumen kullanan bir rest api yazımı ile ilgili tutorial’ı okuyup ve takip edip kendim oluşturdum. Veritabanındaki verilere ilgili endpoint ile postman’den eriştim. ",
        "7": "Anladığım kadarı ile lumen rest api ve mikroservis(ne olduğunu bilmiyorum) oluşturmak için yaratılmış. Verilen dosyada ise view’ler bulunmakta idi ve dolayısı ile konsept lumen'den çıkıp tekrar laravel’e bağlanmış. Bu yüzden başlangıçta lumen kullanmak, kendilerinin de 'yeni projelerinizde beni kullanmayın' uyarısı ile pek uyuşmamış. Ama yine de her türlü çalışan bir şey sanırım yaratılmış. Yine çok boş yaptım sanırım. ",
        "8": "Yarın sizin verdiğiniz dosyayı çalıştırmaya çalışacağım.",
        "9": "223. Gün",
        "10": "Bugün önce ilk gönderdiğiniz dosyaları gerekli sql sorgularını yazarak (database ve tabloları ekleyerek) çalıştırdım. Sonrasında asıl finans uygulamasının front-end’ine bakarak zihnimde nesneleri oluşturmaya çalıştım. Hazır bir hâlde her şey önümde olduğu için çok beyin yorucu değildi. Sonrasında tekrar Laravel’in dokümanlarına baktım ve okudum. Bugün biraz daha sakindi. Covid durumları, iphone düşüncesi biraz zihinde yer aldı.",
        "11": "224. Gün",
        "12": "Evet bir framework kullanmak basit görünse de o framework ile yazılan kodu anlamak pek kolay olmayabiliyormuş. Laravel dokümanı çok detaylı ve anlaşılır olsa da direkt bu konsepti bilmeyen bir insan için kodların niçin yazıldığının  eklenmemesi sonraki yazılımcıyı biraz zorlayabilirmiş. Bugün aldığım ders, bir kod yazmışsam neden o kodun var olduğunu açıklamam gerektiği üzerineydi. Elbette bir kod parçasını okuyunca ne iş yaptığı anlaşılsa da tüm parçaları birleştirmeye çalışmak zor olabiliyor.",
        "13": "Bugün daha backend tarafındaki kodların ne yaptıklarını tek tek anlamaya çalıştım. Bazı kısımlarda gereksiz uzatılmış kodlar gördüm fakat dokunmadım. Bazı yerlerde (hatta birçok kod parçasında) kırmızı uyarılar vardı ve nasıl düzgün çalıştığını henüz çözemedim bu kısımların.",
        "14": "Henüz sistemin nasıl çalıştığını tam çözemedim. Çözmeyi deneyeceğim, deniyorum.",
        "15": "225. Gün",
        "16": "Bugün de uygulamayı inceledim. View dosyaları ile backend arasındaki bağlantıyı anlamaya çalıştım. Yine MVC ve laravel’deki uygulanışını kavramaya çalıştım. Yarın öğleden sonra uygulamanın ilk açılmasından itibaren nasıl çalıştığını, route'ları, controller'ı ve kullandığı modüllerle modeli nasıl etkilediğini, frontend kodunun nasıl çalıştığını izlemeye ve anlamaya çalışacağım.",
        "17": "226. Gün",
        "18": "Bugün yine muhasebe uygulamasına baktım ve çalıştım. Sistemin çalışmasını anlamaya çalıştım. Route geçişlerini, controller’ın yaptıklarını, view’leri ve blade engine’I çözmeye çalıştım. Çok ufak birkaç değişiklik yapmaya çalıştım.",
        "19": "1 hafta aranın ardından sanki her şeyi unutmuş gibi hissetmiştim ama hemen hemen bir çok şeyi hızlıca hatırlayıp adapte olduğumu düşünüyorum.",
        "20": "Projede bana en ilginç gelen kısım backend’in farklı domain de olmasıydı. Neden böyle bir ihtiyaç doğdu bilmiyorum. Belki de bu kullanım hep vardır ve ben yeni öğrenmişimdir.",
        "21": "Bir sorunum var. Canlı bir sistemde kullanılan veritabanına laragon kullanarak nasıl ulaşacağımı ve değişikliklikleri yapabileceğimi henüz çözemedim. Örneğin sistemde kayıtlı kişi bilgileri ile giriş yapılıyor. Sisteme kayıtlı olmayan kişi bilgileri ile de giriş yapılabiliyor. Oysa ki 2. Durumda giriş yapamaması gerekiyor. Bu kontrolün nasıl çalıştığını, veritabanındaki verilere direkt laragon ile erişmeyi, Cors problemlerini nasıl çözebileceğimi, canlıda olan sistemi yerelde çalıştırmayı isteyince neden autoloader ile ilgili bir hata aldığımı anlamaya ve çözmeye çalışacağım.",
        "22": "227. Gün",
        "23": "Dün gördüğüm birkaç hatayı bugün düzeltmeye çalıştım. Öncelikle cors hatası nedeni ile backend api’den hiçbir veri çekilip front app’inde görünmüyordu. Request header’ındaki ilgili eksikler tamamlandı ve sorun çözüldü. Sonrasında hiç canlı bir uygulamada çalışmayan bünyem local’de veritabanına erişmeye çabalıyordu. Yapamadım. Sonrasında uygulamanın çöktüğü bir yer keşfettim. Bir url’e erişim sağlanmak istendiğinde onlarca isteğin axios ile gönderildiğini, bu durumun da birkaç sayfa yenilemede “429 too many request” hatası çıkardığını gördüm. Henüz düzeltemedim. Ama yarın çözebileceğimi düşünüyorum. İki sorun daha var: yanlış login bilgileri ile sisteme giriş yapılır gibi arayüz değişmekte fakat sonrasında login sayfasına geri dönülmekte. Bu düzeltilmeli. Birkaç farklı front end hataları da bulunmakta. O kısımlar da tamamlanmaya çalışılacak.",
        "24": "228. Gün",
        "25": "Bu sabah, dün  karşılaştığım “too many request”li problemi çözdüm. Fakat birkaç yerde de yine aynı “429 too many request” hatasını gördüm (Daha sık şekilde sayfa yenilemelerde olabiliyor). O kısımlarda henüz bir değişiklik yapmadım. Sonrasında login sayfasında yanlış veriler girildikten sonra ana sayfaya aktarılma problemini düzelttim. Giriş yapılmıyor ve hatalı şifre yada kullanıcı ismi girildiği bildiriliyor. Sonrasında biraz teorik bilgisayar bilimleri konularına baktım (mesai bitimine yakın). ",
        "26": "229. Gün",
        "27": "Bugün muhasebe programında bir değişiklik yapmadım. Hem laravel hem delumen için iki ayrı uygulama oluşturup en temel lumen ve laravel uygulaması ile yazılmış olan kodu karşılaştırdım. Eklenen kısımları not edip böyle bir uygulama yapılırken nelere dikkat edildiğini anlamaya çalıştım. Gün içinde karşılaştığım ya da merak ettiğim birkaç algoritmaya, mantık kapılarına, ve php ile ilgili Stackoverflow’daki soru cevapları okudum. Gün sonunda sizin söylediğiniz konuyu araştırdım. Okuduğum birkaç yazıdan aklımda kalanı size özetlemeye çalıştım fakat sanırım yanlış anlamış yada yorumlamış olabilirim. Şimdi tekrar o konuya bakacağım çünkü merak ediyorum.",
        "28": "230. Gün",
        "29": "Bugün",
        "30": "C programlama notlarını",
        "31": "biraz okumak istedim. Tabii öncesinde muhasebe programını tekrar kontrol ettim ve gözden kaçırdığım iki kısmı (frontend’de kaydetme ya da güncelleme ile ilgili iki butona basıldığında form verisinin gönderilmemesi) fix’ledim. Programın ana işlevlerini engelleyen ya da kısıtlayan farklı bir sorunla karşılaşmadım."
    },
    "part24": {
        "1": "231. Gün",
        "2": "Bugün tüm endpoint’lerin (neredeyse hepsi) listesini frontend kodlarından bakarak listeleyip, listedeki her durumu çalıştırdım. Bir hatalı kısım login/logout’ta yaşanıyordu ve o düzeltildi. Kdv oranı kısmında silme işleminin yapılamadığı durumda (Eğer kullanılıyorsa silinemiyor) Uyarı yazısı çıkarıldı. Yarın 429’lu hataların nerelerde yaşandığını test edip not alacağım.",
        "3": "232. Gün",
        "4": "Yapamamayı hiç sevmesem de bugün verilen görevi yapamadım. Aslında yapılabilir fakat Laravel’in dinamiklerine pek ısınamadığım için yapmakta da zorlandım. \"Fazla istek geldi\" sorununu çözersem http isteklerinde bir sorun kalmayacak gibi görünüyor. Sonrasında da frontend kodunu düzeltebilirim. ",
        "5": "233. Gün",
        "6": "Bugün 429 hatalarının neredeyse hepsi bitirildi (daha doğrusu 20 dakikalık ufak bir kısım kaldı). Hesap bilgileri kısmında para birimini eklemek ve güncellemek için çıkan seçenekler static yapıdaydı. Dinamikleştirildi. Her url’de endpoint’e gönderilen istek sayısı çoğunlukla 1 tane olmak üzere en fazla 3 tane olacak hâle getirildi. ",
        "7": "Dün çok verim alınmamış olsa da bugün aksine çok daha verimli geçti. Farkettiğim bir şey de şu oldu:  sadece backend bilmek ya da sadece frontend bilmek yeterli değil gibiydi. Sadece bir tanesi bilinse bile aradaki bağlantıyı da bilmek gerekliymiş. ",
        "8": "234. Gün",
        "9": "Bugün tüm endpoint’lerin front end’te hangi url’den çağrıldığı dokümante edildi. Tek bir Url’de gözden kaçan bir eksiklik tespit edildi ve yarın sabah o kısım da düzeltilecek.",
        "10": "235. Gün",
        "11": "Bir şeyleri fixlemek yerine üretmeyi görmeyi özlemişim. Bugün front end tarafında değişimler yapmaya çalışırken bolca görülen ve rahatsız eden bootstrap’li görünümü düzeltmek için sade bir şekilde tekrar tasarım yapmak istedim. Çok keyif verdi. Çok uzun sürmeden bitirebileceğimi düşünüyorum.",
        "12": "Bugünün en güzel teknik dışı paylaşımı: Yaşamaya dair (Nazım Hikmet): ",
        "13": "...Yani, öylesine ciddiye alacaksın ki yaşamayı,",
        "14": "yetmişinde bile, mesela, zeytin dikeceksin,",
        "15": "hem de öyle çocuklara falan kalır diye değil,",
        "16": "ölmekten korktuğun halde ölüme inanmadığın için,",
        "17": "yaşamak yanı ağır bastığından...",
        "18": "236. Gün",
        "19": "Bugün ana sayfayı tamamladım. Kusurları olabilir, kötü bir tasarım da olabilir fakat ben genel manada beğendim. Şimdi sırada diğer sayfaları tamamlamak var.",
        "20": "237. Gün",
        "21": "Bugün anasayfada göstermem gereken bilgileri sizden edinip gösterecektim. KDV ile ilgili bilgiler için front end kısmını yazdıktan sonra backend’den çekmekte sorun yaşadım. Çekemedim. Hatamın nerede olduğunu çözemediğim için yapamadım. Sonrasında senior'lerimin yardımı ile bu durum tamamlandı (Her ne kadar yapmak için elimden geldiğince uğraşsam da o kısmı ben tamamlayamadım). Ben de front’a nasıl aktaracağımı ve gösterileceğini tamamlayacağım. Sonrasında kalan kısımları elimden geldiğince bitirmeye çalışacağım.",
        "22": "238. Gün",
        "23": "Bugün ana sayfada iki farklı veri daha gösterdim (aylık kar/zarar, gelir vergisine bağlı aylık satış tutarı). Sonrasında hesaplar sayfasını tamamladım. Ardından yeni hesap ekleme sayfasını düzenlemeye başladım fakat yarın öğlen biter diye düşünüyorum. Sonrasında hesap güncelleme sayfası da tamamlanması beklenmektedir.",
        "24": "239. Gün",
        "25": "Bugün “hesaplar, para birimi, ödeme yöntemleri” sayfalarını (/index, /edit, /create kısımlarını) düzenledim. Kategori sayfasında pagination’a gerek duyulduğu için o kısmı tekrar yazmak istedim (Aslında şu anda pagination çalışmakta fakat yeteri kadar iyi olduğunu düşünmüyorum). Yarın ilk iş o kısmı tamamlamaya çalışacağım. Tüm sayfalar için “/edit, /index, /create” sayfalarını şablon olarak oluşturunca tüm sayfalar benzerlik gösterdiği için sayfalarla ilgili spesifik kısımlar değiştirilerek hepsinde kullanılabiliyor. Bu yüzden çok zaman alacağa benzemiyor. Aksi belirtilmedikçe filtreleme ve arama kısımlarını son olarak eklemeyi düşünüyorum.",
        "26": "240. Gün",
        "27": "Bugün kategoriler sayfası tamamlandı. En çok vakit alan kısım pagination oldu. O da tamamlandı. Yarın fatura detayları sayfaları tamamlanmaya çalışılacak."
    },
    "part25": {
        "1": "241. Gün",
        "2": "Bugün satış faturalarının gösterildiği sayfa tamamlandı. Satış faturası ekleme sayfası tamamlanamadı. Yarın paraşütün sayfasının kopyası yapılmaya çalışılacak. Sonrasında da işlevler eklenecek.",
        "3": "242. Gün",
        "4": "Bugün toplantıda bahsettiği konular aklımdan çok çıkmamıştı ve biraz dalgındım. Onun dışında paraşüt’ün front end’inin benzerini şimdiye dek öğrendiğim yöntemlerle (flex gibi) yapacağım. ",
        "5": "243. Gün",
        "6": "Bugün yeni fatura ekleme sayfası üzerine çalışıldı. Paraşüt’teki ilgili sayfanın bir benzerini yapmaya çalıştım. Henüz tamamlanmadı. Ama yarın en azından static kısmı tamamlanıp işlevselliğin verilmesine başlanır diye düşünüyorum.",
        "7": "244. Gün",
        "8": "Bugün fatura sayfasının static kısmının çoğunluğunu tamamlamış olsam da henüz bitmedi. Detaylı bir şekilde tasarlarken ister istemez daha fazla zaman almakta. Yarın fatura ekleme sayfasını bitirmeye çalışacağım.",
        "9": "245. Gün",
        "10": "Sayfanın statik olarak çoğunluğu tamamlanmış olsa da beklediğimden çok zaman alıyor. Hedefim günde 1 sayfa tamamlamakken paraşütün tek bir fatura ekleme sayfasının temel ‘html/css/js’ kısmı 3 gün aldı (%90’ı). Ya ben çok yavaştım ya da sayfa gerçekten detaysız gibi görünse de detaylıydı. Ben ikinci seçeneğin doğru olduğunu düşünüyorum. Yarın öğle molasına kadar hızlıca statik kısımlardaki eksikleri tamamlayıp artık api’den gelen bilgileri sayfada göstermeye çalışacağım.",
        "11": "246. Gün",
        "12": "Satış faturası ekleme sayfasının statik kısmı tamamlandı. Mümkün oldukça paraşütün ilgili sayfasına benzetildi. Javascript’li kısımlar ister istemez daha çok mantıksal işlem içerdiği için biraz fazla zaman aldı. Yarın dinamik veriler eklenmeye başlanacak.",
        "13": "247. Gün",
        "14": "Bugün Api’den alınan verileri fatura ekleme sayfasında göstermeye başladım. Müşteri arama, vergi oranları, para birimi bilgileri gerekli kısımlarda gösterildi. Kategori, ürün ve etiket arama sonuçları da sayfada ilgili kısımlarda gösterilecek. Hesaplamaların da tekrar yapılması gerekebilir (Paraşütte bulunan ara toplama ve her ayrı ürüne indirim işlevleri eklendiği için). Son olarak da post ile verileri gönderme hata varsa gösterme işlemleri kalıyor.",
        "15": "Bu sayfa çok fazla zaman aldı. Gider faturaları sayfasına da benzeri bir yapı kurularak en azından orda daha az zaman harcanabilir.",
        "16": "248. Gün",
        "17": "Kategori araması, ürün araması, sayıların formatlandırılmasındaki yanlışlıklar bugün düzeltildi. Yarın ilk iş ürünler araması için yazmış olduğum kodda çok çok fazla event listener eklenmesi problemini halletmek. Sonrasında fatura hesaplamaları ve api’ye ilgili post request’inin gönderilmesi kısmını tamamlayacağım.",
        "18": "249. Gün",
        "19": "Bugün fatura ekleme sayfasındaki ürünlerin fiyat hesaplamalarının birçoğunu tamamladım. Brüt toplamını hesaplama kısmını ve seçili dövize göre toplam tutarın Türk Lirası karşılığını da yazdığımda sadece api’ye faturayı kaydetmek için post isteğini göndermek kalacak.",
        "20": "250. Gün",
        "21": "Bugün sayfayı tammaladım. Post ile veirleri gönderme kısmı kaldı. Onu da kısaca tamamlayacağım. Bu sayfa benim için başarısızlıktı. Javascript kodları çok karışıktı ve sadelikten eser yoktu. Bu sayfadan dersler çıkarıp diğer sayfalarda elimden geldiğince daha iyisini yazmaya çalışacağım.",
        "22": "251. Gün",
        "23": "Bugün satış faturası ekleme sayfası tamamlandı. İlgili API metotlarında hatalar bulunmaktaydı ve düzeltildi. ",
        "24": "Front end kodunda hata mesajlarının gösterimi, api request’inde verilerin uygun formatta gönderilmesi; veritabanındaki bazı sütunların doldurulmaması sorunu ile karşılaşınca ise ilgili repository ve model fix’lendi.",
        "25": "Yarın farklı bir sayfaya başlayacağım.",
        "26": "252. Gün",
        "27": "Bugün fatura ekleme sayfaları tamamlanmış oldu. Gider faturalarının listelendiği sayfada filtreleme ve arama kısmı eklendi. Fakat arama kısmında verilerin doğruluğu düşük olduğu için sonuçların gösterilmesi kısmı henüz yapılmadı. Sonrasında gider faturası düzenleme sayfasına başlandı. Yarın satış ve gider faturası düzenleme sayfaları tamamlanır diye tahmin ediliyor.",
        "28": "253. Gün",
        "29": "Bugün fatura güncelleme sayfalarının ikisinin de çoğunluğu tamamlandı. Hesaplamalar doğru yapılsa da format konusunda birkaç problem kaldı ama sonrasında o kısım düzeltilecek. Ayrıca backend kodunda ve veritabanında da düzeltmeler yapıldı (Bugün genel olarak bu düzeltmelerle geçti). Yarın satış faturası düzenleme sayfasının birkaç eksikliği giderildikten sonra fatura detayı sayfalarına başlanacaktır.",
        "30": "254. Gün",
        "31": "Bugün fatura ekleme/düzeltme sayfalarındaki eksikler tamamlanıp (sayı formatlama kısmında biraz pürüz kaldı) fatura detay/ödeme sayfasına başlangıç yapıldı.",
        "32": "Bugün performans düşüklüğü vardı. Akla takılan konular ve sorular çokça fazlaydı. Yöneticimin (öğretmenimin) ayrılması ve vedalaşılmaması (ghosting durumu) duygusal yönden epey kötü iz bıraktı. Gün içinde işe dikkatimi veremediğim bir an, “Mühendis nedir, ne iş yapar, kaç çeşit mühendis vardır?” isimli bizimle paylaştığınız makaleyi tekrar okudum.",
        "33": "\"Bugün bir kez daha anlıyorum ki, aslında hocalarım “mühendis kimdir ve ne iş yapar” sorularına en iyi cevabı bulmamı sağlamışlar. Mühendis problem çözer. Problem çözen mühendis doğu ve batının bakış açısının sentezidir, rapor yazar, verir ve okur. Mühendisin yazılı rapor vereni makbuldur. Rapor yazarken problem tanımlar, yaratıcı çözümler bulur, görmediklerini görme imkanı olur, yazdıklarını yorumlamak ve sonuç çıkarmak zorundadır ve yazı kalır sözse uçar gider. İyi rapor yazan mühendis iyi rapor okur, iyi sorgular. Bu gerçeği gören mühendis bireysel kurumsallaşmasını tamamlamıştır ve isterse çok iyi bir yönetici adayıdır. Bu gerçeğin farkında olan üst düzey yöneticiler ellerindeki hazinenin değerini bilirler. Göremeyenler ise maddi ve manevi kayıplarını daha sonra anlarlar.\"",
        "34": "Makaleyi yazan kadının ideal mühendis tanımlamaları benim yöneticime uyuyordu. Bana da uymalıydı çünkü ben de iyi bir mühendis olmayı istiyordum. Okulunu okumuştum, ama anlamıştım ki okulunu okumak yetmiyormuş. Mühendisliği tam anlamıyla bu ofiste gördüm ilk kez. İlk kez sihirden bu kadar çok etkilendim. Ve tabii ki illüzyon olduğunu öğrendim sonra. İllüzyonun farkına vardığımda öğrendiklerim eski seviyeme göre çok artmıştı ve dolayısıyla zihnimdeki telaş ve panik azalmaya başlamıştı.",
        "35": "Sanki benim intihar notum gibi bir yazı oldu ve rapor bağlamından epey uzaklaştı ama son raporda da birazcık duygusallık katma hakkı olabilir.",
        "36": "Hayatımdaki en büyük şans ve imkanlardan biri sizinle tanışmaktı. Bir hazine buldum. Elimden geldiğince hazineden bir şeyler kapmaya çalıştım. Hazineye de bu düşünsel fakirlikle bir şeyler katmaya çalıştım. Yeteneklerim az ya da çok nedir bilmesem de gayret ettim. Talih gayret edenden yanadır diye umarak büyük bir iştahla öğrenmeye, problemlere daha iyi çözümler bulmaya, insanlarla ve kendimle güzel ilişkiler oluşturmaya çalışacağım ve devam edeceğim. Sizin kadar iyi olmaya çalışmak ve sonrasında o seviyenin (varsa) de üzerine çıkabilmek şu an ki en büyük amacım.",
        "37": "Tanıştığım ve güzel bir bağ kurduğum için bu 11 aylık süre ve siz zihnimde çok çok çok değerli kalacaksınız diye düşünüyorum."
    },
    "part26": {
        "1": "",
        "2": "",
        "3": "",
        "4": "",
        "5": "",
        "6": "",
        "7": "",
        "8": "",
        "9": "",
        "10": "",
        "11": "",
        "12": "",
        "13": "",
        "14": "",
        "15": "",
        "16": "",
        "17": "",
        "18": "",
        "19": "",
        "20": "",
        "21": "",
        "22": "",
        "23": "",
        "24": "",
        "25": "",
        "26": "",
        "27": "",
        "28": "",
        "29": "",
        "30": "",
        "31": "",
        "32": "",
        "33": "",
        "34": "",
        "35": "",
        "36": "",
        "37": "",
        "38": "",
        "39": "",
        "40": "",
        "41": "",
        "42": "",
        "43": "",
        "44": "",
        "45": "",
        "46": "",
        "47": "",
        "48": "",
        "49": "",
        "50": "",
        "51": "",
        "52": "",
        "53": "",
        "54": "",
        "55": "",
        "56": "",
        "57": "",
        "58": "",
        "59": "",
        "60": "",
        "61": "",
        "62": "",
        "63": "",
        "64": "",
        "65": "",
        "66": "",
        "67": "",
        "68": "",
        "69": "",
        "70": ""
    }
}